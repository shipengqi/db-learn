<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="子查询#SQL 还允许创建子查询（subquery），即嵌套在其他查询中的查询。
利用子查询过滤#订单存储在两个表中。对于包含订单号、客户 ID、订单日期的每个订单，orders 表存储一行。各订单的物品存储在相关的 orderitems 表中。 orders 表不存储客户信息。它只存储客户的 ID。实际的客户信息存储在 customers 表中。
假如需要列出订购物品 TNT2 的所有客户，需要下面几步：
 检索包含物品 TNT2 的所有订单的编号。 检索具有前一步骤列出的订单编号的所有客户的 ID。 检索前一步骤返回的所有客户ID的客户信息。  # 检索包含物品 TNT2 的所有订单的编号 mysql&gt; select order_num from orderitems where pod_id= &#39;TNT2&#39;; &#43;-------------&#43; | order_num | &#43;-------------&#43; | 2005 | | 2007 | &#43;-------------&#43; # 查询具有订单 20005 和 20007 的客户 ID mysql&gt; select cust_id from orders where order_num in (2005,2007); &#43;-------------&#43; | cust_id | &#43;-------------&#43; | 1001 | | 1004 | &#43;-------------&#43; 把第一个查询（返回订单号的那一个）变为子查询组合两个查询:">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="MySQL 复杂查询语句" />
<meta property="og:description" content="子查询#SQL 还允许创建子查询（subquery），即嵌套在其他查询中的查询。
利用子查询过滤#订单存储在两个表中。对于包含订单号、客户 ID、订单日期的每个订单，orders 表存储一行。各订单的物品存储在相关的 orderitems 表中。 orders 表不存储客户信息。它只存储客户的 ID。实际的客户信息存储在 customers 表中。
假如需要列出订购物品 TNT2 的所有客户，需要下面几步：
 检索包含物品 TNT2 的所有订单的编号。 检索具有前一步骤列出的订单编号的所有客户的 ID。 检索前一步骤返回的所有客户ID的客户信息。  # 检索包含物品 TNT2 的所有订单的编号 mysql&gt; select order_num from orderitems where pod_id= &#39;TNT2&#39;; &#43;-------------&#43; | order_num | &#43;-------------&#43; | 2005 | | 2007 | &#43;-------------&#43; # 查询具有订单 20005 和 20007 的客户 ID mysql&gt; select cust_id from orders where order_num in (2005,2007); &#43;-------------&#43; | cust_id | &#43;-------------&#43; | 1001 | | 1004 | &#43;-------------&#43; 把第一个查询（返回订单号的那一个）变为子查询组合两个查询:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/db-learn/docs/mysql/04_advanced_query/" />
<meta property="article:modified_time" content="2020-06-17T17:45:14+08:00" />
<title>MySQL 复杂查询语句 | Database Learning</title>
<link rel="manifest" href="/db-learn/manifest.json">
<link rel="icon" href="/db-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/db-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/db-learn/en.search.min.79aa4caec43110b70bc10866de8e262ae56a148e0d75708b1522265755d59b70.js" integrity="sha256-eapMrsQxELcLwQhm3o4mKuVqFI4NdXCLFSImV1XVm3A="></script>

<script defer src="/db-learn/sw.min.b93542a5760842e2e25439dfb3c014a53a75c12fc8ef2e8e01a71b378f98e127.js" integrity="sha256-uTVCpXYIQuLiVDnfs8AUpTp1wS/I7y6OAacbN4&#43;Y4Sc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/db-learn"><span>Database Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/db-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li>
<p><strong>Mysql</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mysql/01_getting_started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mysql/02_install/">安裝</a></li>
<li>
  <a href="/db-learn/docs/mysql/03_query/">简单查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/04_advanced_query/"class=active>复杂查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/05_write_operation/">写操作</a></li>
<li>
  <a href="/db-learn/docs/mysql/06_other/">其他</a></li>
<li>
  <a href="/db-learn/docs/mysql/07_architecture/">基础架构</a></li>
<li>
  <a href="/db-learn/docs/mysql/08_config/">启动选项和配置文件</a></li>
<li>
  <a href="/db-learn/docs/mysql/09_character/">字符集和比较规则</a></li>
<li>
  <a href="/db-learn/docs/mysql/10_innodb-record-store-structure/">InnoDB 记录存储结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/11_innodb-page-structure/">InnoDB 数据页结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/12_b-tree/">B+ 树索引</a></li>
<li>
  <a href="/db-learn/docs/mysql/13_isolation-level/">事务的隔离级别</a></li>
<li>
  <a href="/db-learn/docs/mysql/14_lock/">锁</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>Redis</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/redis/01_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/redis/02_redis-config/">安装配置</a></li>
<li>
  <a href="/db-learn/docs/redis/03_redis-string/">数据类型 String</a></li>
<li>
  <a href="/db-learn/docs/redis/04_redis-hash/">数据类型 Hash</a></li>
<li>
  <a href="/db-learn/docs/redis/05_redis-set/">数据类型 Set</a></li>
<li>
  <a href="/db-learn/docs/redis/06_redis-sortedset/">数据类型 SortedSet</a></li>
<li>
  <a href="/db-learn/docs/redis/07_redis-list/">数据类型 List</a></li>
<li>
  <a href="/db-learn/docs/redis/08_redis-key/">Key 操作</a></li>
<li>
  <a href="/db-learn/docs/redis/09_sds/">简单动态字符串</a></li>
<li>
  <a href="/db-learn/docs/redis/10_dict/">字典</a></li>
<li>
  <a href="/db-learn/docs/redis/11_redis-object/">对象</a></li>
<li>
  <a href="/db-learn/docs/redis/12_bitmap/">位图</a></li>
<li>
  <a href="/db-learn/docs/redis/13_distributed-lock/">分布式锁</a></li>
<li>
  <a href="/db-learn/docs/redis/14_queue/">延时队列</a></li>
<li>
  <a href="/db-learn/docs/redis/15_hyperloglog/">HyperLogLog</a></li>
<li>
  <a href="/db-learn/docs/redis/16_bloom-filter/">布隆过滤器</a></li>
<li>
  <a href="/db-learn/docs/redis/17_current-limit/">限流</a></li>
<li>
  <a href="/db-learn/docs/redis/18_geohash/">GeoHash</a></li>
<li>
  <a href="/db-learn/docs/redis/19_persistence/">持久化</a></li>
<li>
  <a href="/db-learn/docs/redis/20_pipeline/">管道</a></li>
<li>
  <a href="/db-learn/docs/redis/21_transaction/">事务</a></li>
<li>
  <a href="/db-learn/docs/redis/22_sync/">主从同步</a></li>
<li>
  <a href="/db-learn/docs/redis/23_cluster/">集群</a></li>
<li>
  <a href="/db-learn/docs/redis/24_info/">INFO 指令</a></li>
<li>
  <a href="/db-learn/docs/redis/25_redis-expire-strategy/">过期策略和内存淘汰机制</a></li>
<li>
  <a href="/db-learn/docs/redis/26_protect-redis/">保护 Redis</a></li>
<li>
  <a href="/db-learn/docs/redis/27_skills/">一些命令行技巧</a></li>
<li>
  <a href="/db-learn/docs/redis/28_slowlog/">慢查询日志</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>MongoDB</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mongo/01_overview/">介绍</a></li>
<li>
  <a href="/db-learn/docs/mongo/02_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mongo/03_advance/">使用</a></li>
<li>
  <a href="/db-learn/docs/mongo/04_migrate/">数据迁移</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/db-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>MySQL 复杂查询语句</strong>

  <label for="toc-control">
    
    <img src="/db-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#子查询">子查询</a>
      <ul>
        <li><a href="#利用子查询过滤">利用子查询过滤</a></li>
        <li><a href="#作为计算字段使用子查询">作为计算字段使用子查询</a></li>
      </ul>
    </li>
    <li><a href="#联结表">联结表</a>
      <ul>
        <li><a href="#关系表">关系表</a></li>
        <li><a href="#创建联结">创建联结</a></li>
        <li><a href="#高级联结">高级联结</a></li>
      </ul>
    </li>
    <li><a href="#组合查询">组合查询</a>
      <ul>
        <li><a href="#union-规则">UNION 规则</a></li>
        <li><a href="#包含或取消重复的行">包含或取消重复的行</a></li>
        <li><a href="#组合查询结果排序">组合查询结果排序</a></li>
      </ul>
    </li>
    <li><a href="#全文本搜索">全文本搜索</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="子查询">
  子查询
  <a class="anchor" href="#%e5%ad%90%e6%9f%a5%e8%af%a2">#</a>
</h2>
<p>SQL 还允许创建子查询（subquery），即嵌套在其他查询中的查询。</p>
<h3 id="利用子查询过滤">
  利用子查询过滤
  <a class="anchor" href="#%e5%88%a9%e7%94%a8%e5%ad%90%e6%9f%a5%e8%af%a2%e8%bf%87%e6%bb%a4">#</a>
</h3>
<p>订单存储在两个表中。对于包含订单号、客户 ID、订单日期的每个订单，<code>orders</code> 表存储一行。各订单的物品存储在相关的 <code>orderitems</code> 表中。
<code>orders</code> 表不存储客户信息。它只存储客户的 ID。实际的客户信息存储在 <code>customers</code> 表中。</p>
<p>假如需要列出订购物品 TNT2 的所有客户，需要下面几步：</p>
<ol>
<li>检索包含物品 TNT2 的所有订单的编号。</li>
<li>检索具有前一步骤列出的订单编号的所有客户的 ID。</li>
<li>检索前一步骤返回的所有客户ID的客户信息。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 检索包含物品 TNT2 的所有订单的编号</span>
mysql&gt; <span style="color:#66d9ef">select</span> order_num from orderitems where pod_id<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;TNT2&#39;</span>;
+-------------+
| order_num   |
+-------------+
|      <span style="color:#ae81ff">2005</span>   |
|      <span style="color:#ae81ff">2007</span>   |
+-------------+

<span style="color:#75715e"># 查询具有订单 20005 和 20007 的客户 ID</span>
mysql&gt; <span style="color:#66d9ef">select</span> cust_id from orders where order_num in <span style="color:#f92672">(</span>2005,2007<span style="color:#f92672">)</span>;
+-------------+
|   cust_id   |
+-------------+
|      <span style="color:#ae81ff">1001</span>   |
|      <span style="color:#ae81ff">1004</span>   |
+-------------+
</code></pre></div><p>把第一个查询（返回订单号的那一个）变为子查询组合两个查询:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">mysql&gt; <span style="color:#66d9ef">select</span> cust_id from orders where order_num in <span style="color:#f92672">(</span><span style="color:#66d9ef">select</span> order_num from orderitems where pod_id<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;TNT2&#39;</span><span style="color:#f92672">)</span>;
+-------------+
|   cust_id   |
+-------------+
|      <span style="color:#ae81ff">1001</span>   |
|      <span style="color:#ae81ff">1004</span>   |
+-------------+
</code></pre></div><p><strong>子查询总是从内向外处理</strong>。在处理上面的 <code>SELECT</code> 语句时，MySQL <strong>实际上执行了两个操作</strong>。</p>
<p>进一步根据客户 id 查出客户信息：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> cust_name <span style="color:#66d9ef">from</span> customers <span style="color:#66d9ef">where</span> cust_id <span style="color:#66d9ef">in</span> (
<span style="color:#66d9ef">select</span> cust_id <span style="color:#66d9ef">from</span> orders <span style="color:#66d9ef">where</span> order_num <span style="color:#66d9ef">in</span> (<span style="color:#66d9ef">select</span> order_num <span style="color:#66d9ef">from</span> orderitems <span style="color:#66d9ef">where</span> pod_id<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;TNT2&#39;</span>));
</code></pre></div><blockquote>
<p>对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。
<strong>在 <code>WHERE</code> 子句中使用子查询，应该保证 <code>SELECT</code> 语句具有与 <code>WHERE</code> 子句中相同数目的列</strong>。通常，子查询将返回单个列并且与
单个列匹配，但如果需要也可以使用多个列。</p>
</blockquote>
<h3 id="作为计算字段使用子查询">
  作为计算字段使用子查询
  <a class="anchor" href="#%e4%bd%9c%e4%b8%ba%e8%ae%a1%e7%ae%97%e5%ad%97%e6%ae%b5%e4%bd%bf%e7%94%a8%e5%ad%90%e6%9f%a5%e8%af%a2">#</a>
</h3>
<p>子查询的另一方法是创建计算字段。</p>
<p>假如需要显示 <code>customers</code> 表中每个客户的订单总数。订单与相应的客户ID存储在 <code>orders</code> 表中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> cust_name, (<span style="color:#66d9ef">select</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> orders <span style="color:#66d9ef">where</span> orders.cust_id <span style="color:#f92672">=</span> customers.cust_id) <span style="color:#66d9ef">as</span> orders <span style="color:#66d9ef">from</span> customers <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> cust_name;
</code></pre></div><p><code>orders</code> 是一个计算字段，它是由圆括号中的子查询建立的。该子查询对检索出的每个客户执行一次。子查询中的 <code>WHERE</code> 子句使
用了<strong>完全限定列名</strong>。</p>
<h2 id="联结表">
  联结表
  <a class="anchor" href="#%e8%81%94%e7%bb%93%e8%a1%a8">#</a>
</h2>
<p>SQL 最强大的功能之一就是能在数据检索查询的执行中联结（<code>join</code>）表。</p>
<h3 id="关系表">
  关系表
  <a class="anchor" href="#%e5%85%b3%e7%b3%bb%e8%a1%a8">#</a>
</h3>
<p>假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。</p>
<p>现在，假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢？将这些数据与产品信息分开存储的理
由如下。</p>
<ul>
<li>因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。</li>
<li>如果供应商信息改变（例如，供应商搬家或电话号码变动），只需改动一次即可。</li>
<li>如果有重复数据（即每种产品都存储供应商信息），很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。
数据无重复，显然数据是一致的，这使得处理数据更简单。</li>
</ul>
<p><strong>相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础</strong>。关系表的设计就是要保证把信息分解成多个表，一类数据一个表。<strong>各表通过某
些常用的值（即关系设计中的关系（relational））互相关联</strong>。</p>
<h4 id="为什么使用联结表">
  为什么使用联结表
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e8%81%94%e7%bb%93%e8%a1%a8">#</a>
</h4>
<p>分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。如果数据存储在多个表中，怎样用单条 <code>SELECT</code>
语句检索出数据？</p>
<p>使用<strong>联结</strong>。</p>
<h3 id="创建联结">
  创建联结
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e8%81%94%e7%bb%93">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> vend_name, prod_name, prod_price <span style="color:#66d9ef">from</span> vendors, products <span style="color:#66d9ef">where</span> vendors.vend_id <span style="color:#f92672">=</span> products.vend_id <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> vend_name, prod_name;
</code></pre></div><p>列 <code>prod_name</code> 和 <code>prod_price</code> 在一个表中，而列 <code>vend_name</code> 在另一个表中。<code>FROM</code> 子句列出了两个表，分别是 <code>vendors</code> 和 <code>products</code>。
这两个表用 <code>WHERE</code> 子句联结。</p>
<blockquote>
<p><strong>笛卡儿积</strong>（cartesian product）由<strong>没有联结条件</strong>的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中
的行数。</p>
</blockquote>
<h4 id="内部联结">
  内部联结
  <a class="anchor" href="#%e5%86%85%e9%83%a8%e8%81%94%e7%bb%93">#</a>
</h4>
<p>目前为止所用的联结称为<strong>等值联结（equijoin）</strong>，它基于两个表之间的相等测试。这种联结也称为<strong>内部联结</strong>。其实，对于这种联结可以使用稍
微不同的语法来明确指定联结的类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> vend_name, prod_name, prod_price <span style="color:#66d9ef">from</span> vendors <span style="color:#66d9ef">inner</span> <span style="color:#66d9ef">join</span> products <span style="color:#66d9ef">on</span> vendors.vend_id <span style="color:#f92672">=</span> products.vend_id;
</code></pre></div><p>此语句中的 <code>FROM</code> 子句与上面的不同。两个表之间的关系是 <code>FROM</code> 子句的组成部分，以 <strong><code>INNER JOIN</code></strong> 指定。在使用这种语法时，联
结条件用特定的 <strong><code>ON</code>子句</strong> 而不是 <code>WHERE</code> 子句给出。传递给 <code>ON</code> 的实际条件与传递给 <code>WHERE</code> 的相同。</p>
<blockquote>
<p><strong>SQL 规范首选 <code>INNER JOIN</code> 语法。此外，尽管使用 <code>WHERE</code> 子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，
有时候这样做也能影响性能。不要联结不必要的表。联结的表越多，性能下降越厉害</strong>。</p>
</blockquote>
<p>当两张表的数据量比较大，又需要连接查询时，应该使用 <code>FROM table1 JOIN table2 ON xxx</code> 的语法，避免使
用 <code>FROM table1,table2 WHERE xxx</code> 的语法，因为后者会在内存中先生成一张数据量比较大的笛卡尔积表，增加了内存的开销。</p>
<h4 id="联结多个表">
  联结多个表
  <a class="anchor" href="#%e8%81%94%e7%bb%93%e5%a4%9a%e4%b8%aa%e8%a1%a8">#</a>
</h4>
<p>SQL 对一条 SELECT 语句中可以联结的表的数目没有限制。</p>
<p>使用前面子查询的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> cust_name <span style="color:#66d9ef">from</span> customers <span style="color:#66d9ef">where</span> cust_id <span style="color:#66d9ef">in</span> (
<span style="color:#66d9ef">select</span> cust_id <span style="color:#66d9ef">from</span> orders <span style="color:#66d9ef">where</span> order_num <span style="color:#66d9ef">in</span> (<span style="color:#66d9ef">select</span> order_num <span style="color:#66d9ef">from</span> orderitems <span style="color:#66d9ef">where</span> pod_id <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;TNT2&#39;</span>));
</code></pre></div><p>可以改造为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> cust_name <span style="color:#66d9ef">from</span> customers, orders, orderitems
<span style="color:#66d9ef">where</span> customers.cust_id <span style="color:#f92672">=</span> orders.cust_id
<span style="color:#66d9ef">and</span> orderitems.order_num <span style="color:#f92672">=</span> orders.order_num
<span style="color:#66d9ef">and</span> pod_id <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;TNT2&#39;</span>;
</code></pre></div><h3 id="高级联结">
  高级联结
  <a class="anchor" href="#%e9%ab%98%e7%ba%a7%e8%81%94%e7%bb%93">#</a>
</h3>
<h4 id="表别名">
  表别名
  <a class="anchor" href="#%e8%a1%a8%e5%88%ab%e5%90%8d">#</a>
</h4>
<p>使用表别名：</p>
<ul>
<li>缩短 SQL 语句</li>
<li>允许在单条 <code>SELECT</code> 语句中多次使用相同的表</li>
</ul>
<p><strong>使用表别名的主要原因之一是能在单条 <code>SELECT</code> 语句中不止一次引用相同的表</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> cust_name <span style="color:#66d9ef">from</span> customers <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">c</span>, orders <span style="color:#66d9ef">as</span> o, orderitems <span style="color:#66d9ef">as</span> oi
<span style="color:#66d9ef">where</span> <span style="color:#66d9ef">c</span>.cust_id <span style="color:#f92672">=</span> o.cust_id
<span style="color:#66d9ef">and</span> oi.order_num <span style="color:#f92672">=</span> o.order_num
<span style="color:#66d9ef">and</span> pod_id <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;TNT2&#39;</span>;
</code></pre></div><p>与上面的例子功能一样，却更简短。</p>
<h4 id="不同类型的联结">
  不同类型的联结
  <a class="anchor" href="#%e4%b8%8d%e5%90%8c%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%81%94%e7%bb%93">#</a>
</h4>
<p>内部联结或等值联结（equijoin）是简单联结。其他联结类型有自联结、自然联结和外部联结。</p>
<h5 id="自联结">
  自联结
  <a class="anchor" href="#%e8%87%aa%e8%81%94%e7%bb%93">#</a>
</h5>
<p>假如你发现某物品（其 ID 为 DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。
此查询要求首先找到生产 ID 为 DTNTR 的物品的供应商，然后找出这个供应商生产的其他物品：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> prod_id, prod_name <span style="color:#66d9ef">from</span> products <span style="color:#66d9ef">where</span> vend_id <span style="color:#f92672">=</span> (<span style="color:#66d9ef">select</span> vend_id <span style="color:#66d9ef">from</span> products <span style="color:#66d9ef">where</span> prod_id <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;DTNTR&#39;</span>);

<span style="color:#66d9ef">select</span> p1.prod_id, p1.prod_name <span style="color:#66d9ef">from</span> products <span style="color:#66d9ef">as</span> p1, products <span style="color:#66d9ef">as</span> p2 <span style="color:#66d9ef">where</span> p1.vend_id <span style="color:#f92672">=</span> p2.vend_id an dp2.prod_id <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;DTNTR&#39;</span>;
</code></pre></div><p>上面第一条使用了子查询，第二条使用了联结，并且一个表使用了两次。</p>
<blockquote>
<p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应
该试一下两种方法，以确定哪一种的性能更好。</p>
</blockquote>
<h5 id="自然联结">
  自然联结
  <a class="anchor" href="#%e8%87%aa%e7%84%b6%e8%81%94%e7%bb%93">#</a>
</h5>
<p>标准的联结返回所有数据，甚至相同的列多次出现。<strong>自然联结</strong>排除多次出现，使每个列只返回一次。</p>
<p>事实上，很可能永远都不会用到不是自然联结的内部联结。</p>
<h5 id="外部联结">
  外部联结
  <a class="anchor" href="#%e5%a4%96%e9%83%a8%e8%81%94%e7%bb%93">#</a>
</h5>
<p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。例如，可能需要使用联结来完成以下工作：</p>
<ul>
<li>对每个客户下了多少订单进行计数，包括那些至今尚未下订单的客户；</li>
<li>列出所有产品以及订购数量，包括没有人订购的产品；</li>
<li>计算平均销售规模，包括那些至今尚未下订单的客户。</li>
</ul>
<p>在上述例子中，联结包含了那些在相关表中没有关联行的行。这种类型的联结称为<strong>外部联结</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> customers.cust_id, orders.order_num <span style="color:#66d9ef">from</span> customers <span style="color:#66d9ef">inner</span> <span style="color:#66d9ef">join</span> orders <span style="color:#66d9ef">on</span> customers.cust_id <span style="color:#f92672">=</span> orders.cust_id;
</code></pre></div><p>上面的语句很简单，就是检索所有客户及其订单。那么如果想要检索所有客户，包括没有订单的客户，如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> customers.cust_id, orders.order_num <span style="color:#66d9ef">from</span> customers <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">outer</span> <span style="color:#66d9ef">join</span> orders <span style="color:#66d9ef">on</span> customers.cust_id <span style="color:#f92672">=</span> orders.cust_id;
</code></pre></div><p>这条语句使用了关键字 <code>OUTER JOIN</code> 来指定联结的类型。外部联结还包括没有关联行的行。在使用 <code>OUTER JOIN</code> 语法时，必须使用 <strong><code>RIGHT</code>
或 <code>LEFT</code> 关键字指定包括其所有行的表</strong>（<code>RIGHT</code> 指的是 <code>OUTER JOIN</code> 右边的表，而 <code>LEFT</code> 指的是 <code>OUTER JOIN</code> 左边的表）。</p>
<p>上面的例子使用 <code>LEFT OUTER JOIN</code> 从 <code>FROM</code> 子句的左边表（<code>customers</code> 表）中选择所有行。</p>
<blockquote>
<p>可通过颠倒 FROM 或 WHERE 子句中表的顺序，来转换外部联结形式。两种类型的外部联结可互换使用，而究竟使用哪一种纯粹是根据方便而定。</p>
</blockquote>
<h4 id="带聚集函数的联结">
  带聚集函数的联结
  <a class="anchor" href="#%e5%b8%a6%e8%81%9a%e9%9b%86%e5%87%bd%e6%95%b0%e7%9a%84%e8%81%94%e7%bb%93">#</a>
</h4>
<p>检索所有客户及每个客户所下的订单数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> customers.cust_id, <span style="color:#66d9ef">COUNT</span>(orders.order_num) <span style="color:#66d9ef">as</span> num_ord <span style="color:#66d9ef">from</span> customers <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">outer</span> <span style="color:#66d9ef">join</span> orders <span style="color:#66d9ef">on</span> customers.cust_id <span style="color:#f92672">=</span> orders.cust_id <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> customers.cust_id;
</code></pre></div><h2 id="组合查询">
  组合查询
  <a class="anchor" href="#%e7%bb%84%e5%90%88%e6%9f%a5%e8%af%a2">#</a>
</h2>
<p>MySQL 也允许执行多个查询（多条 <code>SELECT</code> 语句），并将结果作为单个查询结果集返回。这些组合查询通常称为<strong>并</strong>（<code>union</code>）或
<strong>复合查询</strong>（<code>compound query</code>）。</p>
<p>需要使用组合查询的情况：</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据；</li>
<li>对单个表执行多个查询，按单个查询返回数据。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> vend_id, prod_id, prod_price <span style="color:#66d9ef">from</span> products <span style="color:#66d9ef">where</span> prod_price <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">5</span>
<span style="color:#66d9ef">union</span>
<span style="color:#66d9ef">select</span> vend_id, prod_id, prod_price <span style="color:#66d9ef">from</span> products <span style="color:#66d9ef">where</span> vend_id <span style="color:#66d9ef">in</span> (<span style="color:#ae81ff">1001</span>,<span style="color:#ae81ff">1002</span>);
</code></pre></div><p>转成多条 <code>where</code> 子句的写法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> vend_id, prod_id, prod_price <span style="color:#66d9ef">from</span> products <span style="color:#66d9ef">where</span> prod_price <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">5</span> <span style="color:#66d9ef">or</span> vend_id <span style="color:#66d9ef">in</span> (<span style="color:#ae81ff">1001</span>,<span style="color:#ae81ff">1002</span>);
</code></pre></div><blockquote>
<p>任何具有多个 <code>WHERE</code> 子句的 <code>SELECT</code> 语句都可以作为一个组合查询给出。这两种技术在不同的查询中性能也不同。因此，应该试一下这
两种技术，以确定对特定的查询哪一种性能更好。</p>
</blockquote>
<h3 id="union-规则">
  UNION 规则
  <a class="anchor" href="#union-%e8%a7%84%e5%88%99">#</a>
</h3>
<ul>
<li><code>UNION</code> 必须由两条或两条以上的 <code>SELECT</code> 语句组成，语句之间用关键字 <code>UNION</code> 分隔。</li>
<li><code>UNION</code> 中的每个查询<strong>必须包含相同的列、表达式或聚集函数</strong>（不过各个列不需要以相同的次序列出）。</li>
<li><strong>列数据类型必须兼容</strong>：类型不必完全相同，但必须是 DBMS 可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li>
</ul>
<h3 id="包含或取消重复的行">
  包含或取消重复的行
  <a class="anchor" href="#%e5%8c%85%e5%90%ab%e6%88%96%e5%8f%96%e6%b6%88%e9%87%8d%e5%a4%8d%e7%9a%84%e8%a1%8c">#</a>
</h3>
<p><code>UNION</code> 从查询结果集中<strong>自动去除了重复的行</strong>。如果想返回所有匹配行，可使用 <code>UNION ALL</code> 而不是 <code>UNION</code>。</p>
<h3 id="组合查询结果排序">
  组合查询结果排序
  <a class="anchor" href="#%e7%bb%84%e5%90%88%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e6%8e%92%e5%ba%8f">#</a>
</h3>
<p><strong>用 <code>UNION</code> 组合查询时，只能使用一条 <code>ORDER BY</code> 子句，它必须出现在最后一条 <code>SELECT</code> 语句之后</strong>。对于结果集，不存在用一种方式排序一
部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条 <code>ORDER BY</code> 子句。</p>
<h2 id="全文本搜索">
  全文本搜索
  <a class="anchor" href="#%e5%85%a8%e6%96%87%e6%9c%ac%e6%90%9c%e7%b4%a2">#</a>
</h2>
<p>两个最常使用的引擎为 <code>MyISAM</code> 和 <code>InnoDB</code>，前者支持全文本搜索，而后者不支持。</p>
<p>使用 MySQL 的 <code>Match()</code> 和 <code>Against()</code> 函数进行全文本搜索。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/db-learn/commit/391abafbb55e9e09f274b9823c6b411133314e4f" title='Last modified by shipengqi | June 17, 2020' target="_blank" rel="noopener">
      <img src="/db-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 17, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/db-learn/edit/master/content//docs/mysql/04_advanced_query.md" target="_blank" rel="noopener">
      <img src="/db-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#子查询">子查询</a>
      <ul>
        <li><a href="#利用子查询过滤">利用子查询过滤</a></li>
        <li><a href="#作为计算字段使用子查询">作为计算字段使用子查询</a></li>
      </ul>
    </li>
    <li><a href="#联结表">联结表</a>
      <ul>
        <li><a href="#关系表">关系表</a></li>
        <li><a href="#创建联结">创建联结</a></li>
        <li><a href="#高级联结">高级联结</a></li>
      </ul>
    </li>
    <li><a href="#组合查询">组合查询</a>
      <ul>
        <li><a href="#union-规则">UNION 规则</a></li>
        <li><a href="#包含或取消重复的行">包含或取消重复的行</a></li>
        <li><a href="#组合查询结果排序">组合查询结果排序</a></li>
      </ul>
    </li>
    <li><a href="#全文本搜索">全文本搜索</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












