<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Redis Key 操作#在日常开发中，查找某个，或某些铁定前缀的 key，修改他们的值，删除 key，都是很常用的操作。 Redis 如何从海量的 key 中找出满足特 定前缀的key列表？
Redis 的 keys 指令。
Redis 允许的最大 Key 长度是 512MB（对 Value 的长度限制也是 512MB），但是尽量不要使用过长的 key，不仅会消耗更多的 内存，还会导致查找的效率降低。key 也不应该过于短，开发中应该使用统一的规范来设计 key，可读性好，也易于维护。比 如 user:&lt;user id&gt;:followers。
查找删除#KEYS#按指定的正则匹配模式 pattern 查找 key。
KEYS pattern  KEYS * 匹配数据库中所有的 key KEYS h?llo 匹配 hello、hallo、hxllo 等 KEYS h*llo 匹配 hllo、heeeeello等 KEYS h[ae]llo 匹配 hello、hallo，但不匹配 hillo  KEYS 指令非常简单，但是有两个缺点：
 没有 offset、limit 参数，会返回所有匹配到的 key。 执行 KEYS 会遍历所有的 key，如果 Redis 存储了海量的 key，由于 Redis 是单线程，KEYS 指令就会阻塞其他指令，直 到 KEYS 执行完毕。  所以在数据量很大的情况下，不建议使用 KEYS，会造成 Redis 服务卡顿，导致其他的指令延时甚至超时报错。 Redis 提供了 SCAN 指令来解决这个问题。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="Redis Key 操作" />
<meta property="og:description" content="Redis Key 操作#在日常开发中，查找某个，或某些铁定前缀的 key，修改他们的值，删除 key，都是很常用的操作。 Redis 如何从海量的 key 中找出满足特 定前缀的key列表？
Redis 的 keys 指令。
Redis 允许的最大 Key 长度是 512MB（对 Value 的长度限制也是 512MB），但是尽量不要使用过长的 key，不仅会消耗更多的 内存，还会导致查找的效率降低。key 也不应该过于短，开发中应该使用统一的规范来设计 key，可读性好，也易于维护。比 如 user:&lt;user id&gt;:followers。
查找删除#KEYS#按指定的正则匹配模式 pattern 查找 key。
KEYS pattern  KEYS * 匹配数据库中所有的 key KEYS h?llo 匹配 hello、hallo、hxllo 等 KEYS h*llo 匹配 hllo、heeeeello等 KEYS h[ae]llo 匹配 hello、hallo，但不匹配 hillo  KEYS 指令非常简单，但是有两个缺点：
 没有 offset、limit 参数，会返回所有匹配到的 key。 执行 KEYS 会遍历所有的 key，如果 Redis 存储了海量的 key，由于 Redis 是单线程，KEYS 指令就会阻塞其他指令，直 到 KEYS 执行完毕。  所以在数据量很大的情况下，不建议使用 KEYS，会造成 Redis 服务卡顿，导致其他的指令延时甚至超时报错。 Redis 提供了 SCAN 指令来解决这个问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/db-learn/docs/redis/08_redis-key/" />
<meta property="article:modified_time" content="2020-06-17T17:45:14+08:00" />
<title>Redis Key 操作 | Database Learning</title>
<link rel="manifest" href="/db-learn/manifest.json">
<link rel="icon" href="/db-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/db-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/db-learn/en.search.min.79aa4caec43110b70bc10866de8e262ae56a148e0d75708b1522265755d59b70.js" integrity="sha256-eapMrsQxELcLwQhm3o4mKuVqFI4NdXCLFSImV1XVm3A="></script>

<script defer src="/db-learn/sw.min.b93542a5760842e2e25439dfb3c014a53a75c12fc8ef2e8e01a71b378f98e127.js" integrity="sha256-uTVCpXYIQuLiVDnfs8AUpTp1wS/I7y6OAacbN4&#43;Y4Sc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/db-learn"><span>Database Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/db-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li>
<p><strong>Mysql</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mysql/01_getting_started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mysql/02_install/">安裝</a></li>
<li>
  <a href="/db-learn/docs/mysql/03_query/">简单查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/04_advanced_query/">复杂查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/05_write_operation/">写操作</a></li>
<li>
  <a href="/db-learn/docs/mysql/06_other/">其他</a></li>
<li>
  <a href="/db-learn/docs/mysql/07_architecture/">基础架构</a></li>
<li>
  <a href="/db-learn/docs/mysql/08_config/">启动选项和配置文件</a></li>
<li>
  <a href="/db-learn/docs/mysql/09_character/">字符集和比较规则</a></li>
<li>
  <a href="/db-learn/docs/mysql/10_innodb-record-store-structure/">InnoDB 记录存储结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/11_innodb-page-structure/">InnoDB 数据页结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/12_b-tree/">B+ 树索引</a></li>
<li>
  <a href="/db-learn/docs/mysql/13_isolation-level/">事务的隔离级别</a></li>
<li>
  <a href="/db-learn/docs/mysql/14_lock/">锁</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>Redis</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/redis/01_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/redis/02_redis-config/">安装配置</a></li>
<li>
  <a href="/db-learn/docs/redis/03_redis-string/">数据类型 String</a></li>
<li>
  <a href="/db-learn/docs/redis/04_redis-hash/">数据类型 Hash</a></li>
<li>
  <a href="/db-learn/docs/redis/05_redis-set/">数据类型 Set</a></li>
<li>
  <a href="/db-learn/docs/redis/06_redis-sortedset/">数据类型 SortedSet</a></li>
<li>
  <a href="/db-learn/docs/redis/07_redis-list/">数据类型 List</a></li>
<li>
  <a href="/db-learn/docs/redis/08_redis-key/"class=active>Key 操作</a></li>
<li>
  <a href="/db-learn/docs/redis/09_sds/">简单动态字符串</a></li>
<li>
  <a href="/db-learn/docs/redis/10_dict/">字典</a></li>
<li>
  <a href="/db-learn/docs/redis/11_redis-object/">对象</a></li>
<li>
  <a href="/db-learn/docs/redis/12_bitmap/">位图</a></li>
<li>
  <a href="/db-learn/docs/redis/13_distributed-lock/">分布式锁</a></li>
<li>
  <a href="/db-learn/docs/redis/14_queue/">延时队列</a></li>
<li>
  <a href="/db-learn/docs/redis/15_hyperloglog/">HyperLogLog</a></li>
<li>
  <a href="/db-learn/docs/redis/16_bloom-filter/">布隆过滤器</a></li>
<li>
  <a href="/db-learn/docs/redis/17_current-limit/">限流</a></li>
<li>
  <a href="/db-learn/docs/redis/18_geohash/">GeoHash</a></li>
<li>
  <a href="/db-learn/docs/redis/19_persistence/">持久化</a></li>
<li>
  <a href="/db-learn/docs/redis/20_pipeline/">管道</a></li>
<li>
  <a href="/db-learn/docs/redis/21_transaction/">事务</a></li>
<li>
  <a href="/db-learn/docs/redis/22_sync/">主从同步</a></li>
<li>
  <a href="/db-learn/docs/redis/23_cluster/">集群</a></li>
<li>
  <a href="/db-learn/docs/redis/24_info/">INFO 指令</a></li>
<li>
  <a href="/db-learn/docs/redis/25_redis-expire-strategy/">过期策略和内存淘汰机制</a></li>
<li>
  <a href="/db-learn/docs/redis/26_protect-redis/">保护 Redis</a></li>
<li>
  <a href="/db-learn/docs/redis/27_skills/">一些命令行技巧</a></li>
<li>
  <a href="/db-learn/docs/redis/28_slowlog/">慢查询日志</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>MongoDB</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mongo/01_overview/">介绍</a></li>
<li>
  <a href="/db-learn/docs/mongo/02_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mongo/03_advance/">使用</a></li>
<li>
  <a href="/db-learn/docs/mongo/04_migrate/">数据迁移</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/db-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Redis Key 操作</strong>

  <label for="toc-control">
    
    <img src="/db-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#查找删除">查找删除</a>
      <ul>
        <li><a href="#keys">KEYS</a></li>
        <li><a href="#exists">EXISTS</a></li>
        <li><a href="#randomkey">RANDOMKEY</a></li>
        <li><a href="#type">TYPE</a></li>
        <li><a href="#sort">SORT</a></li>
        <li><a href="#del">DEL</a></li>
      </ul>
    </li>
    <li><a href="#重命名">重命名</a>
      <ul>
        <li><a href="#rename">RENAME</a></li>
        <li><a href="#renamenx">RENAMENX</a></li>
      </ul>
    </li>
    <li><a href="#序列化和反序列化">序列化和反序列化</a>
      <ul>
        <li><a href="#dump">DUMP</a></li>
        <li><a href="#restore">RESTORE</a></li>
      </ul>
    </li>
    <li><a href="#生存时间">生存时间</a>
      <ul>
        <li><a href="#expire">EXPIRE</a></li>
        <li><a href="#expireat">EXPIREAT</a></li>
        <li><a href="#persist">PERSIST</a></li>
        <li><a href="#persistat">PERSISTAT</a></li>
        <li><a href="#ttl">TTL</a></li>
        <li><a href="#pttl">PTTL</a></li>
      </ul>
    </li>
    <li><a href="#迁移">迁移</a>
      <ul>
        <li><a href="#migrate">MIGRATE</a></li>
        <li><a href="#move">MOVE</a></li>
      </ul>
    </li>
    <li><a href="#scan">SCAN</a>
      <ul>
        <li><a href="#scan-对比-keys">SCAN 对比 KEYS</a></li>
        <li><a href="#字典结构">字典结构</a></li>
        <li><a href="#scan-遍历顺序">scan 遍历顺序</a></li>
        <li><a href="#大-key-扫描">大 key 扫描</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="redis-key-操作">
  Redis Key 操作
  <a class="anchor" href="#redis-key-%e6%93%8d%e4%bd%9c">#</a>
</h1>
<p>在日常开发中，查找某个，或某些铁定前缀的 <code>key</code>，修改他们的值，删除 <code>key</code>，都是很常用的操作。 Redis 如何从海量的 <code>key</code> 中找出满足特
定前缀的<code>key</code>列表？</p>
<p>Redis 的 <code>keys</code> 指令。</p>
<p>Redis 允许的最大 <code>Key</code> 长度是 <code>512MB</code>（对 <code>Value</code> 的长度限制也是 <code>512MB</code>），<strong>但是尽量不要使用过长的 <code>key</code>，不仅会消耗更多的
内存，还会导致查找的效率降低。<code>key</code> 也不应该过于短，开发中应该使用统一的规范来设计 <code>key</code>，可读性好，也易于维护。比
如 <code>user:&lt;user id&gt;:followers</code></strong>。</p>
<h2 id="查找删除">
  查找删除
  <a class="anchor" href="#%e6%9f%a5%e6%89%be%e5%88%a0%e9%99%a4">#</a>
</h2>
<h3 id="keys">
  KEYS
  <a class="anchor" href="#keys">#</a>
</h3>
<p>按指定的正则匹配模式 <code>pattern</code> 查找 <code>key</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">KEYS pattern
</code></pre></div><ul>
<li><code>KEYS *</code> 匹配数据库中所有的 <code>key</code></li>
<li><code>KEYS h?llo</code> 匹配 hello、hallo、hxllo 等</li>
<li><code>KEYS h*llo</code> 匹配 hllo、heeeeello等</li>
<li><code>KEYS h[ae]llo</code> 匹配 hello、hallo，但不匹配 hillo</li>
</ul>
<p><code>KEYS</code> 指令非常简单，但是有两个缺点：</p>
<ul>
<li>没有 <code>offset</code>、<code>limit</code> 参数，会返回所有匹配到的 <code>key</code>。</li>
<li><strong>执行 <code>KEYS</code> 会遍历所有的 <code>key</code>，如果 Redis 存储了海量的 <code>key</code>，由于 Redis 是单线程，<code>KEYS</code> 指令就会阻塞其他指令</strong>，直
到 <code>KEYS</code> 执行完毕。</li>
</ul>
<p>所以在数据量很大的情况下，不建议使用 <code>KEYS</code>，会造成 Redis 服务卡顿，导致其他的指令延时甚至超时报错。
Redis 提供了 <code>SCAN</code> 指令来解决这个问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 4 个测试数据</span>
redis&gt; MSET one <span style="color:#ae81ff">1</span> two <span style="color:#ae81ff">2</span> three <span style="color:#ae81ff">3</span> four <span style="color:#ae81ff">4</span>
OK

redis&gt; KEYS *o*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;four&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;two&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;one&#34;</span>

redis&gt; KEYS t??
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;two&#34;</span>

redis&gt; KEYS t<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span>*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;two&#34;</span>

<span style="color:#75715e"># 匹配数据库内所有 key</span>
redis&gt; KEYS *
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;four&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;three&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;two&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;one&#34;</span>
</code></pre></div><h3 id="exists">
  EXISTS
  <a class="anchor" href="#exists">#</a>
</h3>
<p>判断 <code>key</code> 是否存在。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">EXISTS key
</code></pre></div><p>存在返回 <code>1</code>，不存在返回 <code>0</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis&gt; SET db <span style="color:#e6db74">&#34;redis&#34;</span>
OK

redis&gt; EXISTS db
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>

redis&gt; DEL db
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>

redis&gt; EXISTS db
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h3 id="randomkey">
  RANDOMKEY
  <a class="anchor" href="#randomkey">#</a>
</h3>
<p>随机返回一个 <code>key</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 设置多个 key</span>
redis&gt; MSET fruit <span style="color:#e6db74">&#34;apple&#34;</span> drink <span style="color:#e6db74">&#34;beer&#34;</span> food <span style="color:#e6db74">&#34;cookies&#34;</span>
OK

redis&gt; RANDOMKEY
<span style="color:#e6db74">&#34;fruit&#34;</span>

redis&gt; RANDOMKEY
<span style="color:#e6db74">&#34;food&#34;</span>

<span style="color:#75715e"># 返回 key 但不删除</span>
redis&gt; KEYS *
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;food&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;drink&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;fruit&#34;</span>

<span style="color:#75715e"># 删除当前数据库所有 key，数据库为空</span>
redis&gt; FLUSHDB
OK
redis&gt; RANDOMKEY
<span style="color:#f92672">(</span>nil<span style="color:#f92672">)</span>
</code></pre></div><h3 id="type">
  TYPE
  <a class="anchor" href="#type">#</a>
</h3>
<p>返回 <code>key</code> 的值的类型。<code>key</code> 不存在返回 <code>none</code>，否则返回值得类型 <code>string</code>，<code>list</code>，<code>set</code>，<code>zset</code>，<code>hash</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 字符串</span>
redis&gt; SET weather <span style="color:#e6db74">&#34;sunny&#34;</span>
OK
redis&gt; TYPE weather
string

<span style="color:#75715e"># 列表</span>
redis&gt; LPUSH book_list <span style="color:#e6db74">&#34;programming in scala&#34;</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
redis&gt; TYPE book_list
list

<span style="color:#75715e"># 集合</span>
redis&gt; SADD pat <span style="color:#e6db74">&#34;dog&#34;</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
redis&gt; TYPE pat
set
</code></pre></div><h3 id="sort">
  SORT
  <a class="anchor" href="#sort">#</a>
</h3>
<p>返回指定 <code>key</code> 中元素,并对元素进行排序，<code>key</code> 的类型是列表、集合、有序集合。排序默认以数字作为对象，值被解释为双精度浮点数，然后进
行比较。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">SORT key <span style="color:#f92672">[</span>BY pattern<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>LIMIT offset count<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>GET pattern <span style="color:#f92672">[</span>GET pattern ...<span style="color:#f92672">]]</span> <span style="color:#f92672">[</span>ASC | DESC<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>ALPHA<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>STORE destination<span style="color:#f92672">]</span>
</code></pre></div><h4 id="简单用法">
  简单用法
  <a class="anchor" href="#%e7%ae%80%e5%8d%95%e7%94%a8%e6%b3%95">#</a>
</h4>
<ul>
<li><code>SORT key</code>，按从大到小顺序排序</li>
<li><code>SORT key DESC</code>，按从小到大的顺序排序</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 开销金额列表</span>
redis&gt; LPUSH today_cost <span style="color:#ae81ff">30</span> 1.5 <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">8</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">4</span>

<span style="color:#75715e"># 排序</span>
redis&gt; SORT today_cost
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1.5&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;8&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;10&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;30&#34;</span>

<span style="color:#75715e"># 倒序</span>
redis&gt; SORT today_cost DESC
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;30&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;10&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;8&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1.5&#34;</span>
</code></pre></div><h4 id="alpha-排序">
  ALPHA 排序
  <a class="anchor" href="#alpha-%e6%8e%92%e5%ba%8f">#</a>
</h4>
<p><code>SORT</code> 默认以数字作为对象排序，如果需要对字符串进行排序，使用 <code>ALPHA</code> 参数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 网址</span>

redis&gt; LPUSH website <span style="color:#e6db74">&#34;www.reddit.com&#34;</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>

redis&gt; LPUSH website <span style="color:#e6db74">&#34;www.slashdot.com&#34;</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">2</span>

redis&gt; LPUSH website <span style="color:#e6db74">&#34;www.infoq.com&#34;</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">3</span>

<span style="color:#75715e"># 默认（按数字）排序</span>

redis&gt; SORT website
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;www.infoq.com&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;www.slashdot.com&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;www.reddit.com&#34;</span>

<span style="color:#75715e"># 按字符排序</span>

redis&gt; SORT website ALPHA
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;www.infoq.com&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;www.reddit.com&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;www.slashdot.com&#34;</span>
</code></pre></div><h4 id="使用-limit">
  使用 LIMIT
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8-limit">#</a>
</h4>
<p>类似 SQL 的分页查询，两个参数：</p>
<ul>
<li>offset，指定偏移量</li>
<li>count，指定返回数量</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 添加测试数据，列表值为 1 指 10</span>
redis&gt; RPUSH rank <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">9</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">5</span>

redis&gt; RPUSH rank <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">8</span> <span style="color:#ae81ff">10</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">10</span>

<span style="color:#75715e"># 返回列表中最小的 5 个值</span>
redis&gt; SORT rank LIMIT <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">5</span>
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;2&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;3&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;4&#34;</span>
5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;5&#34;</span>

<span style="color:#75715e"># 使用排序</span>
redis&gt; SORT rank LIMIT <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">5</span> DESC
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;10&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;9&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;8&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;7&#34;</span>
5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;6&#34;</span>
</code></pre></div><h4 id="使用外部-key-进行排序">
  使用外部 key 进行排序
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e5%a4%96%e9%83%a8-key-%e8%bf%9b%e8%a1%8c%e6%8e%92%e5%ba%8f">#</a>
</h4>
<p>可以使用外部 key 的数据作为权重，代替默认的直接对比键值的方式来进行排序。</p>
<p>假设现在有用户数据如下：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>user_name_{uid}</th>
<th>user_level_{uid}</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>admin</td>
<td>9999</td>
</tr>
<tr>
<td>2</td>
<td>jack</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>peter</td>
<td>25</td>
</tr>
<tr>
<td>4</td>
<td>mary</td>
<td>70</td>
</tr>
</tbody>
</table>
<p>以下代码将数据输入到 Redis 中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># admin</span>

redis 127.0.0.1:6379&gt; LPUSH uid <span style="color:#ae81ff">1</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>

redis 127.0.0.1:6379&gt; SET user_name_1 admin
OK

redis 127.0.0.1:6379&gt; SET user_level_1 <span style="color:#ae81ff">9999</span>
OK

<span style="color:#75715e"># jack</span>

redis 127.0.0.1:6379&gt; LPUSH uid <span style="color:#ae81ff">2</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">2</span>

redis 127.0.0.1:6379&gt; SET user_name_2 jack
OK

redis 127.0.0.1:6379&gt; SET user_level_2 <span style="color:#ae81ff">10</span>
OK

<span style="color:#75715e"># peter</span>

redis 127.0.0.1:6379&gt; LPUSH uid <span style="color:#ae81ff">3</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">3</span>

redis 127.0.0.1:6379&gt; SET user_name_3 peter
OK

redis 127.0.0.1:6379&gt; SET user_level_3 <span style="color:#ae81ff">25</span>
OK

<span style="color:#75715e"># mary</span>

redis 127.0.0.1:6379&gt; LPUSH uid <span style="color:#ae81ff">4</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">4</span>

redis 127.0.0.1:6379&gt; SET user_name_4 mary
OK

redis 127.0.0.1:6379&gt; SET user_level_4 <span style="color:#ae81ff">70</span>
OK
</code></pre></div><h5 id="by-选项">
  BY 选项
  <a class="anchor" href="#by-%e9%80%89%e9%a1%b9">#</a>
</h5>
<p>默认情况下，<code>SORT uid</code> 直接按 <code>uid</code> 中的值排序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; SORT uid
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>      <span style="color:#75715e"># admin</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;2&#34;</span>      <span style="color:#75715e"># jack</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;3&#34;</span>      <span style="color:#75715e"># peter</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;4&#34;</span>      <span style="color:#75715e"># mary</span>
</code></pre></div><p>通过使用 <code>BY</code> 选项，可以让 <code>uid</code> 按其他键的元素来排序。</p>
<p>比如说， 以下代码让 <code>uid</code> 键按照 <code>user_level_{uid}</code> 的大小来排序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; SORT uid BY user_level_*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;2&#34;</span>      <span style="color:#75715e"># jack , level = 10</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;3&#34;</span>      <span style="color:#75715e"># peter, level = 25</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;4&#34;</span>      <span style="color:#75715e"># mary, level = 70</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>      <span style="color:#75715e"># admin, level = 9999</span>
</code></pre></div><p><code>user_level_*</code> 是一个占位符， 它先取出 <code>uid</code> 中的值， 然后再用这个值来查找相应的键。
比如在对 <code>uid</code> 列表进行排序时， 程序就会先取出 <code>uid</code> 的值 1 、 2 、 3 、 4 ， 然后使用 <code>user_level_1</code>、<code>user_level_2</code> 、 
<code>user_level_3</code> 和 <code>user_level_4</code> 的值作为排序 <code>uid</code> 的权重。</p>
<h5 id="get-选项">
  GET 选项
  <a class="anchor" href="#get-%e9%80%89%e9%a1%b9">#</a>
</h5>
<p>使用 <code>GET</code> 选项， 可以根据排序的结果来取出相应的键值。</p>
<p>比如说， 以下代码先排序 <code>uid</code>， 再取出键 <code>user_name_{uid}</code>的值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; SORT uid GET user_name_*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;admin&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;jack&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;peter&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;mary&#34;</span>
</code></pre></div><h5 id="组合使用-by-和-get">
  组合使用 BY 和 GET
  <a class="anchor" href="#%e7%bb%84%e5%90%88%e4%bd%bf%e7%94%a8-by-%e5%92%8c-get">#</a>
</h5>
<p>通过组合使用 <code>BY</code> 和 <code>GET</code>， 可以让排序结果以更直观的方式显示出来。</p>
<p>比如说， 以下代码先按 <code>user_level_{uid}</code> 来排序 <code>uid</code> 列表， 再取出相应的 <code>user_name_{uid}</code> 的值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; SORT uid BY user_level_* GET user_name_*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;jack&#34;</span>       <span style="color:#75715e"># level = 10</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;peter&#34;</span>      <span style="color:#75715e"># level = 25</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;mary&#34;</span>       <span style="color:#75715e"># level = 70</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;admin&#34;</span>      <span style="color:#75715e"># level = 9999</span>
</code></pre></div><p>现在的排序结果要比只使用  <code>SORT uid BY user_level_* </code> 要直观得多。</p>
<h5 id="获取多个外部键">
  获取多个外部键
  <a class="anchor" href="#%e8%8e%b7%e5%8f%96%e5%a4%9a%e4%b8%aa%e5%a4%96%e9%83%a8%e9%94%ae">#</a>
</h5>
<p>可以同时使用多个 <code>GET</code> 选项， 获取多个外部键的值。</p>
<p>以下代码就按 <code>uid</code> 分别获取 <code>user_level_{uid}</code> 和 <code>user_name_{uid}</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; SORT uid GET user_level_* GET user_name_*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;9999&#34;</span>       <span style="color:#75715e"># level</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;admin&#34;</span>      <span style="color:#75715e"># name</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;10&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;jack&#34;</span>
5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;25&#34;</span>
6<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;peter&#34;</span>
7<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;70&#34;</span>
8<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;mary&#34;</span>
</code></pre></div><p><code>GET</code> 有一个额外的参数规则，那就是 <code>——</code> 可以用 <code>#</code> 获取被排序键的值。</p>
<p>以下代码就将 <code>uid</code> 的值、及其相应的 <code>user_level_*</code> 和 <code>user_name_*</code> 都返回为结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; SORT uid GET <span style="color:#75715e"># GET user_level_* GET user_name_*</span>
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>          <span style="color:#75715e"># uid</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;9999&#34;</span>       <span style="color:#75715e"># level</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;admin&#34;</span>      <span style="color:#75715e"># name</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;2&#34;</span>
5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;10&#34;</span>
6<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;jack&#34;</span>
7<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;3&#34;</span>
8<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;25&#34;</span>
9<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;peter&#34;</span>
10<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;4&#34;</span>
11<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;70&#34;</span>
12<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;mary&#34;</span>
</code></pre></div><h5 id="获取外部键但不进行排序">
  获取外部键，但不进行排序
  <a class="anchor" href="#%e8%8e%b7%e5%8f%96%e5%a4%96%e9%83%a8%e9%94%ae%e4%bd%86%e4%b8%8d%e8%bf%9b%e8%a1%8c%e6%8e%92%e5%ba%8f">#</a>
</h5>
<p>通过将一个不存在的键作为参数传给 <code>BY</code> 选项， 可以让 <code>SORT</code> 跳过排序操作， 直接返回结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;4&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;3&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;2&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>
</code></pre></div><p>这种用法在单独使用时，没什么实际用处。</p>
<p>不过，通过将这种用法和 <code>GET</code> 选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 <code>SQL</code> 数
据库的 <code>join</code> 关键字）。</p>
<p>以下代码演示了，如何在不引起排序的情况下，使用 <code>SORT</code> 、 <code>BY</code> 和 <code>GET</code> 获取多个外部键：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key GET <span style="color:#75715e"># GET user_level_* GET user_name_*</span>
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;4&#34;</span>      <span style="color:#75715e"># id</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;70&#34;</span>     <span style="color:#75715e"># level</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;mary&#34;</span>   <span style="color:#75715e"># name</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;3&#34;</span>
5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;25&#34;</span>
6<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;peter&#34;</span>
7<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;2&#34;</span>
8<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;10&#34;</span>
9<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;jack&#34;</span>
10<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>
11<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;9999&#34;</span>
12<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;admin&#34;</span>
</code></pre></div><h5 id="将哈希表作为-get-或-by-的参数">
  将哈希表作为 GET 或 BY 的参数
  <a class="anchor" href="#%e5%b0%86%e5%93%88%e5%b8%8c%e8%a1%a8%e4%bd%9c%e4%b8%ba-get-%e6%88%96-by-%e7%9a%84%e5%8f%82%e6%95%b0">#</a>
</h5>
<p>除了可以将字符串键之外， 哈希表也可以作为 <code>GET</code> 或 <code>BY</code> 选项的参数来使用。</p>
<p>比如说，对于前面给出的用户信息表：</p>
<table>
<thead>
<tr>
<th>uid</th>
<th>user_name_{uid}</th>
<th>user_level_{uid}</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>admin</td>
<td>9999</td>
</tr>
<tr>
<td>2</td>
<td>jack</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>peter</td>
<td>25</td>
</tr>
<tr>
<td>4</td>
<td>mary</td>
<td>70</td>
</tr>
</tbody>
</table>
<p>我们可以不将用户的名字和级别保存在 <code>user_name_{uid}</code> 和 <code>user_level_{uid}</code> 两个字符串键中， 而是用一个带有 <code>name</code> 域和 <code>level</code> 域
的哈希表 <code>user_info_{uid}</code> 来保存用户的名字和级别信息：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; HMSET user_info_1 name admin level <span style="color:#ae81ff">9999</span>
OK

redis 127.0.0.1:6379&gt; HMSET user_info_2 name jack level <span style="color:#ae81ff">10</span>
OK

redis 127.0.0.1:6379&gt; HMSET user_info_3 name peter level <span style="color:#ae81ff">25</span>
OK

redis 127.0.0.1:6379&gt; HMSET user_info_4 name mary level <span style="color:#ae81ff">70</span>
OK
</code></pre></div><p>之后， BY 和 GET 选项都可以用 <code>key-&gt;field</code> 的格式来获取哈希表中的域的值， 其中 <code>key</code> 表示哈希表键， 而 <code>field</code> 则表示哈希表的域：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;2&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;3&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;4&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>

redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level GET user_info_*-&gt;name
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;jack&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;peter&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;mary&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;admin&#34;</span>
</code></pre></div><h4 id="保存排序结果">
  保存排序结果
  <a class="anchor" href="#%e4%bf%9d%e5%ad%98%e6%8e%92%e5%ba%8f%e7%bb%93%e6%9e%9c">#</a>
</h4>
<p>我们可以把 <code>SORT</code> 命令返回的排序结果，保存到指定 <code>key</code> 上。如果 <code>key</code> 已存在，会覆盖。
没有使用 <code>STORE</code>，<code>SORT</code>命令返回列表形式的排序结果；使用 <code>STORE</code> 参数，<code>SORT</code> 命令返回排序结果的元素数量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis&gt; RPUSH numbers <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">9</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">5</span>

redis&gt; RPUSH numbers <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">8</span> <span style="color:#ae81ff">10</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">10</span>

redis&gt; LRANGE numbers <span style="color:#ae81ff">0</span> -1
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;3&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;5&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;7&#34;</span>
5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;9&#34;</span>
6<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;2&#34;</span>
7<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;4&#34;</span>
8<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;6&#34;</span>
9<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;8&#34;</span>
10<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;10&#34;</span>

redis&gt; SORT numbers STORE sorted-numbers
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">10</span>

<span style="color:#75715e"># 排序后的结果</span>
redis&gt; LRANGE sorted-numbers <span style="color:#ae81ff">0</span> -1
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;1&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;2&#34;</span>
3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;3&#34;</span>
4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;4&#34;</span>
5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;5&#34;</span>
6<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;6&#34;</span>
7<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;7&#34;</span>
8<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;8&#34;</span>
9<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;9&#34;</span>
10<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;10&#34;</span>
</code></pre></div><h3 id="del">
  DEL
  <a class="anchor" href="#del">#</a>
</h3>
<p>删除一个或多个 <code>key</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">DEL key <span style="color:#f92672">[</span>key ...<span style="color:#f92672">]</span>
</code></pre></div><p>返回被删除的 <code>key</code> 的数量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#  删除单个 key</span>

redis&gt; SET name huangz
OK

redis&gt; DEL name
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>


<span style="color:#75715e"># 删除一个不存在的 key</span>

redis&gt; EXISTS phone
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>

redis&gt; DEL phone <span style="color:#75715e"># 失败，没有 key 被删除</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>


<span style="color:#75715e"># 同时删除多个 key</span>

redis&gt; SET name <span style="color:#e6db74">&#34;redis&#34;</span>
OK

redis&gt; SET type <span style="color:#e6db74">&#34;key-value store&#34;</span>
OK

redis&gt; SET website <span style="color:#e6db74">&#34;redis.com&#34;</span>
OK

redis&gt; DEL name type website
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">3</span>
</code></pre></div><h2 id="重命名">
  重命名
  <a class="anchor" href="#%e9%87%8d%e5%91%bd%e5%90%8d">#</a>
</h2>
<h3 id="rename">
  RENAME
  <a class="anchor" href="#rename">#</a>
</h3>
<p>将 <code>key</code> 重命名为 <code>newkey</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">RENAME key newkey
</code></pre></div><p>如果 <code>key</code> 和 <code>newkey</code> 相同，或 <code>key</code> 不存在，返回一个错误。当 <code>newkey</code> 已存在，覆盖 <code>newkey</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># key 存在且 newkey 不存在</span>
redis&gt; SET message <span style="color:#e6db74">&#34;hello world&#34;</span>
OK
redis&gt; RENAME message greeting
OK

<span style="color:#75715e"># message 不复存在</span>
redis&gt; EXISTS message
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>
<span style="color:#75715e"># 已被重命名为 greeting</span>
redis&gt; EXISTS greeting
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>


<span style="color:#75715e"># 当 key 不存在时，返回错误</span>
redis&gt; RENAME fake_key never_exists
<span style="color:#f92672">(</span>error<span style="color:#f92672">)</span> ERR no such key


<span style="color:#75715e"># newkey 已存在时， RENAME 会覆盖旧 newkey</span>
redis&gt; SET pc <span style="color:#e6db74">&#34;lenovo&#34;</span>
OK
redis&gt; SET personal_computer <span style="color:#e6db74">&#34;dell&#34;</span>
OK
redis&gt; RENAME pc personal_computer
OK
redis&gt; GET pc
<span style="color:#f92672">(</span>nil<span style="color:#f92672">)</span>
<span style="color:#75715e"># 原来的值 dell 被覆盖了</span>
redis:1&gt; GET personal_computer
<span style="color:#e6db74">&#34;lenovo&#34;</span>
</code></pre></div><h3 id="renamenx">
  RENAMENX
  <a class="anchor" href="#renamenx">#</a>
</h3>
<p>与 <code>RENAME</code> 类似，不同的是 <code>RENAMENX</code> 只有在 <code>newkey</code> 不存在的时候，才会重命名。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">RENAMENX key newkey
</code></pre></div><p>如果 <code>newkey</code> 已经存在返回 <code>0</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># newkey 不存在时，重命名成功</span>
redis&gt; SET player <span style="color:#e6db74">&#34;MPlyaer&#34;</span>
OK
redis&gt; EXISTS best_player
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>
redis&gt; RENAMENX player best_player
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>

<span style="color:#75715e"># newkey存在时，失败</span>
redis&gt; SET animal <span style="color:#e6db74">&#34;bear&#34;</span>
OK
redis&gt; SET favorite_animal <span style="color:#e6db74">&#34;butterfly&#34;</span>
OK
redis&gt; RENAMENX animal favorite_animal
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>
redis&gt; get animal
<span style="color:#e6db74">&#34;bear&#34;</span>
redis&gt; get favorite_animal
<span style="color:#e6db74">&#34;butterfly&#34;</span>
</code></pre></div><h2 id="序列化和反序列化">
  序列化和反序列化
  <a class="anchor" href="#%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96">#</a>
</h2>
<h3 id="dump">
  DUMP
  <a class="anchor" href="#dump">#</a>
</h3>
<p>序列化指定的 <code>key</code> 的值，并返回被序列化的值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis&gt; SET greeting <span style="color:#e6db74">&#34;hello, dumping world!&#34;</span>
OK

redis&gt; DUMP greeting
<span style="color:#e6db74">&#34;\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde&#34;</span>

redis&gt; DUMP not-exists-key
<span style="color:#f92672">(</span>nil<span style="color:#f92672">)</span>
</code></pre></div><h3 id="restore">
  RESTORE
  <a class="anchor" href="#restore">#</a>
</h3>
<p>将序列化的值反序列化，并将反序列化的值存储到指定的 <code>key</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">RESTORE key ttl serialized-value
</code></pre></div><p><code>ttl</code> 表示以毫秒为单位设置 <code>key</code> 的生存时间；如果 <code>ttl</code> 值为 <code>0</code>，表示不设置生存时间。
Redis 在进行反序化前，首先会对序列化值进行 <code>RDB</code> 较验，如果版本不符或数据不完整，会拒绝反序列化并返回一个错误</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis&gt; SET greeting <span style="color:#e6db74">&#34;hello, dumping world!&#34;</span>
OK

redis&gt; DUMP greeting
<span style="color:#e6db74">&#34;\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde&#34;</span>

redis&gt; RESTORE greeting-again <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#34;\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde&#34;</span>
OK

redis&gt; GET greeting-again
<span style="color:#e6db74">&#34;hello, dumping world!&#34;</span>

<span style="color:#75715e"># 使用错误的值进行反序列化</span>
redis&gt; RESTORE fake-message <span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#34;hello moto moto blah blah&#34;</span>   ;
<span style="color:#f92672">(</span>error<span style="color:#f92672">)</span> ERR DUMP payload version or checksum are wrong
</code></pre></div><h2 id="生存时间">
  生存时间
  <a class="anchor" href="#%e7%94%9f%e5%ad%98%e6%97%b6%e9%97%b4">#</a>
</h2>
<h3 id="expire">
  EXPIRE
  <a class="anchor" href="#expire">#</a>
</h3>
<p>为指定的 <code>key</code> 设置生存时间。当生存时间为 <code>0</code> 时，<code>key</code> 会自动删除。
<code>key</code> 设置生存时间后，可以再次执行 <code>EXPIRE</code> 命令更新生存时间。
<strong>注意对 <code>key</code> 的值进行修改甚至使用 <code>RENAME</code> 对 <code>key</code> 进行重命名时，都不会修改 <code>key</code> 的生存时间</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">EXPIRE key seconds
</code></pre></div><p>如果 <code>key</code> 不存在或者不能设置生存时间时，返回 <code>0</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis&gt; SET cache_page <span style="color:#e6db74">&#34;www.google.com&#34;</span>
OK

<span style="color:#75715e"># 设置过期时间为 30 秒</span>
redis&gt; EXPIRE cache_page <span style="color:#ae81ff">30</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>

<span style="color:#75715e"># 查看剩余生存时间</span>
redis&gt; TTL cache_page
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">23</span>

<span style="color:#75715e"># 更新过期时间</span>
redis&gt; EXPIRE cache_page <span style="color:#ae81ff">30000</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>

redis&gt; TTL cache_page
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">29996</span>
</code></pre></div><h3 id="expireat">
  EXPIREAT
  <a class="anchor" href="#expireat">#</a>
</h3>
<p>与 <code>EXPIRE</code> 命令类似，不同的是 <code>EXPIREAT</code> 设置的生存时间是 <code>UNIX</code> 时间戳，以秒为单位。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">EXPIREAT key timestamp
</code></pre></div><p>如果 <code>key</code> 不存在返回 <code>0</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis&gt; SET mykey <span style="color:#e6db74">&#34;Hello&#34;</span>
OK
redis&gt; EXISTS mykey
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
redis&gt; EXPIREAT mykey <span style="color:#ae81ff">1293840000</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
redis&gt; EXISTS mykey
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h3 id="persist">
  PERSIST
  <a class="anchor" href="#persist">#</a>
</h3>
<p>移除 <code>key</code> 的生存时间，将 <code>key</code> 持久化(永不过期的 <code>key</code>)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 设置一个 key</span>
redis&gt; SET mykey <span style="color:#e6db74">&#34;Hello&#34;</span>
OK

<span style="color:#75715e"># 为 key 设置生存时间</span>
redis&gt; EXPIRE mykey <span style="color:#ae81ff">10</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
redis&gt; TTL mykey
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">10</span>

<span style="color:#75715e"># 移除 key 的生存时间</span>
redis&gt; PERSIST mykey
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
redis&gt; TTL mykey
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> -1
</code></pre></div><h3 id="persistat">
  PERSISTAT
  <a class="anchor" href="#persistat">#</a>
</h3>
<p>与 <code>PERSIST</code> 命令类似，不同的是它以毫秒为单位设置 <code>key</code> 的过期 UNIX 时间戳。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">PEXPIREAT key milliseconds-timestamp
</code></pre></div><p>如果 <code>key</code> 不存在返回 <code>0</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis&gt; SET mykey <span style="color:#e6db74">&#34;Hello&#34;</span>
OK
redis&gt; PEXPIREAT mykey <span style="color:#ae81ff">1555555555005</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
redis&gt; TTL mykey
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">192569170</span>
redis&gt; PTTL mykey
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">192569169649</span>
</code></pre></div><h3 id="ttl">
  TTL
  <a class="anchor" href="#ttl">#</a>
</h3>
<p>获取指定 <code>key</code> 的剩余生存时间。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">TTL key
</code></pre></div><p>如果 <code>key</code> 不存在时返回 <code>-2</code>，如果 <code>key</code> 但没有生存时间时，返回 <code>-1</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 不存在的 key</span>
redis&gt; FLUSHDB
OK
redis&gt; TTL key
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> -2

<span style="color:#75715e"># key 存在，但没有设置剩余生存时间</span>
redis&gt; SET key value
OK
redis&gt; TTL key
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> -1

<span style="color:#75715e"># 有剩余生存时间的 key</span>
redis&gt; EXPIRE key <span style="color:#ae81ff">10086</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
redis&gt; TTL key
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">10084</span>
</code></pre></div><h3 id="pttl">
  PTTL
  <a class="anchor" href="#pttl">#</a>
</h3>
<p>与 <code>TTL</code> 命令类似，不同的是剩余生存时间以毫秒为单位。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">PTTL key
</code></pre></div><p>如果 <code>key</code> 不存在返回 <code>0</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 不存在的 key</span>
redis&gt; FLUSHDB
OK
redis&gt; PTTL key
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> -2


<span style="color:#75715e"># key 存在，但没有设置剩余生存时间</span>
redis&gt; SET key value
OK
redis&gt; PTTL key
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> -1


<span style="color:#75715e"># 有剩余生存时间的 key</span>
redis&gt; PEXPIRE key <span style="color:#ae81ff">10086</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
redis&gt; PTTL key
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">6179</span>
</code></pre></div><h2 id="迁移">
  迁移
  <a class="anchor" href="#%e8%bf%81%e7%a7%bb">#</a>
</h2>
<h3 id="migrate">
  MIGRATE
  <a class="anchor" href="#migrate">#</a>
</h3>
<p>将指定 <code>key</code> 从当前实例迁移到到目标实例，并从当前实例删除。<strong>原子操作</strong>，由于 Redis 是单线程，所以该指令会造成阻塞，直到迁移完成，
失败或者超时。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">MIGRATE host port key destination-db timeout <span style="color:#f92672">[</span>COPY<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>REPLACE<span style="color:#f92672">]</span>
</code></pre></div><ul>
<li><code>timeout</code>，超时时间，以毫秒为单位。 Redis 会在指定时间内完成 IO 操作，如果传送时间内发送 IO 错误或达到了超时时间，命令就会停止，并
返回一个 <code>IOERR</code> 错误。
可选参数：</li>
<li><code>COPY</code>：不移除源实例上的 <code>key</code>。</li>
<li><code>REPLACE</code>：替换目标实例上已存在的 <code>key</code>。
迁移流程：</li>
</ul>
<ol>
<li>源实例执行 <code>DUMP</code> 命令进行序列化，并将序列化数据传送到目标实例。</li>
<li>目标实例使用 <code>RESTORE</code> 命令进行反序列化，并存储数据。</li>
<li>当前实例和目标实例一样，收到 <code>RESTORE</code> 命令返回的 <code>ok</code>，当前实例就执行 <code>DEL</code> 命令删除 <code>key</code>。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#启动实例，使用默认的 6379 端口</span>
$ ./redis-server &amp;
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#ae81ff">3557</span>

<span style="color:#75715e">#启动实例，使用 7777 端口</span>
$ ./redis-server --port <span style="color:#ae81ff">7777</span> &amp;
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span> <span style="color:#ae81ff">3560</span>

<span style="color:#75715e">#连接 6379 端口的实例</span>
$ ./redis-cli

redis&gt; flushdb
OK

redis&gt; SET greeting <span style="color:#e6db74">&#34;Hello from 6379 instance&#34;</span>
OK

redis&gt; MIGRATE 127.0.0.1 <span style="color:#ae81ff">7777</span> greeting <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1000</span>
OK

<span style="color:#75715e"># 迁移成功后 key 会被删除</span>
redis&gt; EXISTS greeting
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>

<span style="color:#75715e">#查看 7777 端口的实例</span>
$ ./redis-cli -p <span style="color:#ae81ff">7777</span>

redis 127.0.0.1:7777&gt; GET greeting
<span style="color:#e6db74">&#34;Hello from 6379 instance&#34;</span>
</code></pre></div><h3 id="move">
  MOVE
  <a class="anchor" href="#move">#</a>
</h3>
<p>移动当前数据库中指定的 <code>key</code> 到指定数据库 <code>db</code> 中，<code>MOVE</code> 指令是在同一个实例中的迁移。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">MOVE key db
</code></pre></div><p>如果源数据库中 <code>key</code> 不存在，或者目标数据库中存在相同的 <code>key</code>，<code>MOVE</code> 命令无效。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># key 存在于当前数据库</span>

redis&gt; SELECT <span style="color:#ae81ff">0</span>                             <span style="color:#75715e"># redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。</span>
OK

redis&gt; SET song <span style="color:#e6db74">&#34;secret base - Zone&#34;</span>
OK

redis&gt; MOVE song <span style="color:#ae81ff">1</span>                          <span style="color:#75715e"># 将 song 移动到数据库 1</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>

redis&gt; EXISTS song                          <span style="color:#75715e"># song 已经被移走</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>

redis&gt; SELECT <span style="color:#ae81ff">1</span>                             <span style="color:#75715e"># 使用数据库 1</span>
OK

redis:1&gt; EXISTS song                        <span style="color:#75715e"># 证实 song 被移到了数据库 1 (注意命令提示符变成了&#34;redis:1&#34;，表明正在使用数据库 1)</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>


<span style="color:#75715e"># 当 key 不存在的时候</span>

redis:1&gt; EXISTS fake_key
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>

redis:1&gt; MOVE fake_key <span style="color:#ae81ff">0</span>                    <span style="color:#75715e"># 试图从数据库 1 移动一个不存在的 key 到数据库 0，失败</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>

redis:1&gt; <span style="color:#66d9ef">select</span> <span style="color:#ae81ff">0</span>                           <span style="color:#75715e"># 使用数据库0</span>
OK

redis&gt; EXISTS fake_key                      <span style="color:#75715e"># 证实 fake_key 不存在</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>


<span style="color:#75715e"># 当源数据库和目标数据库有相同的 key 时</span>

redis&gt; SELECT <span style="color:#ae81ff">0</span>                             <span style="color:#75715e"># 使用数据库0</span>
OK
redis&gt; SET favorite_fruit <span style="color:#e6db74">&#34;banana&#34;</span>
OK

redis&gt; SELECT <span style="color:#ae81ff">1</span>                             <span style="color:#75715e"># 使用数据库1</span>
OK
redis:1&gt; SET favorite_fruit <span style="color:#e6db74">&#34;apple&#34;</span>
OK

redis:1&gt; SELECT <span style="color:#ae81ff">0</span>                           <span style="color:#75715e"># 使用数据库0，并试图将 favorite_fruit 移动到数据库 1</span>
OK

redis&gt; MOVE favorite_fruit <span style="color:#ae81ff">1</span>                <span style="color:#75715e"># 因为两个数据库有相同的 key，MOVE 失败</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>

redis&gt; GET favorite_fruit                   <span style="color:#75715e"># 数据库 0 的 favorite_fruit 没变</span>
<span style="color:#e6db74">&#34;banana&#34;</span>
redis&gt; SELECT <span style="color:#ae81ff">1</span>
OK
redis:1&gt; GET favorite_fruit                 <span style="color:#75715e"># 数据库 1 的 favorite_fruit 也是</span>
<span style="color:#e6db74">&#34;apple&#34;</span>
</code></pre></div><h2 id="scan">
  SCAN
  <a class="anchor" href="#scan">#</a>
</h2>
<p>迭代当前数据库中的数据库键。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">SCAN cursor <span style="color:#f92672">[</span>MATCH pattern<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>COUNT count<span style="color:#f92672">]</span>
</code></pre></div><p>选项:</p>
<ul>
<li><code>cursor</code>，整数值，游标参数。</li>
<li><code>MATCH</code>，指定正则匹配模式，对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的，
所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。</li>
<li><code>COUNT</code>，指定每次迭代中从数据集里返回的元素数量，默认值为 <code>10</code>。<code>COUNT</code> 只是一个 <code>hint</code>，返回的结果可多可少。</li>
</ul>
<p>相关命令：</p>
<ul>
<li><code>HSCAN</code>，迭代哈希类型中的键值对。</li>
<li><code>SSCAN</code>，迭代集合中的元素。</li>
<li><code>ZSCAN</code>，迭代有序集合中的元素（包括元素成员和元素分值）。</li>
<li><code>SSCAN</code>，<code>HSCAN</code>和<code>ZSCAN</code>与<code>SCAN</code>都返回一个包含两个元素的 <code>multi-bulk</code> 回复，第一个元素是游标，第二个元素也是一个 <code>multi-bulk</code> 
回复，包含了本次被迭代的元素。</li>
<li><code>SSCAN</code>，<code>HSCAN</code> 和 <code>ZSCAN</code> 与 <code>SCAN</code> 类似，不同的是这三个命令的的第一个参数是一个数据库键。
<code>SCAN</code> 它迭代的是当前数据库中的所有数据库键，所以不需要提供数据库键。</li>
<li><code>SSCAN</code>，<code>HSCAN</code> 和 <code>ZSCAN</code> 与 <code>SCAN</code> 的返回值也不相同：
<ul>
<li><code>SCAN</code> 返回的每个元素都是一个数据库键。</li>
<li><code>SSCAN</code> 返回的每个元素都是一个集合成员。</li>
<li><code>HSCAN</code> 返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</li>
<li><code>ZSCAN</code> 返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</li>
</ul>
</li>
</ul>
<p><code>SCAN</code> 是一个基于游标的迭代器：<code>SCAN</code> 每次被调用之后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为 <code>SCAN</code> 的游
标参数，以此来延续之前的迭代过程。</p>
<p><strong>当 <code>SCAN</code> 命令的游标参数被设置为 <code>0</code> 时，服务器将开始一次新的迭代，而当服务器向用户返回值为 <code>0</code> 的游标时，表示迭代已结束</strong>。
当一个数据集不断地变大时，想要访问这个数据集中的所有元素就需要做越来越多的工作，能否结束一个迭代取决于用户执行迭代的速度是否比数据集
增长的速度更快。</p>
<p>对于 <code>SCAN</code> 这类增量式迭代命令来说，因为在对键进行增量式迭代的过程中，键可能会被修改，所以增量式迭代命令只能对被返回的元素提供有限的
保证（offer limited guarantees about the returned elements）。</p>
<p><strong>注意返回的结果可能会有重复，需要客户端去重复。</strong></p>
<h3 id="scan-对比-keys">
  SCAN 对比 KEYS
  <a class="anchor" href="#scan-%e5%af%b9%e6%af%94-keys">#</a>
</h3>
<ul>
<li>复杂度虽然也是 <code>O(n)</code>，但是它是通过游标分步进行的，不会阻塞线程;</li>
<li>提供 <code>limit</code> 参数，可以控制每次返回结果的最大条数，<code>limit</code> 只是一个 hint，返回的结果可多可少;</li>
<li>同 <code>keys</code> 一样，它也提供模式匹配功能;</li>
<li>服务器不需要为游标保存状态，游标的唯一状态就是 <code>scan</code> 返回给客户端的游标整数;</li>
<li>返回的<strong>结果可能会有重复，需要客户端去重复</strong>;</li>
<li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li>
<li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">redis 127.0.0.1:6379&gt; scan <span style="color:#ae81ff">0</span>
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;17&#34;</span>
2<span style="color:#f92672">)</span>  1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:12&#34;</span>
    2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:8&#34;</span>
    3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:4&#34;</span>
    4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:14&#34;</span>
    5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:16&#34;</span>
    6<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:17&#34;</span>
    7<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:15&#34;</span>
    8<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:10&#34;</span>
    9<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:3&#34;</span>
    10<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:7&#34;</span>
    11<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:1&#34;</span>

redis 127.0.0.1:6379&gt; scan <span style="color:#ae81ff">17</span>
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;0&#34;</span>
2<span style="color:#f92672">)</span> 1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:5&#34;</span>
   2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:18&#34;</span>
   3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:0&#34;</span>
   4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:2&#34;</span>
   5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:19&#34;</span>
   6<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:13&#34;</span>
   7<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:6&#34;</span>
   8<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:9&#34;</span>
   9<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:11&#34;</span>

<span style="color:#75715e"># 使用 MATCH</span>
redis 127.0.0.1:6379&gt; sadd myset <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> foo foobar feelsgood
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">6</span>

redis 127.0.0.1:6379&gt; sscan myset <span style="color:#ae81ff">0</span> match f*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;0&#34;</span>
2<span style="color:#f92672">)</span> 1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;foo&#34;</span>
   2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;feelsgood&#34;</span>
   3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;foobar&#34;</span>

<span style="color:#75715e"># 匹配不到元素</span>
redis 127.0.0.1:6379&gt; scan <span style="color:#ae81ff">0</span> MATCH *11*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;288&#34;</span>
2<span style="color:#f92672">)</span> 1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:911&#34;</span>

redis 127.0.0.1:6379&gt; scan <span style="color:#ae81ff">288</span> MATCH *11*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;224&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>empty list or set<span style="color:#f92672">)</span>

redis 127.0.0.1:6379&gt; scan <span style="color:#ae81ff">224</span> MATCH *11*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;80&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>empty list or set<span style="color:#f92672">)</span>

redis 127.0.0.1:6379&gt; scan <span style="color:#ae81ff">80</span> MATCH *11*
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;176&#34;</span>
2<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>empty list or set<span style="color:#f92672">)</span>

<span style="color:#75715e"># cursor 值为 0 遍历结束</span>
redis 127.0.0.1:6379&gt; scan <span style="color:#ae81ff">176</span> MATCH *11* COUNT <span style="color:#ae81ff">1000</span>
1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;0&#34;</span>
2<span style="color:#f92672">)</span>  1<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:611&#34;</span>
    2<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:711&#34;</span>
    3<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:118&#34;</span>
    4<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:117&#34;</span>
    5<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:311&#34;</span>
    6<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:112&#34;</span>
    7<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:111&#34;</span>
    8<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:110&#34;</span>
    9<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:113&#34;</span>
   10<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:211&#34;</span>
   11<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:411&#34;</span>
   12<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:115&#34;</span>
   13<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:116&#34;</span>
   14<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:114&#34;</span>
   15<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:119&#34;</span>
   16<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:811&#34;</span>
   17<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:511&#34;</span>
   18<span style="color:#f92672">)</span> <span style="color:#e6db74">&#34;key:11&#34;</span>
</code></pre></div><p>上面的示例中提供的 limit 是 1000，但是返回的结果只有 18 个。因为这个 <strong>limit 不是限定返回结果的数量，而是限定服务器单次遍历的字典
槽位数量</strong>(约等于)。如果将 limit 设置为 10，发现返回结果是空的，但是游标值不为零，意味着遍历还没结束。</p>
<h3 id="字典结构">
  字典结构
  <a class="anchor" href="#%e5%ad%97%e5%85%b8%e7%bb%93%e6%9e%84">#</a>
</h3>
<p>Redis 中所有的 key 都存储在一个很大的字典中，这个字典的结构是一维数组 + 二维链表结构，第一维数组的大小总是 2^n(n&gt;=0)，扩容一次数组
大小空间加倍，也就是 n++。</p>
<p>scan 指令返回的游标就是<strong>一维数组的位置索引</strong>，将这个位置索引称为<strong>槽</strong> (slot)。如果不考虑字典的扩容缩容，直接按数组下标挨个遍历就
行了。<strong>limit 参数就表示需要遍历的槽位数</strong>，之所以返回的结果可能多可能少，是因为不是所有的槽位上都会挂接链表，有些槽位可能是空的，还
有些槽位上挂接的链表上的元素可能会有多个。每一次遍历都会将 limit 数量的槽位上挂接的所有链表元素进行模式匹配过滤后，一次性返回给客户端。</p>
<h3 id="scan-遍历顺序">
  scan 遍历顺序
  <a class="anchor" href="#scan-%e9%81%8d%e5%8e%86%e9%a1%ba%e5%ba%8f">#</a>
</h3>
<p>scan 的遍历顺序不是从第一维数组的第 0 位一直遍历到末尾，而是采用了<strong>高位进位加法</strong>来遍历。之所以使用这样特殊的方式进行遍历，是考虑
到字典的扩容和缩容时避免槽位的遍历重复和遗漏。</p>
<h3 id="大-key-扫描">
  大 key 扫描
  <a class="anchor" href="#%e5%a4%a7-key-%e6%89%ab%e6%8f%8f">#</a>
</h3>
<p>如果在 Redis 实例中形成很大的对象，比如一个很大的 hash，一个很大的 zset。这样的对象对 Redis 的集群数据迁移带来了很大的问题，因为在
集群环境下，如果某个 key 太大，会数据导致迁移卡顿。另外在内存分配上，如果一个 key 太大，那么当它需要扩容时，会一次性申请更大的一
块内存，这也会导致卡顿。如果这个大 key 被删除，内存会一次性回收，卡顿现象会再一次产生。</p>
<p><strong>尽量避免大 key 的产生</strong>。</p>
<p><strong>如果观察到 Redis 的内存大起大落，这极有可能是因为大 key 导致的</strong>。</p>
<h4 id="那如何定位大-key-">
  那如何定位大 key ？
  <a class="anchor" href="#%e9%82%a3%e5%a6%82%e4%bd%95%e5%ae%9a%e4%bd%8d%e5%a4%a7-key-">#</a>
</h4>
<p>用 scan 指令，对于扫描出来的每一个 key，使用 type 指令获得 key 的类型，然后使用相应数据结构的 size 或者 len 方法来得到它的大小，对
于每一种类型，保留大小的前 N 名作为扫描结果展示出来。</p>
<p>上面这样的过程需要编写脚本，比较繁琐，不过 Redis 官方已经在 redis-cli 指令中提供了这样的扫描功能。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">redis-cli -h 127.0.0.1 -p <span style="color:#ae81ff">7001</span> –-bigkeys
</code></pre></div><p>如果你担心这个指令会大幅抬升 Redis 的 ops 导致线上报警，还可以增加一个休眠参数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">redis-cli -h 127.0.0.1 -p <span style="color:#ae81ff">7001</span> –-bigkeys -i 0.1
</code></pre></div><p>上面这个指令每隔 100 条 scan 指令就会休眠 0.1s，ops 就不会剧烈抬升，但是扫描的时间会变长。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/db-learn/commit/391abafbb55e9e09f274b9823c6b411133314e4f" title='Last modified by shipengqi | June 17, 2020' target="_blank" rel="noopener">
      <img src="/db-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 17, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/db-learn/edit/master/content//docs/redis/08_redis-key.md" target="_blank" rel="noopener">
      <img src="/db-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#查找删除">查找删除</a>
      <ul>
        <li><a href="#keys">KEYS</a></li>
        <li><a href="#exists">EXISTS</a></li>
        <li><a href="#randomkey">RANDOMKEY</a></li>
        <li><a href="#type">TYPE</a></li>
        <li><a href="#sort">SORT</a></li>
        <li><a href="#del">DEL</a></li>
      </ul>
    </li>
    <li><a href="#重命名">重命名</a>
      <ul>
        <li><a href="#rename">RENAME</a></li>
        <li><a href="#renamenx">RENAMENX</a></li>
      </ul>
    </li>
    <li><a href="#序列化和反序列化">序列化和反序列化</a>
      <ul>
        <li><a href="#dump">DUMP</a></li>
        <li><a href="#restore">RESTORE</a></li>
      </ul>
    </li>
    <li><a href="#生存时间">生存时间</a>
      <ul>
        <li><a href="#expire">EXPIRE</a></li>
        <li><a href="#expireat">EXPIREAT</a></li>
        <li><a href="#persist">PERSIST</a></li>
        <li><a href="#persistat">PERSISTAT</a></li>
        <li><a href="#ttl">TTL</a></li>
        <li><a href="#pttl">PTTL</a></li>
      </ul>
    </li>
    <li><a href="#迁移">迁移</a>
      <ul>
        <li><a href="#migrate">MIGRATE</a></li>
        <li><a href="#move">MOVE</a></li>
      </ul>
    </li>
    <li><a href="#scan">SCAN</a>
      <ul>
        <li><a href="#scan-对比-keys">SCAN 对比 KEYS</a></li>
        <li><a href="#字典结构">字典结构</a></li>
        <li><a href="#scan-遍历顺序">scan 遍历顺序</a></li>
        <li><a href="#大-key-扫描">大 key 扫描</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












