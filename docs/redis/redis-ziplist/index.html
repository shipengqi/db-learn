<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="小对象压缩#如果 Redis 内部管理的集合数据结构很小，它就会使用紧凑存储形式压缩存储。
比如 HashMap 结构，如果内部元素比较少，使用散列表反而浪费空间，不如直接使用数组进行存储，需要查找时，因为元素少进行遍历也很快，甚至 可以比 HashMap 本身的查找还要快。
ziplist#Redis 的 ziplist 是一个紧凑的 byte 数组结构，如下图，每个元素之间都是紧挨着的。
如果 ziplist 存储的是 hash 结构，那么 key 和 value 会作为两个 entry 相邻存在一起。
127.0.0.1:6379&gt; hset hello a 1 (integer) 1 127.0.0.1:6379&gt; hset hello b 2 (integer) 1 127.0.0.1:6379&gt; hset hello c 3 (integer) 1 127.0.0.1:6379&gt; object encoding hello &#34;ziplist&#34; 如果 ziplist 存储的是 zset，那么 value 和 score 会作为两个 entry 相邻存在一起。
127.0.0.1:6379&gt; zadd world 1 a (integer) 1 127.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="小对象压缩" />
<meta property="og:description" content="小对象压缩#如果 Redis 内部管理的集合数据结构很小，它就会使用紧凑存储形式压缩存储。
比如 HashMap 结构，如果内部元素比较少，使用散列表反而浪费空间，不如直接使用数组进行存储，需要查找时，因为元素少进行遍历也很快，甚至 可以比 HashMap 本身的查找还要快。
ziplist#Redis 的 ziplist 是一个紧凑的 byte 数组结构，如下图，每个元素之间都是紧挨着的。
如果 ziplist 存储的是 hash 结构，那么 key 和 value 会作为两个 entry 相邻存在一起。
127.0.0.1:6379&gt; hset hello a 1 (integer) 1 127.0.0.1:6379&gt; hset hello b 2 (integer) 1 127.0.0.1:6379&gt; hset hello c 3 (integer) 1 127.0.0.1:6379&gt; object encoding hello &#34;ziplist&#34; 如果 ziplist 存储的是 zset，那么 value 和 score 会作为两个 entry 相邻存在一起。
127.0.0.1:6379&gt; zadd world 1 a (integer) 1 127." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/db-learn/docs/redis/redis-ziplist/" />
<meta property="article:modified_time" content="2020-06-17T17:45:14+08:00" />
<title>小对象压缩 | Database Learning</title>
<link rel="manifest" href="/db-learn/manifest.json">
<link rel="icon" href="/db-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/db-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/db-learn/en.search.min.79aa4caec43110b70bc10866de8e262ae56a148e0d75708b1522265755d59b70.js" integrity="sha256-eapMrsQxELcLwQhm3o4mKuVqFI4NdXCLFSImV1XVm3A="></script>

<script defer src="/db-learn/sw.min.b93542a5760842e2e25439dfb3c014a53a75c12fc8ef2e8e01a71b378f98e127.js" integrity="sha256-uTVCpXYIQuLiVDnfs8AUpTp1wS/I7y6OAacbN4&#43;Y4Sc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/db-learn"><span>Database Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/db-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li>
<p><strong>Mysql</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mysql/01_getting_started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mysql/02_install/">安裝</a></li>
<li>
  <a href="/db-learn/docs/mysql/03_query/">简单查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/04_advanced_query/">复杂查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/05_write_operation/">写操作</a></li>
<li>
  <a href="/db-learn/docs/mysql/06_other/">其他</a></li>
<li>
  <a href="/db-learn/docs/mysql/07_architecture/">基础架构</a></li>
<li>
  <a href="/db-learn/docs/mysql/08_config/">启动选项和配置文件</a></li>
<li>
  <a href="/db-learn/docs/mysql/09_character/">字符集和比较规则</a></li>
<li>
  <a href="/db-learn/docs/mysql/10_innodb-record-store-structure/">InnoDB 记录存储结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/11_innodb-page-structure/">InnoDB 数据页结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/12_b-tree/">B+ 树索引</a></li>
<li>
  <a href="/db-learn/docs/mysql/13_isolation-level/">事务的隔离级别</a></li>
<li>
  <a href="/db-learn/docs/mysql/14_lock/">锁</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>Redis</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/redis/01_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/redis/02_redis-config/">安装配置</a></li>
<li>
  <a href="/db-learn/docs/redis/03_redis-string/">数据类型 String</a></li>
<li>
  <a href="/db-learn/docs/redis/04_redis-hash/">数据类型 Hash</a></li>
<li>
  <a href="/db-learn/docs/redis/05_redis-set/">数据类型 Set</a></li>
<li>
  <a href="/db-learn/docs/redis/06_redis-sortedset/">数据类型 SortedSet</a></li>
<li>
  <a href="/db-learn/docs/redis/07_redis-list/">数据类型 List</a></li>
<li>
  <a href="/db-learn/docs/redis/08_redis-key/">Key 操作</a></li>
<li>
  <a href="/db-learn/docs/redis/09_sds/">简单动态字符串</a></li>
<li>
  <a href="/db-learn/docs/redis/10_dict/">字典</a></li>
<li>
  <a href="/db-learn/docs/redis/11_redis-object/">对象</a></li>
<li>
  <a href="/db-learn/docs/redis/12_bitmap/">位图</a></li>
<li>
  <a href="/db-learn/docs/redis/13_distributed-lock/">分布式锁</a></li>
<li>
  <a href="/db-learn/docs/redis/14_queue/">延时队列</a></li>
<li>
  <a href="/db-learn/docs/redis/15_hyperloglog/">HyperLogLog</a></li>
<li>
  <a href="/db-learn/docs/redis/16_bloom-filter/">布隆过滤器</a></li>
<li>
  <a href="/db-learn/docs/redis/17_current-limit/">限流</a></li>
<li>
  <a href="/db-learn/docs/redis/18_geohash/">GeoHash</a></li>
<li>
  <a href="/db-learn/docs/redis/19_persistence/">持久化</a></li>
<li>
  <a href="/db-learn/docs/redis/20_pipeline/">管道</a></li>
<li>
  <a href="/db-learn/docs/redis/21_transaction/">事务</a></li>
<li>
  <a href="/db-learn/docs/redis/22_sync/">主从同步</a></li>
<li>
  <a href="/db-learn/docs/redis/23_cluster/">集群</a></li>
<li>
  <a href="/db-learn/docs/redis/24_info/">INFO 指令</a></li>
<li>
  <a href="/db-learn/docs/redis/25_redis-expire-strategy/">过期策略和内存淘汰机制</a></li>
<li>
  <a href="/db-learn/docs/redis/26_protect-redis/">保护 Redis</a></li>
<li>
  <a href="/db-learn/docs/redis/27_skills/">一些命令行技巧</a></li>
<li>
  <a href="/db-learn/docs/redis/28_slowlog/">慢查询日志</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>MongoDB</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mongo/01_overview/">介绍</a></li>
<li>
  <a href="/db-learn/docs/mongo/02_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mongo/03_advance/">使用</a></li>
<li>
  <a href="/db-learn/docs/mongo/04_migrate/">数据迁移</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/db-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>小对象压缩</strong>

  <label for="toc-control">
    
    <img src="/db-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#ziplist">ziplist</a></li>
    <li><a href="#intset">intset</a></li>
    <li><a href="#ziplist-内部实现">ziplist 内部实现</a></li>
    <li><a href="#增加元素">增加元素</a>
      <ul>
        <li><a href="#连锁更新">连锁更新</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="小对象压缩">
  小对象压缩
  <a class="anchor" href="#%e5%b0%8f%e5%af%b9%e8%b1%a1%e5%8e%8b%e7%bc%a9">#</a>
</h1>
<p>如果 Redis 内部管理的集合数据结构很小，它就会使用紧凑存储形式压缩存储。</p>
<p>比如 HashMap 结构，如果内部元素比较少，使用散列表反而浪费空间，不如直接使用数组进行存储，需要查找时，因为元素少进行遍历也很快，甚至
可以比 HashMap 本身的查找还要快。</p>
<h2 id="ziplist">
  ziplist
  <a class="anchor" href="#ziplist">#</a>
</h2>
<p>Redis 的 ziplist 是一个紧凑的 byte 数组结构，如下图，每个元素之间都是紧挨着的。</p>
<p>
  <img src="../../../images/redis-ziplist.jpg" alt="" /></p>
<p>如果 ziplist 存储的是 hash 结构，那么 key 和 value 会作为两个 entry 相邻存在一起。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; hset hello a <span style="color:#ae81ff">1</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
127.0.0.1:6379&gt; hset hello b <span style="color:#ae81ff">2</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
127.0.0.1:6379&gt; hset hello c <span style="color:#ae81ff">3</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
127.0.0.1:6379&gt; object encoding hello
<span style="color:#e6db74">&#34;ziplist&#34;</span>
</code></pre></div><p>如果 ziplist 存储的是 zset，那么 value 和 score 会作为两个 entry 相邻存在一起。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; zadd world <span style="color:#ae81ff">1</span> a
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
127.0.0.1:6379&gt; zadd world <span style="color:#ae81ff">2</span> b
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
127.0.0.1:6379&gt; zadd world <span style="color:#ae81ff">3</span> c
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
127.0.0.1:6379&gt; object encoding world
<span style="color:#e6db74">&#34;ziplist&#34;</span>
</code></pre></div><h2 id="intset">
  intset
  <a class="anchor" href="#intset">#</a>
</h2>
<p>当 set 集合容纳的<strong>元素都是整数并且元素个数较小</strong>时，Redis 会使用 intset 来存储结合元素。intset 是紧凑的数组结构，同时
支持 16 位、32 位和 64 位整数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> intset<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    int32 encoding; <span style="color:#75715e">// 决定整数位宽是 16 位、32 位还是 64 位
</span><span style="color:#75715e"></span>    int32 length; <span style="color:#75715e">// 元素个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> contents; <span style="color:#75715e">// 整数数组，可以是 16 位、32 位和 64 位
</span><span style="color:#75715e"></span>}
</code></pre></div><p>
  <img src="../../../images/redis-intset.jpg" alt="" /></p>
<p>如果整数可以用 uint16 表示，那么 intset 的元素就是 16 位的数组，如果新加入的整数超过了 uint16 的表示范围，那么就使用 uint32 表示，
如果新加入的元素超过了 uint32 的表示范围，那么就使用 uint64 表示，Redis 支持 set 集合动态从 uint16 升级到 uint32，再升级
到 uint64。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; sadd hello <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">3</span>
127.0.0.1:6379&gt; object encoding hello
<span style="color:#e6db74">&#34;intset&#34;</span>
</code></pre></div><p><strong>如果 set 里存储的是字符串，那么 sadd 立即升级为 hashtable 结构</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">127.0.0.1:6379&gt; sadd hello yes no
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">2</span>
127.0.0.1:6379&gt; object encoding hello
<span style="color:#e6db74">&#34;hashtable&#34;</span>
</code></pre></div><p><strong>存储界限</strong> 当集合对象的元素不断增加，或者某个 value 值过大，这种小对象存储也会被升级为标准结构。Redis 规定在小对象存储结构的限制
条件如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">hash-max-ziplist-entries <span style="color:#ae81ff">512</span>  <span style="color:#75715e"># hash 的元素个数超过 512 就必须用标准结构存储</span>
hash-max-ziplist-value <span style="color:#ae81ff">64</span>  <span style="color:#75715e"># hash 的任意元素的 key/value 的长度超过 64 就必须用标准结构存储</span>
list-max-ziplist-entries <span style="color:#ae81ff">512</span>  <span style="color:#75715e"># list 的元素个数超过 512 就必须用标准结构存储</span>
list-max-ziplist-value <span style="color:#ae81ff">64</span>  <span style="color:#75715e"># list 的任意元素的长度超过 64 就必须用标准结构存储</span>
zset-max-ziplist-entries <span style="color:#ae81ff">128</span>  <span style="color:#75715e"># zset 的元素个数超过 128 就必须用标准结构存储</span>
zset-max-ziplist-value <span style="color:#ae81ff">64</span>  <span style="color:#75715e"># zset 的任意元素的长度超过 64 就必须用标准结构存储</span>
set-max-intset-entries <span style="color:#ae81ff">512</span>  <span style="color:#75715e"># set 的整数元素个数超过 512 就必须用标准结构存储</span>
</code></pre></div><h2 id="ziplist-内部实现">
  ziplist 内部实现
  <a class="anchor" href="#ziplist-%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0">#</a>
</h2>
<p>Redis 为了节约内存空间使用，zset 和 hash 容器对象在元素个数较少的时候，采用压缩列表 (ziplist) 进行存储。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> ziplist<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    int32 zlbytes; <span style="color:#75715e">// 整个压缩列表占用字节数
</span><span style="color:#75715e"></span>    int32 zltail_offset; <span style="color:#75715e">// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
</span><span style="color:#75715e"></span>    int16 zllength; <span style="color:#75715e">// 元素个数
</span><span style="color:#75715e"></span>    T[] entries; <span style="color:#75715e">// 元素内容列表，挨个挨个紧凑存储
</span><span style="color:#75715e"></span>    int8 zlend; <span style="color:#75715e">// 标志压缩列表的结束，值恒为 0xFF
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>ztail_offset</code> 这个字段是为了支持双向遍历，用来快速定位到最后一个元素，然后倒着遍历。</p>
<p>entry 块随着容纳的元素类型不同，也会有不一样的结构。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> entry {
    <span style="color:#66d9ef">int</span><span style="color:#f92672">&lt;</span>var<span style="color:#f92672">&gt;</span> prevlen; <span style="color:#75715e">// 前一个 entry 的字节长度
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">&lt;</span>var<span style="color:#f92672">&gt;</span> encoding; <span style="color:#75715e">// 元素类型编码
</span><span style="color:#75715e"></span>    optional byte[] content; <span style="color:#75715e">// 元素内容
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>prevlen 字段 <strong>记录了压缩列表中前一个 entry 节点的长度</strong> ，当压缩列表倒着遍历时，需要通过这个字段来快速定位到下一个元素的位置。
它是一个变长的整数，当字符串长度小于 254(0xFE) 时，使用一个字节表示；如果达到或超出 254(0xFE) 那就使用 5 个字节来表示。第一个字节
是 0xFE(254)，剩余四个字节表示字符串长度。你可能会觉得用 5 个字节来表示字符串长度，是不是太浪费了。我们可以算一下，当字符串长度比
较长的时候，其实 5 个字节也只占用了不到 <code>(5/(254+5))&lt;2%</code> 的空间。</li>
<li>encoding 字段存储了元素内容的编码类型信息，ziplist 通过这个字段来决定后面的 content 内容的形式。Redis 通过这个字段的前缀位来
识别具体存储的数据形式：
<ul>
<li><code>00xxxxxx</code> 最大长度位 63 的短字符串，后面的 6 个位存储字符串的位数，剩余的字节就是字符串的内容。</li>
<li><code>01xxxxxx xxxxxxxx</code> 中等长度的字符串，后面 14 个位来表示字符串的长度，剩余的字节就是字符串的内容。</li>
<li><code>10000000 aaaaaaaa bbbbbbbb cccccccc dddddddd</code> 特大字符串，需要使用额外 4 个字节来表示长度。第一个字节前缀是10，剩余 6 位
没有使用，统一置为零。后面跟着字符串内容。不过这样的大字符串是没有机会使用的，压缩列表通常只是用来存储小数据的。</li>
<li><code>11000000</code> 表示 int16，后跟两个字节表示整数。</li>
<li><code>11010000</code> 表示 int32，后跟四个字节表示整数。</li>
<li><code>11100000</code> 表示 int64，后跟八个字节表示整数。</li>
<li><code>11110000</code> 表示 int24，后跟三个字节表示整数。</li>
<li><code>11111110</code> 表示 int8，后跟一个字节表示整数。</li>
<li><code>11111111</code> 表示 ziplist 的结束，也就是 zlend 的值 0xFF。</li>
<li><code>1111xxxx</code> 表示极小整数，xxxx 的范围只能是 (0001~1101), 也就是 1~13，因为 0000、1110、1111 都被占用了。读取到的 value 需
要将 xxxx 减 1，也就是整数 0~12 就是最终的 value。</li>
</ul>
</li>
<li>content 字段在结构体中定义为 optional 类型，表示这个字段是可选的，对于很小的整数而言，它的内容已经内联到 encoding 字段的尾部了。</li>
</ul>
<h2 id="增加元素">
  增加元素
  <a class="anchor" href="#%e5%a2%9e%e5%8a%a0%e5%85%83%e7%b4%a0">#</a>
</h2>
<p>因为 ziplist 都是紧凑存储，没有冗余空间 (对比一下 Redis 的字符串结构)。意味着插入一个新的元素就需要调用 realloc 扩展内存。取决
于内存分配器算法和当前的 ziplist 内存大小，realloc 可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能在原有的地
址上进行扩展，这时就不需要进行旧内容的内存拷贝。</p>
<p>如果 ziplist 占据内存太大，重新分配内存和拷贝内存就会有很大的消耗。所以 ziplist 不适合存储大型字符串，存储的元素也不宜过多。</p>
<h3 id="连锁更新">
  连锁更新
  <a class="anchor" href="#%e8%bf%9e%e9%94%81%e6%9b%b4%e6%96%b0">#</a>
</h3>
<p>考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 250 字节到 253 字节之间的节点 e1 至 eN ：

  <img src="../../../images/ziplistupdate.png" alt="" /></p>
<p>e1 至 eN 的所有节点的长度都小于 254 字节，所以记录这些节点的长度只需要 1 字节长的 <code>prevlen</code> 属性，
换句话说， e1 至 eN 的所有节点的 <code>prevlen</code> 属性都是 1 字节长的。</p>
<p>如果将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点，那么 new 将成为 e1 的前置节点，因为 e1 的 <code>prevlen</code> 属
性仅长 1 字节，它没办法保存新节点 new 的长度，所以程序将对压缩列表执行空间重分配操作，并将 e1 节点的 <code>prevlen</code> 属性从原来的 1 字节
长扩展为 5 字节长。</p>
<p>e1 原本的长度介于 250 字节至 253 字节之间， 在为 <code>prevlen</code> 属性新增四个字节的空间之后，e1 的长度就变成了介于 254 字节至 257 字节
之间，由于 e1 的长度变长了，长度导致 e2 节点的 <code>prevlen</code> 属性也要从原来的 1 字节长扩展为 5 字节长，否则 1 字节长的 <code>prevlen</code> 属性
是没办法保存。</p>
<p>扩展 e1 引发了对 e2 的扩展，扩展 e2 也会引发对 e3 的扩展，直到 eN 为止。</p>
<p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为<strong>连锁更新</strong>。</p>
<p>连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：</p>
<ul>
<li>首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</li>
<li>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如，对三五个节点进行连锁更新是绝对不会影响
性能的；</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/db-learn/commit/391abafbb55e9e09f274b9823c6b411133314e4f" title='Last modified by shipengqi | June 17, 2020' target="_blank" rel="noopener">
      <img src="/db-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 17, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/db-learn/edit/master/content//docs/redis/redis-ziplist.md" target="_blank" rel="noopener">
      <img src="/db-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#ziplist">ziplist</a></li>
    <li><a href="#intset">intset</a></li>
    <li><a href="#ziplist-内部实现">ziplist 内部实现</a></li>
    <li><a href="#增加元素">增加元素</a>
      <ul>
        <li><a href="#连锁更新">连锁更新</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












