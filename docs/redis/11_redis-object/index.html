<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="对象#Redis 用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合，等等。
Redis 并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希 对象、集合对象和有序集合对象这五种类型的对象。
对象的类型与编码#Redis 使用对象来表示数据库中的键和值，每次在 Redis 的数据库中新创建一个键值对时，至少会创建两个对象，一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。
比如：
redis&gt; SET msg &#34;hello world&#34; OK 每个对象都由一个 redisObject 结构表示:
typedef struct redisObject { // 类型  unsigned type:4; // 编码  unsigned encoding:4; // 指向底层实现数据结构的指针  void *ptr; // ...  } robj; type#对象的 type 属性记录了对象的类型，这个属性的值可以是下面列表中的任意一个：
 REDIS_STRING，字符串对象 REDIS_LIST，列表对象 REDIS_HASH，哈希对象 REDIS_SET，集合对象 REDIS_ZSET，有序集合对象  对于 Redis 数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中 一种，因此：
 当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象” 当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”  编码和底层实现#对象的 ptr 指针指向对象的底层实现数据结构，而这些数据结构由对象的 encoding 属性决定。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="对象" />
<meta property="og:description" content="对象#Redis 用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合，等等。
Redis 并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希 对象、集合对象和有序集合对象这五种类型的对象。
对象的类型与编码#Redis 使用对象来表示数据库中的键和值，每次在 Redis 的数据库中新创建一个键值对时，至少会创建两个对象，一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。
比如：
redis&gt; SET msg &#34;hello world&#34; OK 每个对象都由一个 redisObject 结构表示:
typedef struct redisObject { // 类型  unsigned type:4; // 编码  unsigned encoding:4; // 指向底层实现数据结构的指针  void *ptr; // ...  } robj; type#对象的 type 属性记录了对象的类型，这个属性的值可以是下面列表中的任意一个：
 REDIS_STRING，字符串对象 REDIS_LIST，列表对象 REDIS_HASH，哈希对象 REDIS_SET，集合对象 REDIS_ZSET，有序集合对象  对于 Redis 数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中 一种，因此：
 当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象” 当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”  编码和底层实现#对象的 ptr 指针指向对象的底层实现数据结构，而这些数据结构由对象的 encoding 属性决定。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/db-learn/docs/redis/11_redis-object/" />
<meta property="article:modified_time" content="2020-06-17T17:45:14+08:00" />
<title>对象 | Database Learning</title>
<link rel="manifest" href="/db-learn/manifest.json">
<link rel="icon" href="/db-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/db-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/db-learn/en.search.min.79aa4caec43110b70bc10866de8e262ae56a148e0d75708b1522265755d59b70.js" integrity="sha256-eapMrsQxELcLwQhm3o4mKuVqFI4NdXCLFSImV1XVm3A="></script>

<script defer src="/db-learn/sw.min.b93542a5760842e2e25439dfb3c014a53a75c12fc8ef2e8e01a71b378f98e127.js" integrity="sha256-uTVCpXYIQuLiVDnfs8AUpTp1wS/I7y6OAacbN4&#43;Y4Sc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/db-learn"><span>Database Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/db-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li>
<p><strong>Mysql</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mysql/01_getting_started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mysql/02_install/">安裝</a></li>
<li>
  <a href="/db-learn/docs/mysql/03_query/">简单查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/04_advanced_query/">复杂查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/05_write_operation/">写操作</a></li>
<li>
  <a href="/db-learn/docs/mysql/06_other/">其他</a></li>
<li>
  <a href="/db-learn/docs/mysql/07_architecture/">基础架构</a></li>
<li>
  <a href="/db-learn/docs/mysql/08_config/">启动选项和配置文件</a></li>
<li>
  <a href="/db-learn/docs/mysql/09_character/">字符集和比较规则</a></li>
<li>
  <a href="/db-learn/docs/mysql/10_innodb-record-store-structure/">InnoDB 记录存储结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/11_innodb-page-structure/">InnoDB 数据页结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/12_b-tree/">B+ 树索引</a></li>
<li>
  <a href="/db-learn/docs/mysql/13_isolation-level/">事务的隔离级别</a></li>
<li>
  <a href="/db-learn/docs/mysql/14_lock/">锁</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>Redis</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/redis/01_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/redis/02_redis-config/">安装配置</a></li>
<li>
  <a href="/db-learn/docs/redis/03_redis-string/">数据类型 String</a></li>
<li>
  <a href="/db-learn/docs/redis/04_redis-hash/">数据类型 Hash</a></li>
<li>
  <a href="/db-learn/docs/redis/05_redis-set/">数据类型 Set</a></li>
<li>
  <a href="/db-learn/docs/redis/06_redis-sortedset/">数据类型 SortedSet</a></li>
<li>
  <a href="/db-learn/docs/redis/07_redis-list/">数据类型 List</a></li>
<li>
  <a href="/db-learn/docs/redis/08_redis-key/">Key 操作</a></li>
<li>
  <a href="/db-learn/docs/redis/09_sds/">简单动态字符串</a></li>
<li>
  <a href="/db-learn/docs/redis/10_dict/">字典</a></li>
<li>
  <a href="/db-learn/docs/redis/11_redis-object/"class=active>对象</a></li>
<li>
  <a href="/db-learn/docs/redis/12_bitmap/">位图</a></li>
<li>
  <a href="/db-learn/docs/redis/13_distributed-lock/">分布式锁</a></li>
<li>
  <a href="/db-learn/docs/redis/14_queue/">延时队列</a></li>
<li>
  <a href="/db-learn/docs/redis/15_hyperloglog/">HyperLogLog</a></li>
<li>
  <a href="/db-learn/docs/redis/16_bloom-filter/">布隆过滤器</a></li>
<li>
  <a href="/db-learn/docs/redis/17_current-limit/">限流</a></li>
<li>
  <a href="/db-learn/docs/redis/18_geohash/">GeoHash</a></li>
<li>
  <a href="/db-learn/docs/redis/19_persistence/">持久化</a></li>
<li>
  <a href="/db-learn/docs/redis/20_pipeline/">管道</a></li>
<li>
  <a href="/db-learn/docs/redis/21_transaction/">事务</a></li>
<li>
  <a href="/db-learn/docs/redis/22_sync/">主从同步</a></li>
<li>
  <a href="/db-learn/docs/redis/23_cluster/">集群</a></li>
<li>
  <a href="/db-learn/docs/redis/24_info/">INFO 指令</a></li>
<li>
  <a href="/db-learn/docs/redis/25_redis-expire-strategy/">过期策略和内存淘汰机制</a></li>
<li>
  <a href="/db-learn/docs/redis/26_protect-redis/">保护 Redis</a></li>
<li>
  <a href="/db-learn/docs/redis/27_skills/">一些命令行技巧</a></li>
<li>
  <a href="/db-learn/docs/redis/28_slowlog/">慢查询日志</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>MongoDB</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mongo/01_overview/">介绍</a></li>
<li>
  <a href="/db-learn/docs/mongo/02_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mongo/03_advance/">使用</a></li>
<li>
  <a href="/db-learn/docs/mongo/04_migrate/">数据迁移</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/db-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>对象</strong>

  <label for="toc-control">
    
    <img src="/db-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#对象的类型与编码">对象的类型与编码</a>
      <ul>
        <li><a href="#type">type</a></li>
        <li><a href="#编码和底层实现">编码和底层实现</a></li>
      </ul>
    </li>
    <li><a href="#字典遍历">字典遍历</a></li>
    <li><a href="#重复遍历">重复遍历</a></li>
    <li><a href="#迭代器">迭代器</a></li>
    <li><a href="#迭代器的选择">迭代器的选择</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="对象">
  对象
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1">#</a>
</h1>
<p>Redis 用到的所有主要<strong>数据结构</strong>，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合，等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个<strong>对象系统</strong>，这个系统包含字符串对象、列表对象、哈希
对象、集合对象和有序集合对象这五种类型的对象。</p>
<h2 id="对象的类型与编码">
  对象的类型与编码
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e7%b1%bb%e5%9e%8b%e4%b8%8e%e7%bc%96%e7%a0%81">#</a>
</h2>
<p>Redis 使用对象来表示数据库中的键和值，每次在 Redis 的数据库中新创建一个键值对时，至少会创建两个对象，一个对象用作键值对的键（键对象），
另一个对象用作键值对的值（值对象）。</p>
<p>比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">redis&gt; SET msg <span style="color:#e6db74">&#34;hello world&#34;</span>
OK
</code></pre></div><p>每个对象都由一个 <code>redisObject</code> 结构表示:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisObject {

    <span style="color:#75715e">// 类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> type:<span style="color:#ae81ff">4</span>;

    <span style="color:#75715e">// 编码
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> encoding:<span style="color:#ae81ff">4</span>;

    <span style="color:#75715e">// 指向底层实现数据结构的指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
} robj;
</code></pre></div><h3 id="type">
  type
  <a class="anchor" href="#type">#</a>
</h3>
<p>对象的 <code>type</code> 属性记录了对象的类型，这个属性的值可以是下面列表中的任意一个：</p>
<ul>
<li><code>REDIS_STRING</code>，字符串对象</li>
<li><code>REDIS_LIST</code>，列表对象</li>
<li><code>REDIS_HASH</code>，哈希对象</li>
<li><code>REDIS_SET</code>，集合对象</li>
<li><code>REDIS_ZSET</code>，有序集合对象</li>
</ul>
<p>对于 Redis 数据库保存的键值对来说，<strong>键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中
一种</strong>，因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”</li>
</ul>
<h3 id="编码和底层实现">
  编码和底层实现
  <a class="anchor" href="#%e7%bc%96%e7%a0%81%e5%92%8c%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<p><strong>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构，而这些数据结构由对象的 <code>encoding</code> 属性决定</strong>。</p>
<p><code>encoding</code> 属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>底层实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>REDIS_ENCODING_INT</code>（<code>int</code>）</td>
<td><code>long</code> 类型的整数</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_EMBSTR</code>（<code>embstr</code>）</td>
<td><code>embstr</code> 编码的简单动态字符串</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_RAW</code>（<code>raw</code>）</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_HT</code>（<code>hashtable</code>）</td>
<td>字典</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_LINKEDLIST</code>（<code>linkedlist</code>）</td>
<td>双端链表</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_ZIPLIST</code>（<code>ziplist</code>）</td>
<td>压缩列表</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_INTSET</code>（<code>intset</code>）</td>
<td>整数集合</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_SKIPLIST</code>（<code>skiplist</code>）</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
<p>每种类型的对象都至少使用了两种不同的编码:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_INT</code></td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_EMBSTR</code></td>
<td>使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_RAW</code></td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td><code>REDIS_ENCODING_HT</code></td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td><code>REDIS_ENCODING_INTSET</code></td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td><code>REDIS_ENCODING_HT</code></td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td><code>REDIS_ENCODING_SKIPLIST</code></td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<h2 id="字典遍历">
  字典遍历
  <a class="anchor" href="#%e5%ad%97%e5%85%b8%e9%81%8d%e5%8e%86">#</a>
</h2>
<p>Redis 对象树的主干是一个字典，如果对象很多，这个主干字典也会很大。当我们使用 keys 命令搜寻指定模式的 key 时，它会遍历整个主干字典。</p>
<h2 id="重复遍历">
  重复遍历
  <a class="anchor" href="#%e9%87%8d%e5%a4%8d%e9%81%8d%e5%8e%86">#</a>
</h2>
<p>字典在扩容的时候要进行渐进式迁移，会存在新旧两个 hashtable。遍历需要对这两个 hashtable 依次进行，先遍历完旧的 hashtable，再继续
遍历新的 hashtable。如果在遍历的过程中进行了 rehashStep，将已经遍历过的旧的 hashtable 的元素迁移到了新的 hashtable 中，那么会不
会出现元素的重复？</p>
<p>为了解决这个问题，Redis 为字典的遍历提供了 2 种迭代器，一种是安全迭代器，另一种是不安全迭代器。</p>
<h2 id="迭代器">
  迭代器
  <a class="anchor" href="#%e8%bf%ad%e4%bb%a3%e5%99%a8">#</a>
</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictIterator {
    dict <span style="color:#f92672">*</span>d; <span style="color:#75715e">// 目标字典对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> index; <span style="color:#75715e">// 当前遍历的槽位置，初始化为-1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> table; <span style="color:#75715e">// ht[0] or ht[1]
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> safe; <span style="color:#75715e">// 这个属性非常关键，它表示迭代器是否安全
</span><span style="color:#75715e"></span>    dictEntry <span style="color:#f92672">*</span>entry; <span style="color:#75715e">// 迭代器当前指向的对象
</span><span style="color:#75715e"></span>    dictEntry <span style="color:#f92672">*</span>nextEntry; <span style="color:#75715e">// 迭代器下一个指向的对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> fingerprint; <span style="color:#75715e">// 迭代器指纹，放置迭代过程中字典被修改
</span><span style="color:#75715e"></span>} dictIterator;

<span style="color:#75715e">// 获取非安全迭代器，只读迭代器，允许 rehashStep
</span><span style="color:#75715e"></span>dictIterator <span style="color:#f92672">*</span><span style="color:#a6e22e">dictGetIterator</span>(dict <span style="color:#f92672">*</span>d)
{
    dictIterator <span style="color:#f92672">*</span>iter <span style="color:#f92672">=</span> zmalloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>iter));

    iter<span style="color:#f92672">-&gt;</span>d <span style="color:#f92672">=</span> d;
    iter<span style="color:#f92672">-&gt;</span>table <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    iter<span style="color:#f92672">-&gt;</span>index <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    iter<span style="color:#f92672">-&gt;</span>safe <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    iter<span style="color:#f92672">-&gt;</span>entry <span style="color:#f92672">=</span> NULL;
    iter<span style="color:#f92672">-&gt;</span>nextEntry <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> iter;
}

<span style="color:#75715e">// 获取安全迭代器，允许触发过期处理，禁止 rehashStep
</span><span style="color:#75715e"></span>dictIterator <span style="color:#f92672">*</span><span style="color:#a6e22e">dictGetSafeIterator</span>(dict <span style="color:#f92672">*</span>d) {
    dictIterator <span style="color:#f92672">*</span>i <span style="color:#f92672">=</span> dictGetIterator(d);

    i<span style="color:#f92672">-&gt;</span>safe <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> i;
}
</code></pre></div><ul>
<li><strong>安全的迭代器</strong>，指的是在遍历过程中可以对字典进行查找和修改，会触发过期判断，删除内部元素。迭代过程中不会出现元素重复，为了保证不重
复，就会禁止 rehashStep。</li>
<li><strong>不安全的迭代器</strong>，是指遍历过程中字典是只读的，不可以修改，只能调用 dictNext 对字典进行持续遍历，不得调用任何可能触发过期判断的函数。
不过好处是不影响 rehash，代价就是遍历的元素可能会出现重复。</li>
</ul>
<p>安全迭代器在刚开始遍历时，会给字典打上一个标记，有了这个标记，rehashStep 就不会执行，遍历时元素就不会出现重复。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dict {
    dictType <span style="color:#f92672">*</span>type;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata;
    dictht ht[<span style="color:#ae81ff">2</span>];
    <span style="color:#66d9ef">long</span> rehashidx;
    <span style="color:#75715e">// 这个就是标记，它表示当前加在字典上的安全迭代器的数量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> iterators;
} dict;

<span style="color:#75715e">// 如果存在安全的迭代器，就禁止rehash
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_dictRehashStep</span>(dict <span style="color:#f92672">*</span>d) {
    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>iterators <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) dictRehash(d,<span style="color:#ae81ff">1</span>);
}
</code></pre></div><h2 id="迭代器的选择">
  迭代器的选择
  <a class="anchor" href="#%e8%bf%ad%e4%bb%a3%e5%99%a8%e7%9a%84%e9%80%89%e6%8b%a9">#</a>
</h2>
<p>除了 <code>keys</code> 指令使用了安全迭代器，因为结果不允许重复。那还有其它的地方使用了安全迭代器么，什么情况下遍历适合使用非安全迭代器？</p>
<p>如果遍历过程中不允许出现重复，那就使用 SafeIterator：</p>
<ul>
<li><code>bgaofrewrite</code> 需要遍历所有对象转换称操作指令进行持久化，绝对不允许出现重复</li>
<li><code>bgsave</code> 也需要遍历所有对象来持久化，同样不允许出现重复</li>
</ul>
<p>如果遍历过程中需要处理元素过期，需要对字典进行修改，那也必须使用 SafeIterator，因为非安全的迭代器是只读的。</p>
<p>其它情况下，也就是允许遍历过程中出现个别元素重复，不需要对字典进行结构性修改的情况下一律使用非安全迭代器。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/db-learn/commit/391abafbb55e9e09f274b9823c6b411133314e4f" title='Last modified by shipengqi | June 17, 2020' target="_blank" rel="noopener">
      <img src="/db-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 17, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/db-learn/edit/master/content//docs/redis/11_redis-object.md" target="_blank" rel="noopener">
      <img src="/db-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#对象的类型与编码">对象的类型与编码</a>
      <ul>
        <li><a href="#type">type</a></li>
        <li><a href="#编码和底层实现">编码和底层实现</a></li>
      </ul>
    </li>
    <li><a href="#字典遍历">字典遍历</a></li>
    <li><a href="#重复遍历">重复遍历</a></li>
    <li><a href="#迭代器">迭代器</a></li>
    <li><a href="#迭代器的选择">迭代器的选择</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












