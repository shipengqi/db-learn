<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Database Learning – 核心设计与原理</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/</link><description>Recent content in 核心设计与原理 on Database Learning</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><atom:link href="https://shipengqi.github.io/db-learn/docs/redis/advance/index.xml" rel="self" type="application/rss+xml"/><item><title>简单动态字符串</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/01_sds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/01_sds/</guid><description>
&lt;p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串），而是自己构建了一种名为&lt;strong>简单动态字符串&lt;/strong>（simple dynamic string，SDS）的抽象类型， 并将 &lt;strong>SDS&lt;/strong> 用作 Redis 的默认字符串表示。内部结构实现上类似于 Java 的 ArrayList。&lt;/p>
&lt;p>SDS 的结构是一个带长度信息的字节数组：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">SDS&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">free&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// buf 剩余可用长度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// buf 已占用长度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[];&lt;/span> &lt;span class="c1">// 实际保存字符串数据的地方
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">对 buf 分配一些额外的空间，并使用 free 记录未使用空间的大小。Redis 字符串是可以修改的，它支持 &lt;code>append&lt;/code> 操作。如果数组没有冗余空间，那么追加操作必然涉及到分配新数组，然后将旧内容复制过来，再 &lt;code>append&lt;/code> 新内容。如果字符串的长度非常长，这样的&lt;strong>内存分配和复制开销就会非常大&lt;/strong>。这是利用空间换时间的策略。&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>使用 SDS 的原因：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>二进制安全&lt;/strong>。C 字符串是以 &lt;code>\0&lt;/code> 字符为结尾的，如果客户端传过来的字符串包含 &lt;code>\0&lt;/code> 字符，那么服务器在处理这个字符串时，会将 &lt;code>\0&lt;/code> 后的字符串舍弃掉。适配不同语言的客户端。&lt;/li>
&lt;li>兼容部分 C 字符串函数。SDS 结构体中的 &lt;code>content&lt;/code> 中的字符串是以字节 &lt;code>\0&lt;/code> 结尾的字符串，之所以多出这样一个字节，是为了便于直接使用 &lt;code>glibc&lt;/code> 的字符串处理函数。&lt;/li>
&lt;/ul>
&lt;h2>扩容策略&lt;span class="hx-absolute -hx-mt-20" id="扩容策略">&lt;/span>
&lt;a href="#%e6%89%a9%e5%ae%b9%e7%ad%96%e7%95%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>字符串在长度&lt;strong>小于 1M 之前，扩容空间采用加倍策略&lt;/strong>，也就是保留 100% 的冗余空间。当长度&lt;strong>超过 1M 之后&lt;/strong>，为了避免加倍后的冗余空间过大而导致浪费，&lt;strong>每次扩容只会多分配 1M 大小&lt;/strong>的冗余空间。&lt;/p>
&lt;h2>Redis 的 key&lt;span class="hx-absolute -hx-mt-20" id="redis-的-key">&lt;/span>
&lt;a href="#redis-%e7%9a%84-key" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 是一个键值对数据库，key 是字符串，value 是字符串、列表、哈希、集合、有序集合。&lt;/p>
&lt;p>虽然 Redis 可以使用非字符串类型作为 key，例如：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">set&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; get &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;100&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">set&lt;/span> 0.1 &lt;span class="m">200&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; get 0.1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;200&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>虽然看起来是数字或者浮点数，但是 Redis 会将其作为字符串来处理。&lt;/p></description></item><item><title>字典</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/02_hash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/02_hash/</guid><description>
&lt;p>Redis 中除了 &lt;code>hash&lt;/code> 结构的数据会用到字典外，整个 Redis 数据库的所有 key 和 value 也组成了一个全局字典，还有带过期时间的 key 集合也是一个字典。&lt;code>zset&lt;/code> 集合中存储 value 和 score 值的映射关系也是通过字典实现的。&lt;/p>
&lt;p>&lt;strong>&lt;code>set&lt;/code> 的结构底层实现也是字典，只不过所有的 value 都是 NULL&lt;/strong>，其它的特性和字典一模一样。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">RedisDb&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dict&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">dict&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// all keys key=&amp;gt;value
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">dict&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">expires&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// all expired keys key=&amp;gt;long(timestamp)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">zset&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dict&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dict&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// all values value=&amp;gt;score
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">zskiplist&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">zsl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>字典的结构&lt;span class="hx-absolute -hx-mt-20" id="字典的结构">&lt;/span>
&lt;a href="#%e5%ad%97%e5%85%b8%e7%9a%84%e7%bb%93%e6%9e%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">dict&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dictht&lt;/span> &lt;span class="n">ht&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">dictEntry&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dictEntry&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 链接下一个 entry，用来解决 hash 冲突
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">dictht&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dictEntry&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">table&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 二维
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 第一维数组的长度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">used&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// hash 表中的元素个数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-reshash.png" alt="redis-reshash" loading="lazy" />&lt;/p>
&lt;p>&lt;code>dict&lt;/code> 结构内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的。但是在 &lt;code>dict&lt;/code> 扩缩容时，需要分配新的 hashtable，然后进行&lt;strong>渐进式&lt;/strong>搬迁，这时候两个 hashtable 存储的分别是旧的 hashtable 和新的 hashtable。待搬迁结束后，旧的 hashtable 被删除，新的 hashtable 取而代之。&lt;/p>
&lt;h2>渐进式 rehash&lt;span class="hx-absolute -hx-mt-20" id="渐进式-rehash">&lt;/span>
&lt;a href="#%e6%b8%90%e8%bf%9b%e5%bc%8f-rehash" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;strong>rehash 动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的&lt;/strong>。&lt;/p>
&lt;p>原因在于，Redis 是单线程的，如果哈希表里保存的键值对数量非常庞大，一次性 rehash 庞大的计算量会导致服务器一段时间内停止服务。&lt;/p>
&lt;p>渐进式 rehash 的详细步骤：&lt;/p>
&lt;ol>
&lt;li>为 &lt;code>ht[1]&lt;/code> 分配空间，让字典同时持有 &lt;code>ht[0]&lt;/code> 和 &lt;code>ht[1]&lt;/code> 两个数组。&lt;/li>
&lt;li>在字典中维持一个索引计数器变量 &lt;code>rehashidx&lt;/code> ，并将它的值设置为 0， 表示 rehash 工作正式开始。&lt;/li>
&lt;li>在 rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将 &lt;code>ht[0]&lt;/code> 在 &lt;code>rehashidx&lt;/code> 索引上的所有键值对 rehash 到 &lt;code>ht[1]&lt;/code> ，当 rehash 工作完成之后，程序将 &lt;code>rehashidx&lt;/code> 属性的值增 1。&lt;/li>
&lt;li>随着字典操作的不断执行，最终在某个时间点上，&lt;code>ht[0]&lt;/code> 的所有键值对都会被 rehash 至 &lt;code>ht[1]&lt;/code>，然后将 &lt;code>ht[0]&lt;/code> 指向新的数组，&lt;code>ht[1]&lt;/code> 指向 &lt;code>NULL&lt;/code>，同时程序将 &lt;code>rehashidx&lt;/code> 属性的值设为 &lt;code>-1&lt;/code>，表示 rehash 操作已完成。&lt;/li>
&lt;/ol>
&lt;p>渐进式 rehash 的过程中，字典会同时使用 &lt;code>ht[0]&lt;/code> 和 &lt;code>ht[1]&lt;/code> 两个数组，所以在&lt;strong>渐进式 rehash 进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行&lt;/strong>。&lt;/p>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">&lt;p>rehash 进行期间，查找某个 key 的操作，Redis 会先去 &lt;code>ht[0]&lt;/code> 数组上进行查找操作，如果 &lt;code>ht[0]&lt;/code> 不存在，就会去 &lt;code>ht[1]&lt;/code> 数组上进行查找操作。如果 &lt;code>ht[0]&lt;/code> 存在 key，就会把对应的 key 搬到 &lt;code>ht[1]&lt;/code> 数组上。而且会把 key 所在的桶的整个链表全部迁移到 &lt;code>ht[1]&lt;/code> 数组上。删除和更新都依赖于查找，先必须把元素找到，才可以进行数据结构的修改操作。&lt;/p>
&lt;p>&lt;strong>Redis 还有一个循环定时器去不断的去执行 rehash 操作，即使没有命令执行，也会不断的执行 rehash 操作&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>rehash 由主线程控制，不会有并发安全的问题&lt;/strong>。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="img-zoom">
&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redisdb-dict.jpg" alt="redisdb-dict">
&lt;/div>
&lt;h2>扩容条件&lt;span class="hx-absolute -hx-mt-20" id="扩容条件">&lt;/span>
&lt;a href="#%e6%89%a9%e5%ae%b9%e6%9d%a1%e4%bb%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>正常情况下，当 hash 表中&lt;strong>元素的个数等于数组的长度时&lt;/strong>，就会开始扩容，扩容的&lt;strong>新数组是原数组大小的 2 倍&lt;/strong>。不过如果 Redis 正在做 bgsave，为了减少内存页的过多分离 (Copy On Write)，Redis 尽量不去扩容，但是如果 hash 表已经非常满了，元素的个数已经达到了数组长度的 5 倍，说明 hash 表已经过于拥挤了，这个时候就会强制扩容。&lt;/p>
&lt;h2>缩容条件&lt;span class="hx-absolute -hx-mt-20" id="缩容条件">&lt;/span>
&lt;a href="#%e7%bc%a9%e5%ae%b9%e6%9d%a1%e4%bb%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>当 hash 表因为元素的逐渐删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的数组空间占用。缩容的条件是&lt;strong>元素个数低于数组长度的 10%&lt;/strong>。缩容不会考虑 Redis 是否正在做 bgsave。&lt;/p></description></item><item><title>Redis Object</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/03_redis_obj/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/03_redis_obj/</guid><description>
&lt;div class="img-zoom">
&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redisdb-dict.jpg" alt="redisdb-dict">
&lt;/div>
&lt;p>Redis 在存储 value 时，会把 value 包装成一个 RedisObject 数据结构，RedisObject 是 Redis 中所有 key 和 value 的基础数据结构。比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合，等等。&lt;/p>
&lt;p>每个对象都由一个 &lt;code>redisObject&lt;/code> 结构表示:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">redisObject&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="nl">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 编码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="nl">encoding&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 指向底层实现数据结构的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">unsigned&lt;/span> &lt;span class="nl">lru&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">LRU_BITS&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// LRU 时间或 LFU 数据（24位）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">refcount&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="n">robj&lt;/span>&lt;span class="p">;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>lru (24 bits)&lt;/code>: 用于实现内存回收策略。
&lt;ul>
&lt;li>在 LRU 模式下：记录对象最后一次被访问的时间&lt;/li>
&lt;li>在 LFU 模式下：
&lt;ul>
&lt;li>16 bits: 最近访问时间（分钟级）&lt;/li>
&lt;li>8 bits: 访问频率计数器（logarithmic counter）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>refcount&lt;/code>: 引用计数，用于内存管理。&lt;strong>当 &lt;code>refcount&lt;/code> 为 0 时，对象会被释放&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">set&lt;/span> str guanyu
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">set&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="m">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">set&lt;/span> long aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">type&lt;/span> str
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">string
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">type&lt;/span> &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">string
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">type&lt;/span> long
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">string
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; object encoding str
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;embstr&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; object encoding &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;int&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; object encoding long
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;raw&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>type&lt;/code> 命令可以看到 value 的类型都是 &lt;code>string&lt;/code>，&lt;code>object encoding&lt;/code> 查看编码，可以看到虽然都是字符串，但是编码方式不同。字符串就只有 3 种编码方式：&lt;/p>
&lt;ul>
&lt;li>&lt;code>int&lt;/code>&lt;/li>
&lt;li>&lt;code>embstr&lt;/code>&lt;/li>
&lt;li>&lt;code>raw&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2>String Encoding&lt;span class="hx-absolute -hx-mt-20" id="string-encoding">&lt;/span>
&lt;a href="#string-encoding" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>raw&lt;span class="hx-absolute -hx-mt-20" id="raw">&lt;/span>
&lt;a href="#raw" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>raw&lt;/code> 就是 SDS。&lt;/p>
&lt;p>Redis 的字符串有两种存储方式，在长度特别短时，使用 emb 形式存储 (embeded)，当&lt;strong>长度超过 44 时，使用 &lt;code>raw&lt;/code> 形式存储&lt;/strong>。&lt;/p>
&lt;h3>int&lt;span class="hx-absolute -hx-mt-20" id="int">&lt;/span>
&lt;a href="#int" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>redisObject&lt;/code> 中的 &lt;code>ptr&lt;/code> 指针是真正存储数据的地方，但是对于 &lt;code>int&lt;/code> 编码来说，一个 &lt;code>int&lt;/code> 类型的整数最多是 64 位，也就是 8 个字节，而 &lt;code>ptr&lt;/code> 指针所占用的存储空间也是 8 个字节。&lt;/p>
&lt;p>那么能不能&lt;strong>把 &lt;code>int&lt;/code> 类型的整数直接存储在 &lt;code>ptr&lt;/code> 指针中&lt;/strong>呢？&lt;/p>
&lt;p>答案是可以的，但是为了避免内存的浪费，Redis 在存储 value 时，会判断 value 的长度，如果 value 的&lt;strong>长度小于 20 个字符&lt;/strong>并且&lt;strong>可以转为整形&lt;/strong>（&lt;code>2^64&lt;/code> 能表示的最大的数字是 20 位），那么就会把 value 直接存储在 &lt;code>ptr&lt;/code> 指针中。&lt;/p>
&lt;p>这么做的好处有两个：&lt;/p>
&lt;ol>
&lt;li>节省了内存，不需要再为 value 分配内存。&lt;/li>
&lt;li>可以直接使用 &lt;code>ptr&lt;/code> 指针中的值，而不需要再根据 &lt;code>ptr&lt;/code> 指针地址去取值，省去了一次内存访问的开销。&lt;/li>
&lt;/ol>
&lt;h3>embstr&lt;span class="hx-absolute -hx-mt-20" id="embstr">&lt;/span>
&lt;a href="#embstr" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>字符串长度小于 44 时，使用 &lt;code>embstr&lt;/code> 形式存储。&lt;/p>
&lt;h4>为什么是小于 44 呢？&lt;span class="hx-absolute -hx-mt-20" id="为什么是小于-44-呢">&lt;/span>
&lt;a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e5%b0%8f%e4%ba%8e-44-%e5%91%a2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>先看 Redis 对象头结构体：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">redisObject&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">unsigned&lt;/span> &lt;span class="nl">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 4 bits
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="nl">encoding&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 4 bits
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="nl">lru&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">LRU_BITS&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 24 bits
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">refcount&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 4 bytes
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 8 bytes，64-bit system
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="n">robj&lt;/span>&lt;span class="p">;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>不同的对象具有不同的类型 &lt;code>type&lt;/code>，同一个类型的 &lt;code>type&lt;/code> 会有不同的编码形式 &lt;code>encoding&lt;/code>，为了记录对象的 LRU 信息，使用了 24 个 bit 来记录 LRU 信息。&lt;/li>
&lt;li>每个对象都有个引用计数，当引用计数为零时，对象就会被销毁，内存被回收。&lt;/li>
&lt;li>&lt;code>ptr&lt;/code> 指针将指向对象内容 (body) 的具体存储位置。这样一个 &lt;strong>&lt;code>redisObject&lt;/code> 需要占据 16 字节&lt;/strong>的存储空间。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CPU 缓冲行 cache line 一般一次性读取 64 字节的数据&lt;/strong>。&lt;/p>
&lt;p>Redis 读取数据时，先从 &lt;code>dictEntry&lt;/code> 中读取到 value 的指针，拿到 &lt;code>redisObject&lt;/code> 后，再通过 &lt;code>redisObject&lt;/code> 中的 &lt;code>ptr&lt;/code> 去读取 value 的数据。上面已经知道 &lt;code>redisObject&lt;/code> 占据 16 字节，而 CPU cache line 一般一次性读取 64 字节的数据，还有 48 字节的空间没有被使用。&lt;/p>
&lt;p>&lt;strong>那这 48 字节的空间可以用来存储什么数据&lt;/strong>呢？&lt;/p>
&lt;p>再来看 SDS 结构体：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nf">__attribute__&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">__packed__&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="n">sdshdr8&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint8_t&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 1 byte
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">uint8_t&lt;/span> &lt;span class="n">alloc&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 1 byte
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">flags&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 1 byte
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>len&lt;/code>，&lt;code>alloc&lt;/code>，&lt;code>flags&lt;/code> 分别占据 1 字节，而且由于 sds 要兼容 C 语言的函数库，所以 &lt;strong>&lt;code>buf&lt;/code> 后面还要添加一个字符 &lt;code>\0&lt;/code>&lt;/strong>，也占据 1 字节。所以这个 sds 对象要占据 4 字节。&lt;/p>
&lt;p>48 减去 4 字节，还剩下 44 字节，刚好可以存储一个 44 字节的字符串。这样就可以&lt;strong>一次性把 &lt;code>redisObject&lt;/code> 和 &lt;code>sds&lt;/code> 一起读取到 CPU cache line 中，减少了内存访问的次数，提高了读取效率&lt;/strong>。&lt;/p></description></item><item><title>位图</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/04_bitmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/04_bitmap/</guid><description>
&lt;p>位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 &lt;strong>&lt;code>byte&lt;/code> 数组&lt;/strong>。&lt;/p>
&lt;p>在日常开发中，可能会有一些 &lt;code>bool&lt;/code> 型数据需要存取，如果使用普通的 &lt;code>key/value&lt;/code> 方式存储，会浪费很多存储空间,比如签到记录，签了是 &lt;code>true&lt;/code>，没签是 &lt;code>false&lt;/code>，记录 365 天。如果每个用户存储 365 条记录，当用户量很庞大的时候，需要的存储空间是惊人的。&lt;/p>
&lt;p>对于这种操作，Redis 提供了位操作，这样每天的签到记录只占据一个位，用 1 表示已签到，0 表示没签，那么 365 天就是 365 个 bit，46 个字节就可以完全容纳下，大大节约了存储空间。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>11001101010010&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>当我们要统计月活的时候，因为需要去重，需要使用 &lt;code>set&lt;/code> 来记录所有活跃用户的 id，这非常浪费内存。这时就可以考虑使用位图来标记用户的活跃状态。每个用户会都在这个位图的一个确定位置上，0 表示不活跃，1 表示活跃。然后到月底遍历一次位图就可以得到月度活跃用户数。不过这个方法也是有条件的，那就是 &lt;code>userid&lt;/code> 是整数连续的（用户 id 作为 offset），并且活跃占比较高，否则可能得不偿失。&lt;/p>
&lt;h2>基本使用&lt;span class="hx-absolute -hx-mt-20" id="基本使用">&lt;/span>
&lt;a href="#%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 的位数组是&lt;strong>自动扩展&lt;/strong>的，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。&lt;/p>
&lt;h3>setbit&lt;span class="hx-absolute -hx-mt-20" id="setbit">&lt;/span>
&lt;a href="#setbit" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>设置指定偏移量上的 bit 的值：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>setbit key offset 0|1&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>当 key 不存在时，&lt;strong>自动创建一个新的 key&lt;/strong>。&lt;/li>
&lt;li>&lt;code>offset&lt;/code> 参数的取值范围为大于等于 &lt;code>0&lt;/code>，小于 &lt;code>2^32&lt;/code>(bit 映射限制在 &lt;code>512MB&lt;/code> 以内)。&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 日活场景，设置 11 月 11 日用户 100 的登录状态为 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; setbit login_11_11 &lt;span class="m">100&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; getbit login_11_11 &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; getbit login_11_11 &lt;span class="m">101&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="c1"># bit 默认被初始化为 0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; strlen login_11_11 &lt;span class="c1"># 查看长度&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="c1"># 13 个字节&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">type&lt;/span> login_11_11 &lt;span class="c1"># 查看类型&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">string &lt;span class="c1"># 字符串类型&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; get login_11_11 &lt;span class="c1"># 查看值&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01&amp;#34;&lt;/span> &lt;span class="c1"># 13 个字节的字符串&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">上面的 length 之所以是 13 个字节，是因为 &lt;code>100&lt;/code> 表示的是偏移量为 &lt;code>100&lt;/code> 的 bit，而一个字节有 8 个 bit，所以需要 13 个字节才能表示偏移量为 &lt;code>100&lt;/code> 的 bit。&lt;/div>
&lt;/div>
&lt;/div>
&lt;h3>getbit&lt;span class="hx-absolute -hx-mt-20" id="getbit">&lt;/span>
&lt;a href="#getbit" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>获取指定偏移量上的 bit 的值：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; exists testbit2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; getbit testbit2 &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; setbit testbit2 &lt;span class="m">100&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; getbit testbit2 &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>&lt;code>offset&lt;/code> 比字符串值的长度大，或者 key 不存在时，返回 &lt;code>0&lt;/code>&lt;/strong>。&lt;/p>
&lt;h3>统计&lt;span class="hx-absolute -hx-mt-20" id="统计">&lt;/span>
&lt;a href="#%e7%bb%9f%e8%ae%a1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>统计指令 &lt;code>bitcount&lt;/code> 用来统计指定位置范围内 1 的个数。&lt;/li>
&lt;li>&lt;code>bitop&lt;/code> 指令用来对多个 &lt;code>bit&lt;/code> 数组进行位运算。&lt;/li>
&lt;/ul>
&lt;p>比如可以通过 &lt;code>bitcount&lt;/code> 统计用户一共签到了多少天，如果指定了范围参数 &lt;code>[start, end]&lt;/code>，就可以统计在某个时间范围内用户签到了多少天。&lt;/p>
&lt;p>&lt;strong>&lt;code>start&lt;/code> 和 &lt;code>end&lt;/code> 参数是字节索引，也就是说指定的位范围必须是 8 的倍数&lt;/strong>，而不能任意指定。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; setbit login_11_11 &lt;span class="m">100&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1"># 模拟用户 100 签到&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; setbit login_11_11 &lt;span class="m">101&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1"># 模拟用户 101 签到&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; setbit login_11_11 &lt;span class="m">102&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1"># 模拟用户 102 签到&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; setbit login_11_11 &lt;span class="m">103&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1"># 模拟用户 103 签到&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; bitcount login_11_11 &lt;span class="c1"># 统计 bit 为 1 的数量，没有指定范围，默认是整个字符串&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; strlen login_11_11 &lt;span class="c1"># 查看长度&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="c1"># 13 个字节&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; bitcount login_11_11 &lt;span class="m">0&lt;/span> &lt;span class="m">12&lt;/span> &lt;span class="c1"># 0 是第一个字节，12 是最后一个字节，统计 0-12 字节范围内 bit 为 1 的数量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>假设要统计用户连续登录的情况，比如用户 100 连续登录了 5 天，用户 101 连续登录了 3 天。&lt;/p>
&lt;p>可以将几天的数据进行&lt;strong>位运算&lt;/strong>，然后再统计结果中 1 的个数。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>login_11_07: 0 1 0 1 1 1 0 1 1 1 0 1 0 0 0 1
login_11_08: 0 0 0 1 0 1 0 1 1 1 0 1 0 0 0 1
login_11_09: 1 0 0 1 1 0 0 1 1 1 0 1 0 0 0 1
login_11_10: 1 1 0 1 0 1 0 1 1 1 0 1 0 0 0 1
login_11_11: 1 1 0 1 0 0 0 1 1 1 0 1 0 0 0 1
----------------------------------------------
0 0 0 1 0 0 0 1 1 1 0 1 0 0 0 1 # 按位与运算，连续登录的人数
1 1 0 1 1 1 0 1 1 1 0 1 0 0 0 1 # 按位或运算，只要有一天登录，就为 1，可以用来统计周活，月活等&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>bitop&lt;/code> 示例：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; setbit login_11_10 &lt;span class="m">100&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1"># 模拟用户 100 签到&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; setbit login_11_10 &lt;span class="m">101&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1"># 模拟用户 101 签到&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; setbit login_11_10 &lt;span class="m">102&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1"># 模拟用户 102 签到&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; bitop and login_11_10-11 login_11_10 login_11_11 &lt;span class="c1"># 按位与运算，连续登录的人数，and 表示按位与运算，结果保存在 login_11_10-11 中&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">13&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; bitcount login_11_10-11 &lt;span class="c1"># 统计连续登录的人数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; bitop or login_11_10-11-active login_11_10 login_11_11 &lt;span class="c1"># 按位或运算，只要有一天登录，就为 1，or 表示按位或运算，结果保存在 login_11_10-11-active 中&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">13&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; bitcount login_11_10-11-active
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>ziplist</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/05_ziplist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/05_ziplist/</guid><description>
&lt;p>Redis 为了节约内存空间使用，zset 和 hash 容器对象在元素个数较少的时候，采用压缩列表 (&lt;code>ziplist&lt;/code>) 进行存储。压缩列表是&lt;strong>一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙&lt;/strong>。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; hset testhash name pooky address shanghai f1 v1 f2 v2 f3 v3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; hgetall testhash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pooky&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;address&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;shanghai&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;f1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;f2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;v2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;f3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;v3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; object encoding testhash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;ziplist&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>可以看出，hash 中的元素是顺序存放的。这时 hash 底层的存储结构时 &lt;code>ziplist&lt;/code>。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; hset testhash f4 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; hgetall testhash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pooky&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;f4&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;f2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;v3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;f3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;v3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;f1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;v1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;address&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">12&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;shanghai&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; object encoding testhash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;hashtable&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>可以看出，hash 中的元素时乱序的，这是因为这个时候 hash 底层的存储结构已经从 &lt;code>ziplist&lt;/code> 变成了 &lt;code>hashtable&lt;/code>。&lt;code>f4&lt;/code> 这个元素的长度超过了 &lt;code>hash-max-ziplist-value&lt;/code> 的 64 字节。&lt;/p>
&lt;h2>数据结构&lt;span class="hx-absolute -hx-mt-20" id="数据结构">&lt;/span>
&lt;a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 的 &lt;code>ziplist&lt;/code> 是一个紧凑的 &lt;code>byte&lt;/code> 数组结构，如下图，每个元素之间都是紧挨着的。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-ziplist.png" alt="redis-ziplist" loading="lazy" />&lt;/p>
&lt;ul>
&lt;li>&lt;code>zlbytes&lt;/code>：整个压缩列表占用字节数。&lt;/li>
&lt;li>&lt;code>zltail_offset&lt;/code> 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点。&lt;/li>
&lt;li>&lt;code>zllength&lt;/code>：元素个数。&lt;/li>
&lt;li>&lt;code>entries&lt;/code>：元素内容列表，挨个挨个紧凑存储。&lt;/li>
&lt;li>&lt;code>zlend&lt;/code>：标志压缩列表的结束。&lt;/li>
&lt;/ul>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">&lt;code>ziplist&lt;/code> 为了支持双向遍历，所以才会有 &lt;code>ztail_offset&lt;/code> 这个字段，用来快速定位到最后一个元素，然后倒着遍历。&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>entry&lt;/code> 块可以容纳不同的元素类型，也会有不一样的结构：&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-ziplist-entry.png" alt="redis-ziplist-entry" loading="lazy" />&lt;/p>
&lt;ul>
&lt;li>&lt;code>prerawlen&lt;/code>：表示前一个 entry 的字节长度，当压缩列表倒着遍历时，需要通过这个字段来快速定位到下一个元素的位置。它是一个变长的整数，当字符串长度小于 254 时，使用一个字节表示；如果达到或超出 254 那就使用 5 个字节来表示（第一个字节是 254，剩余四个字节表示字符串长度）。&lt;/li>
&lt;li>&lt;code>len&lt;/code>：除了表示当前元素的字节长度，还有别的含义。&lt;code>len&lt;/code> 的第一个字节分为 9 种情况：
&lt;ul>
&lt;li>&lt;code>00xxxxxx&lt;/code>：前两个 bit 是 00，&lt;code>len&lt;/code> 占 1 个字节。剩余的 6 个 bit 表示字符串长度，即最大的长度是 &lt;code>2^6 - 1&lt;/code>。&lt;/li>
&lt;li>&lt;code>01xxxxxx xxxxxxxx&lt;/code>：前两个 bit 是 01，&lt;code>len&lt;/code> 占 2 个字节。剩余的 14 个 bit 表示字符串长度，即最大的长度是 &lt;code>2^14 - 1&lt;/code>。&lt;/li>
&lt;li>&lt;code>10xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx&lt;/code>：前两个 bit 是 10，&lt;code>len&lt;/code> 占 5 个字节。剩余的 32 个 bit 表示字符串长度，即最大的长度是 &lt;code>2^32 - 1&lt;/code>。&lt;/li>
&lt;li>&lt;code>11000000&lt;/code>：表示 &lt;code>int16&lt;/code>，&lt;code>len&lt;/code> 占 1 个字节。后面的 &lt;code>data&lt;/code> 占 2 个字节。&lt;/li>
&lt;li>&lt;code>11010000&lt;/code>：表示 &lt;code>int32&lt;/code>，&lt;code>len&lt;/code> 占 1 个字节。后面的 &lt;code>data&lt;/code> 占 4 个字节。&lt;/li>
&lt;li>&lt;code>11100000&lt;/code>：表示 &lt;code>int64&lt;/code>，&lt;code>len&lt;/code> 占 1 个字节。后面的 &lt;code>data&lt;/code> 占 8 个字节。&lt;/li>
&lt;li>&lt;code>11110000&lt;/code> 表示 &lt;code>int24&lt;/code>，&lt;code>len&lt;/code> 占 1 个字节。后面的 &lt;code>data&lt;/code> 占 3 个字节。&lt;/li>
&lt;li>&lt;code>11111110&lt;/code> 表示 &lt;code>int8&lt;/code>，&lt;code>len&lt;/code> 占 1 个字节。后面的 &lt;code>data&lt;/code> 占 1 个字节。&lt;/li>
&lt;li>&lt;code>1111xxxx&lt;/code> 表示极小整数，&lt;code>xxxx&lt;/code> 的范围只能是 &lt;code>0001~1101&lt;/code>, 也就是 &lt;code>1~13&lt;/code>，因为 &lt;code>0000&lt;/code>、&lt;code>1110&lt;/code>、&lt;code>1111&lt;/code>（&lt;code>11111111&lt;/code> 表示 &lt;code>ziplist&lt;/code> 的结束，也就是 &lt;code>zlend&lt;/code>）都被其他情况占用了。读取到的 &lt;code>value&lt;/code> 需要将 &lt;code>xxxx&lt;/code> 减 &lt;code>1&lt;/code>，也就是整数 &lt;code>0~12&lt;/code> 就是最终的 &lt;code>value&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>data&lt;/code>：元素的内容。&lt;/li>
&lt;/ul>
&lt;h3>存储 hash 结构&lt;span class="hx-absolute -hx-mt-20" id="存储-hash-结构">&lt;/span>
&lt;a href="#%e5%ad%98%e5%82%a8-hash-%e7%bb%93%e6%9e%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>如果 &lt;code>ziplist&lt;/code> 存储的是 hash 结构，那么 &lt;strong>key 和 value 会作为两个 entry 相邻存在一起&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-ziplist-hash.png" alt="redis-ziplist-hash" loading="lazy" />&lt;/p>
&lt;h4>配置选项&lt;span class="hx-absolute -hx-mt-20" id="配置选项">&lt;/span>
&lt;a href="#%e9%85%8d%e7%bd%ae%e9%80%89%e9%a1%b9" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>当数据量比较少，或者单个元素比较小的时候，Redis 会使用 &lt;code>ziplist&lt;/code> 来存储。数据大小和元素数量的阈值可以通过以下配置项来调整：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="na">hash-max-ziplist-entries 512 # ziplist 的元素个数超过 512，就使用 hashtable 存储&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">hash-max-ziplist-value 64 # 单个元素大小超过 64 字节，就使用 hashtable 存储&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>存储 zset 结构&lt;span class="hx-absolute -hx-mt-20" id="存储-zset-结构">&lt;/span>
&lt;a href="#%e5%ad%98%e5%82%a8-zset-%e7%bb%93%e6%9e%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>zset&lt;/code> 使用 &lt;code>ziplist&lt;/code> 来存储元素时，&lt;strong>value 和 score 会作为两个 entry 相邻存在一起&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-ziplist-zset.png" alt="redis-ziplist-zset" loading="lazy" />&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; zadd testzset &lt;span class="m">100&lt;/span> a &lt;span class="m">200&lt;/span> b &lt;span class="m">150&lt;/span> c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; zrange testzset &lt;span class="m">0&lt;/span> -1 withscores
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;a&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;100&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;c&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;150&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;b&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;200&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">type&lt;/span> testzset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;zset&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; object encoding testzset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;ziplist&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>配置选项&lt;span class="hx-absolute -hx-mt-20" id="配置选项-1">&lt;/span>
&lt;a href="#%e9%85%8d%e7%bd%ae%e9%80%89%e9%a1%b9-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="na">zset-max-ziplist-entries 128 # zset 的元素个数超过 128，使用 skiplist 存储&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">zset-max-ziplist-value 64 # zset 的任意元素大小超过 64 字节，使用 skiplist 存储&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>增加元素&lt;span class="hx-absolute -hx-mt-20" id="增加元素">&lt;/span>
&lt;a href="#%e5%a2%9e%e5%8a%a0%e5%85%83%e7%b4%a0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>因为 &lt;code>ziplist&lt;/code> 是紧凑存储，没有冗余空间 (对比一下 Redis 的字符串结构)。意味着插入一个新的元素就需要调用 &lt;code>realloc&lt;/code> 扩展内存。取决于内存分配器算法和当前的 &lt;code>ziplist&lt;/code> 内存大小，&lt;code>realloc&lt;/code> 可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能在原有的地址上进行扩展，这时就不需要进行旧内容的内存拷贝。&lt;/p>
&lt;p>&lt;strong>如果 &lt;code>ziplist&lt;/code> 占据内存太大，重新分配内存和拷贝内存就会有很大的消耗&lt;/strong>。所以 &lt;code>ziplist&lt;/code> 不适合存储大型字符串，存储的元素也不宜过多。&lt;/p>
&lt;h2>intset&lt;span class="hx-absolute -hx-mt-20" id="intset">&lt;/span>
&lt;a href="#intset" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>当 set 集合容纳的&lt;strong>元素都是整数并且元素个数较少&lt;/strong>时，会使用 &lt;code>intset&lt;/code> 来存储结合元素。&lt;code>intset&lt;/code> 是紧凑的数组结构，同时支持 16 位、32 位和 64 位整数。&lt;/p>
&lt;p>&lt;strong>如果向 set 里存储非整数值时，那么 sadd 立即转变为 hashtable 结构&lt;/strong>。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; sadd testset &lt;span class="m">1&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">10&lt;/span> &lt;span class="m">9&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="m">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">7&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; smembers testset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;4&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;5&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;9&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">type&lt;/span> testset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;set&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; object encoding testset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;intset&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>可以看到上面的 &lt;code>set&lt;/code> 中的元素是有序的，为什么不是无序的？因为 &lt;code>set&lt;/code> 底层的存储结构是 &lt;code>intset&lt;/code>，&lt;strong>&lt;code>intset&lt;/code> 是一个紧凑的数组结构&lt;/strong>。&lt;strong>有序的数组&lt;/strong>查询的时间复杂度是 &lt;code>O(logn)&lt;/code>，因为&lt;strong>可以使用二分查找&lt;/strong>。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; sadd testset a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; smembers testset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;4&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;9&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;10&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;a&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;5&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">type&lt;/span> testset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;set&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; object encoding testset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;hashtable&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>可以看到上面的 &lt;code>set&lt;/code> 中的元素是无序的，因为 &lt;code>set&lt;/code> 底层的存储结构已经变成了 &lt;code>hashtable&lt;/code>。&lt;/p>
&lt;h3>配置选项&lt;span class="hx-absolute -hx-mt-20" id="配置选项-2">&lt;/span>
&lt;a href="#%e9%85%8d%e7%bd%ae%e9%80%89%e9%a1%b9-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>intset&lt;/code> 能存储的元素个数可以通过下面的配置项来调整：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="na">set-max-intset-entries 512 # set 的整数元素个数超过 512，使用 hashtable 存储&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>数据结构&lt;span class="hx-absolute -hx-mt-20" id="数据结构-1">&lt;/span>
&lt;a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">intset&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">encoding&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 编码类型，决定整数位是 16 位、32 位还是 64 位
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 元素个数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int8_t&lt;/span> &lt;span class="n">contents&lt;/span>&lt;span class="p">[];&lt;/span> &lt;span class="c1">// 元素数组，可以是 16 位、32 位和 64 位
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="n">intset&lt;/span>&lt;span class="p">;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-intset.png" alt="redis-intset" loading="lazy" />&lt;/p></description></item><item><title>quicklist</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/06_quicklist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/06_quicklist/</guid><description>
&lt;p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 &lt;code>ziplist&lt;/code> 和普通的双向链表 &lt;code>linkedlist&lt;/code>，也就是元素少时用 &lt;code>ziplist&lt;/code>，元素多时用 &lt;code>linkedlist&lt;/code>。&lt;/p>
&lt;p>但是由于 &lt;code>linkedlist&lt;/code> 结构，要存储 &lt;code>pre&lt;/code> 和 &lt;code>next&lt;/code> 指针，一个指针的大小为 8 字节，两个指针的大小为 16 字节（如果节点本身存储的 value 很小，比如 1 个字节，但是还是需要 16 个字节来存储指针，非常浪费空间）。当&lt;strong>链表中的节点非常多时，指针占用的空间就会非常大&lt;/strong>，而且链表的内存是不连续的，会产生内存碎片，影响内存的利用率。&lt;/p>
&lt;p>Redis 使用 &lt;code>quicklist&lt;/code> 代替了 &lt;code>ziplist&lt;/code> 和 &lt;code>linkedlist&lt;/code>。&lt;/p>
&lt;p>&lt;code>quicklist&lt;/code> 是 &lt;code>ziplist&lt;/code> 和 &lt;code>linkedlist&lt;/code> 的混合体，它将 &lt;code>linkedlist&lt;/code> 按段切分，每一段使用 &lt;code>ziplist&lt;/code> 来紧凑存储，每个节点之间用双向指针串接起来，组成一个&lt;strong>双向链表&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-quicklist.png" alt="redis-quicklist" loading="lazy" />&lt;/p>
&lt;p>&lt;code>quicklist&lt;/code> 虽然还有 &lt;code>pre&lt;/code> 和 &lt;code>next&lt;/code> 指针，但是节点少了很多。&lt;/p>
&lt;h2>配置选项&lt;span class="hx-absolute -hx-mt-20" id="配置选项">&lt;/span>
&lt;a href="#%e9%85%8d%e7%bd%ae%e9%80%89%e9%a1%b9" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>可以设置每个 &lt;code>ziplist&lt;/code> 的最大容量，&lt;code>quicklist&lt;/code> 的数据压缩范围，提升数据存取效率。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="na">list-max-ziplist-size -2 # -2 表示每个 ziplist 最多存储 8kb 大小，超过则会分裂，将数据存储在新的 ziplist 节点中&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">list-compress-depth 0 # 压缩深度。0 表示不压缩，1 表示头部的一个，尾部的一个，一共两个 ziplist 节点不压缩，中间的节点全部压缩。依次类推，2 表示头部的两个，尾部的两个，一共四个节点不压缩。&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>&lt;code>list-max-ziplist-size&lt;/code> 不建议设置太大，因为 &lt;code>ziplist&lt;/code> 增加元素时会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址&lt;/strong>。如果 &lt;code>ziplist&lt;/code> 占据内存太大，重新分配内存和拷贝内存就会有很大的消耗。&lt;/p>
&lt;p>所以 &lt;code>ziplist&lt;/code> 不适合存储大型字符串，存储的元素也不宜过多。&lt;/p>
&lt;p>&lt;code>quicklist&lt;/code> 默认的压缩深度是 0。&lt;/p>
&lt;h2>增加元素&lt;span class="hx-absolute -hx-mt-20" id="增加元素">&lt;/span>
&lt;a href="#%e5%a2%9e%e5%8a%a0%e5%85%83%e7%b4%a0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>增加元素时，只需要修改其中一个 &lt;code>ziplist&lt;/code> 节点即可。当 &lt;code>ziplist&lt;/code> 节点的大小超过了 &lt;code>list-max-ziplist-size&lt;/code> 时，就会分裂出新的 &lt;code>quicklistNode&lt;/code>，将数据存储在新的 &lt;code>ziplist&lt;/code> 节点中。&lt;/p>
&lt;h2>压缩深度&lt;span class="hx-absolute -hx-mt-20" id="压缩深度">&lt;/span>
&lt;a href="#%e5%8e%8b%e7%bc%a9%e6%b7%b1%e5%ba%a6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>当某一个 list 列表中，存储了一部分热点数据，如果头尾节点数据是热点数据经常被访问，中间的数据访问不是那么频繁，就可以设置压缩深度，将中间的数据压缩，减少内存的占用。&lt;/p></description></item><item><title>跳表</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/07_skiplist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/07_skiplist/</guid><description>
&lt;p>&lt;code>zset&lt;/code> 的内部实现是一个 &lt;code>hashtable&lt;/code> 加一个跳跃列表 (&lt;code>skiplist&lt;/code>)。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">zset&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dict&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dict&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// all values value=&amp;gt;score
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">zskiplist&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">zsl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>dict&lt;/code> 是一个 &lt;code>hashtable&lt;/code> 结构用来存储 &lt;code>value&lt;/code> 和 &lt;code>score&lt;/code> 值的映射关系。用来查找数据到分数的对应关系。&lt;/li>
&lt;li>&lt;code>zsl&lt;/code> 是一个 &lt;code>skiplist&lt;/code> 结构，用来根据分数查询数据，支持范围查询。&lt;/li>
&lt;/ul>
&lt;h2>跳表的原理&lt;span class="hx-absolute -hx-mt-20" id="跳表的原理">&lt;/span>
&lt;a href="#%e8%b7%b3%e8%a1%a8%e7%9a%84%e5%8e%9f%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>假设使用链表来存储数据，查找一个元素的时间复杂度是 &lt;code>O(n)&lt;/code>，因为要遍历整个链表。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-skiplist1.png" alt="redis-skiplist1" loading="lazy" />&lt;/p>
&lt;p>可以加一个索引层，索引层的元素指向原始链表中的元素，这样查找元素 79，就可以从索引层开始找。只要找到第一个比 79 大的元素，图中就是 84，然后就通过前一个元素 78 指向的指针，找到原始链表中的 79。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-skiplist2.png" alt="redis-skiplist2" loading="lazy" />&lt;/p>
&lt;p>上面的索引层是一层，相对于原始链表来说，查找的元素个数大概减少了一半。&lt;/p>
&lt;p>如果再加一层索引层，那么查找的元素个数就会减少到原来的 1/4。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-skiplist3.png" alt="redis-skiplist3" loading="lazy" />&lt;/p>
&lt;p>从第一层索引层开始查找，最后一个元素是 78，比 79 小，那就往下一层索引层找。&lt;/p>
&lt;p>如果再加一层索引层，就可以明显的看出来，一次减少一半，类似二分查找：&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/skiplist-demo.png" alt="skiplist-demo" loading="lazy" />&lt;/p>
&lt;p>&lt;strong>时间复杂度&lt;/strong>：&lt;/p>
&lt;p>如果有 N 个元素：&lt;/p>
&lt;ul>
&lt;li>第一层索引层的元素个数是 &lt;code>N/2&lt;/code>。&lt;/li>
&lt;li>第二层索引层的元素个数是 &lt;code>N/4&lt;/code>。&lt;/li>
&lt;li>第三层索引层的元素个数是 &lt;code>N/8&lt;/code>。&lt;/li>
&lt;li>第 k 层索引层的元素个数是 &lt;code>N/(2^k)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>假设 k 层索引层的元素个数是 2，那么 &lt;code>N/(2^k)=2 =&amp;gt; 2^k=N/2 =&amp;gt; k=log2(N/2)&lt;/code>，索引的访问，每层大概访问两个元素，是常数级的。忽略掉常数，即 &lt;code>k=logN&lt;/code>。&lt;/p>
&lt;h2>zskiplist&lt;span class="hx-absolute -hx-mt-20" id="zskiplist">&lt;/span>
&lt;a href="#zskiplist" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-zskiplist.png" alt="redis-zskiplist" loading="lazy" />&lt;/p>
&lt;p>上图中只有三个元素，&lt;code>a&lt;/code>、&lt;code>b&lt;/code>、&lt;code>c&lt;/code>，对应的 score 值分别是 100、120、200。&lt;/p>
&lt;ul>
&lt;li>&lt;code>header&lt;/code> 指向跳表的&lt;strong>头节点&lt;/strong>。头节点不存储任何数据，只用来作为跳表的&lt;strong>起始点&lt;/strong>。&lt;/li>
&lt;li>&lt;code>tail&lt;/code> 指向跳表的&lt;strong>尾节点&lt;/strong>，尾节点不存储任何数据，只用来作为跳表的&lt;strong>结束点&lt;/strong>。&lt;/li>
&lt;li>&lt;code>level&lt;/code> 表示当前跳表的&lt;strong>最高层数&lt;/strong>，初始化为 1。这是用来遍历跳表时，直接找到最高的一层开始遍历。图中虽然画的是 31 层，但是实际使用时，只使用了 3 层。&lt;/li>
&lt;li>&lt;code>length&lt;/code> 表示跳表中元素的个数，初始化为 0。&lt;/li>
&lt;/ul>
&lt;h4>zskiplistNode&lt;span class="hx-absolute -hx-mt-20" id="zskiplistnode">&lt;/span>
&lt;a href="#zskiplistnode" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>跳表的节点结构：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">zslnode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">string&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">score&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">zslnode&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">forwards&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 多层连接指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">zslnode&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">backward&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>backward&lt;/code> 指针用来从后往前遍历跳表。&lt;/li>
&lt;/ul>
&lt;h4>随机层数&lt;span class="hx-absolute -hx-mt-20" id="随机层数">&lt;/span>
&lt;a href="#%e9%9a%8f%e6%9c%ba%e5%b1%82%e6%95%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>不停地往跳表中插入数据时，如果不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。&lt;/p>
&lt;p>所以对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数。生成高层的索引节点的概率要小于生成低层的索引节点的概率。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* Returns a random level for the new skiplist node we are going to create.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * (both inclusive), with a powerlaw-alike distribution where higher
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * levels are less likely to be returned. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">zslRandomLevel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="nf">random&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="mh">0xFFFF&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ZSKIPLIST_P&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mh">0xFFFF&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">level&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">level&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">ZSKIPLIST_MAXLEVEL&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="nl">level&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">ZSKIPLIST_MAXLEVEL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>Go 实现一个简单的跳表&lt;span class="hx-absolute -hx-mt-20" id="go-实现一个简单的跳表">&lt;/span>
&lt;a href="#go-%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e8%b7%b3%e8%a1%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">const&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">MaxLevel&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">16&lt;/span> &lt;span class="c1">// 最大层级
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">Probability&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mf">0.5&lt;/span> &lt;span class="c1">// 每一层晋升的概率
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Skiplist&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">head&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Node&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">level&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 当前跳表的最大层级
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Node&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// nexts 指针是一个 slice 的形式，其长度对应为当前节点的高度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">nexts&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">Node&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// NewNode 创建一个新节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewNode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">value&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">node&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">node&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">key&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">value&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">value&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">next&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">level&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// NewSkipList 初始化跳表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewSkipList&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">SkipList&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">rand&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Seed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">UnixNano&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">head&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">NewNode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">math&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">MinInt32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">MaxLevel&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 头节点使用最小值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">SkipList&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">head&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">head&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">level&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// randomLevel 决定新节点的层级（几率下降）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">randomLevel&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">level&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">rand&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Float64&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">Probability&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">MaxLevel&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">level&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">level&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 根据 key 读取 val，第二个 bool flag 反映 key 在 skiplist 中是否存在
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Skiplist&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 根据 key 尝试检索对应的 node，如果 node 存在，则返回对应的 val
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">_node&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">_node&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">_node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 从跳表中检索 key 对应的 Node
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Skiplist&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Node&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每次检索从头部出发
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">move&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">head&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每次检索从最大高度出发，直到来到首层
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">level&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">level&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在每一层中持续向右遍历，直到下一个节点不存在或者 key 值大于等于 key
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">key&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">move&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果 key 值相等，则找到了目标直接返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">key&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 当前层没找到目标，则层数减 1，继续向下
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 遍历完所有层数，都没有找到目标，返回 nil
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 将 key-val 对加入 skiplist
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Skiplist&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 假如 kv对已存在，则直接对值进行更新并返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">_node&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">_node&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_node&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">val&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">val&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 新节点的高度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">randomLevel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建出新的节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">newNode&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">NewNode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">val&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从头节点的最高层出发
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">move&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">head&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">level&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">level&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 向右遍历，直到右侧节点不存在或者 key 值大于 key
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">key&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">move&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 调整指针关系，完成新节点的插入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">newNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">newNode&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 根据 key 从跳表中删除对应的节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Skiplist&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Del&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果 kv 对不存在，则无需删除直接返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">_node&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">_node&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从头节点的最高层出发
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">move&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">head&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">level&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">level&lt;/span>&lt;span class="o">--&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 向右遍历，直到右侧节点不存在或者 key 值大于等于 key
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">key&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">move&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 右侧节点不存在或者 key 值大于 target，则直接跳过
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">key&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">key&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 走到此处意味着右侧节点的 key 值必然等于 key，则调整指针引用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">move&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 更新跳表层级
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">level&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">head&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nexts&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">level&lt;/span>&lt;span class="o">--&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>GeoHash</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/08_geohash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/08_geohash/</guid><description>
&lt;h2>GeoHash 算法&lt;span class="hx-absolute -hx-mt-20" id="geohash-算法">&lt;/span>
&lt;a href="#geohash-%e7%ae%97%e6%b3%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>GeoHash 是一种地理位置编码的方法。GeoHash 算法&lt;strong>将二维的经纬度数据映射到一维的整数，这样所有的元素都将在挂载到一条线上，距离靠近的二维坐标映射到一维后，两点之间距离也会很接近&lt;/strong>。当我们想要计算&lt;strong>附近的人&lt;/strong>时，首先将目标位置映射到这条线上，然后在这个一维的线上获取附近的点就行了。&lt;/p>
&lt;p>地图元素的位置数据使用&lt;strong>二维的经纬度&lt;/strong>表示，经度范围 &lt;code>(-180, 180]&lt;/code>，纬度范围 &lt;code>(-90, 90]&lt;/code>，纬度正负以赤道为界，北正南负，经度正负以本初子午线 (英国格林尼治天文台) 为界，东正西负。&lt;/p>
&lt;p>如果纬度范围 &lt;code>[-90, 0)&lt;/code> 用二进制 0 表示，&lt;code>(0, 90]&lt;/code> 用二进制 1 表示。经度范围 &lt;code>[-180, 0)&lt;/code> 用二进制 0 表示，&lt;code>(0, 180]&lt;/code> 用二进制 1 表示。那么地球可以分为 4 个区域：&lt;/p>
&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/geo-earth.png" width="280px">
&lt;ul>
&lt;li>&lt;code>00&lt;/code> 第一个 0 表示纬度 &lt;code>[-90, 0)&lt;/code>，第二个 0 表示经度 &lt;code>[-180, 0)&lt;/code>。&lt;/li>
&lt;li>&lt;code>10&lt;/code> 0 表示纬度 &lt;code>[-90, 0)&lt;/code>，1 表示经度 &lt;code>(0, 180]&lt;/code>。&lt;/li>
&lt;li>&lt;code>01&lt;/code> 1 表示纬度 &lt;code>(0, 90]&lt;/code>，0 表示经度 &lt;code>[-180, 0)&lt;/code>。&lt;/li>
&lt;li>&lt;code>11&lt;/code> 第一个 1 表示纬度 &lt;code>(0, 90]&lt;/code>，第二个 1 表示经度 &lt;code>(0, 180]&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>分成 4 个区域之后，大概可以知道在地球的哪个方位了。如果想要更精确的定位，就可以继续切分，比如把 &lt;code>00&lt;/code> 继续分成 4 个区域。&lt;/p>
&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/geo-earth2.png" width="280px">
&lt;ul>
&lt;li>&lt;code>00&lt;/code> 分成了 4 个区域，这四个区域前面的 &lt;code>00&lt;/code> 就是父区域的编码。子区域的四个编码还是 &lt;code>00&lt;/code>、&lt;code>01&lt;/code>、&lt;code>10&lt;/code>、&lt;code>11&lt;/code>，再加上父区域的编码作为前缀，就得到了 &lt;code>0000&lt;/code>、&lt;code>0001&lt;/code>、&lt;code>0010&lt;/code>、&lt;code>0011&lt;/code>。&lt;/li>
&lt;li>有共同前缀的区域，可以理解为距离也是比价近的。&lt;/li>
&lt;/ul>
&lt;p>继续切下去，正方形就会越来越小，二进制整数也会越来越长，精确度就会越来越高。&lt;/p>
&lt;p>通过上述的过程，最终会得到一串二进制的编码。这串二进制编码通常很长，不便于阅读和传输。为了使得 Geohash 更加紧凑和易于使用，通常会将这串二进制编码转换成 Base32 编码。&lt;/p>
&lt;p>在 Redis 里面，将这个编码值放了 &lt;code>zset&lt;/code> 的 &lt;code>score&lt;/code> 中。&lt;/p>
&lt;p>在使用 Redis 进行 Geo 查询时，通过 &lt;code>zset&lt;/code> 的 &lt;code>score&lt;/code> 排序就可以得到坐标附近的其它元素，通过将 &lt;code>score&lt;/code> 还原成坐标值就可以得到元素的原始坐标。&lt;/p>
&lt;h2>Geo 指令&lt;span class="hx-absolute -hx-mt-20" id="geo-指令">&lt;/span>
&lt;a href="#geo-%e6%8c%87%e4%bb%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>geoadd&lt;span class="hx-absolute -hx-mt-20" id="geoadd">&lt;/span>
&lt;a href="#geoadd" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>geoadd&lt;/code> 指令携带集合名称以及多个经纬度名称三元组，注意这里可以加入多个三元组：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geoadd company 116.48105 39.996794 juejin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geoadd company 116.514203 39.905409 ireader
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geoadd company 116.489033 40.007669 meituan
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">2&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>geo 存储结构上使用的是 zset，意味着可以使用 zset 相关的指令来操作 geo 数据，所以删除指令可以直接使用 zrem 指令&lt;/strong>。&lt;/p>
&lt;h3>geodist&lt;span class="hx-absolute -hx-mt-20" id="geodist">&lt;/span>
&lt;a href="#geodist" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>geodist&lt;/code> 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geodist company juejin ireader km
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;10.5501&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geodist company juejin meituan km
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;1.3878&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geodist company juejin jd km
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;24.2739&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geodist company juejin xiaomi km
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;12.9606&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geodist company juejin juejin km
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;0.0000&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>掘金离美团最近，因为它们都在望京。距离单位可以是 &lt;code>m&lt;/code>、&lt;code>km&lt;/code>、&lt;code>ml&lt;/code>、&lt;code>ft&lt;/code>，分别代表米、千米、英里和尺。&lt;/p>
&lt;h3>geopos&lt;span class="hx-absolute -hx-mt-20" id="geopos">&lt;/span>
&lt;a href="#geopos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>geopos&lt;/code> 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geopos company juejin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;116.48104995489120483&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;39.99679348858259686&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geopos company ireader
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;116.5142020583152771&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;39.90540918662494363&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geopos company juejin ireader
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;116.48104995489120483&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;39.99679348858259686&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;116.5142020583152771&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;39.90540918662494363&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>获取的经纬度坐标和 &lt;code>geoadd&lt;/code> 进去的坐标有轻微的误差，原因是 &lt;code>geohash&lt;/code> 对二维坐标进行的一维映射是有损的，通过映射再还原回来的值会出现较小的差别。&lt;/p>
&lt;h3>geohash&lt;span class="hx-absolute -hx-mt-20" id="geohash">&lt;/span>
&lt;a href="#geohash" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>geohash&lt;/code> 可以获取元素的经纬度编码字符串，它是 base32 编码。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geohash company ireader
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;wx4g52e1ce0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; geohash company juejin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;wx4gd94yjn0&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>可以使用 &lt;a href="http://geohash.org/" target="_blank" rel="noopener">geohash&lt;/a> 来解编码。格式 &lt;code>http://geohash.org/wx4g52e1ce0&lt;/code>。&lt;/p>
&lt;h3>georadiusbymember&lt;span class="hx-absolute -hx-mt-20" id="georadiusbymember">&lt;/span>
&lt;a href="#georadiusbymember" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>georadiusbymember&lt;/code> 指令是最为关键的指令，它可以用来查询指定元素附近的其它元素。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; georadiusbymember company ireader &lt;span class="m">20&lt;/span> km count &lt;span class="m">3&lt;/span> asc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;ireader&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;juejin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;meituan&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 范围 20 公里以内最多 3 个元素按距离倒排&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; georadiusbymember company ireader &lt;span class="m">20&lt;/span> km count &lt;span class="m">3&lt;/span> desc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;jd&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;meituan&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;juejin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 三个可选参数 withcoord withdist withhash 用来携带附加参数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># withdist 很有用，它可以用来显示距离&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; georadiusbymember company ireader &lt;span class="m">20&lt;/span> km withcoord withdist withhash count &lt;span class="m">3&lt;/span> asc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;ireader&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;0.0000&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4069886008361398&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;116.5142020583152771&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;39.90540918662494363&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;juejin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;10.5501&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4069887154388167&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;116.48104995489120483&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;39.99679348858259686&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;meituan&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;11.5748&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4069887179083478&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;116.48903220891952515&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;40.00766997707732031&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>georadius&lt;span class="hx-absolute -hx-mt-20" id="georadius">&lt;/span>
&lt;a href="#georadius" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>georadius&lt;/code> 可以用来查询指定坐标附近的其它元素。参数和 &lt;code>georadiusbymember&lt;/code> 基本一致。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; georadius company 116.514202 39.905409 &lt;span class="m">20&lt;/span> km withdist count &lt;span class="m">3&lt;/span> asc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;ireader&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;0.0000&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;juejin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;10.5501&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;meituan&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;11.5748&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>注意&lt;span class="hx-absolute -hx-mt-20" id="注意">&lt;/span>
&lt;a href="#%e6%b3%a8%e6%84%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>地图应用中，车的数据、餐馆的数据可能会有百万千万条，如果使用 Redis 的 Geo 数据结构，它们将全部放在一个 &lt;code>zset&lt;/code> 集合中。在 Redis 的集群环境中，集合可能会从一个节点迁移到另一个节点，如果单个 key 的数据过大，会对集群的迁移工作造成较大的影响，在集群环境中单个 key 对应的数据量&lt;strong>不宜超过 1M&lt;/strong>，否则会导致集群迁移出现卡顿现象，影响线上服务的正常运行。&lt;/p>
&lt;p>建议 Geo 的数据使用单独的 Redis 实例部署，不使用集群环境。&lt;/p>
&lt;p>如果数据量过亿甚至更大，就需要&lt;strong>对 Geo 数据进行拆分，按国家拆分、按省拆分，按市拆分，在人口特大城市甚至可以按区拆分&lt;/strong>。这样就可以显著&lt;strong>降低单个 &lt;code>zset&lt;/code> 集合的大小&lt;/strong>。&lt;/p></description></item><item><title>HyperLogLog</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/09_hyperloglog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/09_hyperloglog/</guid><description>
&lt;p>如果你负责开发维护一个大型的网站，有一天老板找产品经理要网站每个网页每天的 UV（用户访问量，一个用户一天不论访问一次还是多次，都只算一次）数据，然后让你来开发这个统计模块，如何实现？&lt;/p>
&lt;p>如果统计 PV（页面访问量，只要页面被访问一次，就算一次，不管用户访问了多少次）那非常好办，给每个网页一个独立的 Redis 计数器就可以了，这个计数器的 &lt;code>key&lt;/code> 后缀加上当天的日期。这样来一个请求，&lt;code>incrby&lt;/code> 一次，最终就可以统计出所有的 PV 数据。&lt;/p>
&lt;p>但是 UV 不一样，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求每一个网页请求都需要带上用户的 ID，无论是登陆用户还是未登陆用户都需要一个唯一 ID 来标识。&lt;/p>
&lt;p>&lt;strong>一个非常简单的方案&lt;/strong>：&lt;/p>
&lt;p>为每一个页面一个独立的 &lt;code>set&lt;/code> 集合来存储所有当天访问过此页面的用户 ID。当一个请求过来时，使用 &lt;code>sadd&lt;/code> 将用户 ID 塞进去就可以了。通过 &lt;code>scard&lt;/code> 可以取出这个集合的大小，这个数字就是这个页面的 UV 数据。&lt;/p>
&lt;p>但是，如果页面访问量非常大，比如一个爆款页面几千万的 UV，就需要一个很大的 &lt;code>set&lt;/code> 集合来统计，这就非常浪费空间。如果这样的页面很多，还需要为每个页面都去创建一个 &lt;code>set&lt;/code> 集合，那所需要的存储空间是惊人的。&lt;/p>
&lt;p>Redis 提供了 &lt;code>HyperLogLog&lt;/code> 数据结构就是用来解决这种统计问题的。&lt;code>HyperLogLog&lt;/code> 提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，可以满足上面的 UV 统计需求了。&lt;/p>
&lt;h2>使用&lt;span class="hx-absolute -hx-mt-20" id="使用">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;code>HyperLogLog&lt;/code> 提供了两个指令 &lt;strong>&lt;code>pfadd&lt;/code> 和 &lt;code>pfcount&lt;/code>，根据字面意义很好理解，一个是增加计数，一个是获取计数&lt;/strong>。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfadd 08-15:u:id user1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfcount 08-15:u:id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfadd 08-15:u:id user2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfcount 08-15:u:id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfadd 08-15:u:id user3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfcount 08-15:u:id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfadd 08-15:u:id user4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfcount 08-15:u:id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfadd 08-15:u:id user5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfcount 08-15:u:id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfadd 08-15:u:id user6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfcount 08-15:u:id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">6&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfadd 08-15:u:id user7 user8 user9 user10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; pfcount 08-15:u:id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">10&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>但是在数据量比较大的时候，&lt;code>pfcount&lt;/code> 的结果就会出现误差。&lt;/p>
&lt;p>以使用集合类型和 HperLogLog 统计百万级用户访问次数的占用空间对比：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数据类型&lt;/th>
&lt;th>1天&lt;/th>
&lt;th>1个月&lt;/th>
&lt;th>1年&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>集合类型&lt;/td>
&lt;td>80M&lt;/td>
&lt;td>2.4G&lt;/td>
&lt;td>28G&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HyperLogLog&lt;/td>
&lt;td>15k&lt;/td>
&lt;td>450k&lt;/td>
&lt;td>5M&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以看到，HyperLogLog 内存占用量小得惊人，但是用如此小空间来估算如此巨大的数据，必然不是 100% 的正确，其中一定存在误差率。前面说过，Redis 官方给出的数字是 &lt;code>0.81%&lt;/code> 的失误率。&lt;/p>
&lt;h2>pfmerge&lt;span class="hx-absolute -hx-mt-20" id="pfmerge">&lt;/span>
&lt;a href="#pfmerge" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;code>pfmerge&lt;/code> 用于将多个 pf 计数值累加在一起形成一个新的 pf 值。&lt;/p>
&lt;p>比如在网站中我们有两个内容差不多的页面，运营说需要这两个页面的数据进行合并。其中页面的 UV 访问量也需要合并，那这个时候 &lt;code>pfmerge&lt;/code> 就可以派上用场了。&lt;/p>
&lt;h2>HyperLogLog 原理&lt;span class="hx-absolute -hx-mt-20" id="hyperloglog-原理">&lt;/span>
&lt;a href="#hyperloglog-%e5%8e%9f%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>基本原理&lt;span class="hx-absolute -hx-mt-20" id="基本原理">&lt;/span>
&lt;a href="#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>HyperLogLog &lt;strong>基于概率论中伯努利试验并结合了极大似然估算方法&lt;/strong>，并做了&lt;strong>分桶优化&lt;/strong>。&lt;/p>
&lt;p>实际上目前还没有发现更好的在大数据场景中准确计算基数的高效算法，因此在不追求绝对准确的情况下，使用概率算法算是一个不错的解决方案。概率算法不直接存储数据集合本身，通过一定的概率统计方法预估值，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Linear Counting&lt;/strong>(LC)：早期的基数估计算法，LC 在空间复杂度方面并不算优秀。&lt;/li>
&lt;li>&lt;strong>LogLog Counting&lt;/strong>(LLC)：LogLog Counting相比于 LC 更加节省内存，空间复杂度更低。&lt;/li>
&lt;li>&lt;strong>HyperLogLog Counting&lt;/strong>(HLL)：HyperLogLog Counting 是基于 LLC 的优化和改进，在同样空间复杂度情况下，能够比 LLC 的基数估计误差更小。&lt;/li>
&lt;/ul>
&lt;p>举个例子来理解 HyperLogLog 算法，有一天 Fox 老师和 Mark 老师玩抛硬币的游戏，规则是 Mark 老师负责抛硬币，每次抛的硬币可能正面，可能反面，每当抛到正面为一回合，Mark 老师可以自己决定进行几个回合。最后需要告诉 Fox 老师最长的那个回合抛了多少次以后出现了正面，再由 Fox 老师来猜 Mark 老师一共进行了几个回合。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/hll.png" alt="hll" loading="lazy" />&lt;/p>
&lt;p>进行了 n 个回合试验，比如上图：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>第一次: 抛了 3 次才出现正面，此时 `k=3，n=1`。
第二次试验: 抛了 2 次才出现正面，此时 `k=2，n=2`。
第三次试验: 抛了 4 次才出现正面，此时 `k=4，n=3`。
…………
第 n 次试验：抛了 7 次才出现正面，此时我们估算，`k=7，n=n`。&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>k&lt;/code> 是每回合抛到 &lt;code>1&lt;/code>（硬币的正面）所用的次数，我们已知的是最大的 &lt;code>k&lt;/code> 值，也就是 Mark 老师告诉 Fox 老师的数，可以用 &lt;code>k_max&lt;/code> 表示。由于每次抛硬币的结果只有 &lt;code>0&lt;/code> 和 &lt;code>1&lt;/code> 两种情况，因此，能够推测出 &lt;code>k_max&lt;/code> 在任意回合出现的概率 ，并由 &lt;code>kmax&lt;/code> 结合极大似然估算的方法推测出 &lt;code>n = 2^(k_max)&lt;/code>。概率学把这种问题叫做&lt;strong>伯努利实验&lt;/strong>。&lt;/p>
&lt;p>现在 Mark 老师已经完成了 n 个回合，并且告诉 Fox 老师最长的一次抛了 4 次，Fox 老师此时也胸有成竹，马上说出他的答案 16，最后的结果是：Mark 老师只抛了 3 回合，这三个回合中 &lt;code>k_max=4&lt;/code>，放到公式中，Fox 老师算出 &lt;code>n=2^4&lt;/code>，于是推测 Mark 老师抛了 16 个回合，但是 Fox 老师输了。&lt;/p>
&lt;p>所以这种预估方法存在较大误差，为了改善误差情况，HLL 中引入&lt;strong>分桶平均&lt;/strong>的概念。&lt;/p>
&lt;p>同样举抛硬币的例子，如果只有一组抛硬币实验，显然根据公式推导得到的实验次数的估计误差较大；如果 100 个组同时进行抛硬币实验，&lt;strong>样本数变大，受运气影响的概率就很低了&lt;/strong>，每组分别进行多次抛硬币实验，并上报各自实验过程中抛到正面的抛掷次数的最大值，就能根据 100 组的平均值预估整体的实验次数了。&lt;/p>
&lt;p>分桶平均的基本原理是&lt;strong>将统计数据划分为 &lt;code>m&lt;/code> 个桶，每个桶分别统计各自的 &lt;code>k_max&lt;/code>&lt;/strong>,​ 并能得到各自的基数预估值，最终&lt;strong>对这些基数预估值求平均&lt;/strong>得到整体的基数估计值。LLC 中使用几何平均数预估整体的基数值，但是当统计数据量较小时误差较大；HLL 在 LLC 基础上做了改进，&lt;strong>采用调和平均数&lt;/strong>过滤掉不健康的统计值。&lt;/p>
&lt;h4>调和平均数&lt;span class="hx-absolute -hx-mt-20" id="调和平均数">&lt;/span>
&lt;a href="#%e8%b0%83%e5%92%8c%e5%b9%b3%e5%9d%87%e6%95%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>举个例子：&lt;/p>
&lt;p>求平均工资：A 的是 &lt;code>1000/月&lt;/code>，B 的 &lt;code>30000/月&lt;/code>。采用平均数的方式就是：&lt;code>(1000 + 30000) / 2 = 15500&lt;/code>&lt;/p>
&lt;p>采用调和平均数的方式就是：&lt;code>2/(1/1000 + 1/30000) ≈ 1935.484&lt;/code>。&lt;/p>
&lt;p>可见&lt;strong>调和平均数比平均数的好处就是不容易受到大的数值的影响&lt;/strong>，比平均数的效果是要更好的。&lt;/p>
&lt;h3>结合实例&lt;span class="hx-absolute -hx-mt-20" id="结合实例">&lt;/span>
&lt;a href="#%e7%bb%93%e5%90%88%e5%ae%9e%e4%be%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>下面我们结合实例来理解 HyperLogLog 算法。&lt;/p>
&lt;p>统计网页每天的 UV 数据。&lt;/p>
&lt;ol>
&lt;li>转为比特串&lt;/li>
&lt;/ol>
&lt;p>通过 hash 函数，将用户 ID 转为二进制数，例如用户 ID 为 5，便转为 101。&lt;/p>
&lt;p>&lt;strong>为什么要这样转化呢？&lt;/strong>&lt;/p>
&lt;p>是因为要和抛硬币对应上，二进制数中，0 代表了反面，1 代表了正面，如果一个数据最终被转化了 &lt;code>10010000&lt;/code>，那么从右往左，从低位往高位看，我们可以认为，首次出现 1 的时候，就是正面。&lt;/p>
&lt;p>那么基于上面的估算结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样也就可以根据存入数据中，转化后的出现了 1 的最大的位置 &lt;code>k_max&lt;/code> 来估算存入了多少数据。&lt;/p>
&lt;ol start="2">
&lt;li>分桶&lt;/li>
&lt;/ol>
&lt;p>分桶就是分多少轮。就是一个长度为 &lt;code>L&lt;/code> 的 &lt;strong>bitmap&lt;/strong> &lt;code>S&lt;/code>，将 &lt;code>S&lt;/code> 平均分为 &lt;code>m&lt;/code> 组，这个 &lt;code>m&lt;/code> 组，就是对应多少轮，然后每组所占有的比特个数是平均的，设为 P。容易得出下面的关系：&lt;/p>
&lt;ul>
&lt;li>&lt;code>L = S.length&lt;/code>&lt;/li>
&lt;li>&lt;code>L = m * p&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>以 KB 为单位，&lt;code>S 占用的内存 = L / 8 / 1024&lt;/code>。&lt;/p>
&lt;ol start="3">
&lt;li>对应&lt;/li>
&lt;/ol>
&lt;p>假设访问用户 ID 为：&lt;code>idn&lt;/code>, &lt;code>n-&amp;gt;0,1,2,3....&lt;/code>&lt;/p>
&lt;p>在这个统计问题中，不同的用户 ID 标识了一个用户，那么我们可以把用户的 ID 作为被 hash 的输入。即：&lt;code>hash(id) = 二进制数&lt;/code>。&lt;/p>
&lt;p>不同的用户 ID，拥有不同的二进制数。每一个二进制数，也必然会至少出现一次 1 的位置。我们类比每一个二进制数为一次伯努利试验。&lt;/p>
&lt;p>现在要分轮，也就是分桶。所以我们可以设定，每个二进制数的前多少位转为 10 进制后，其值就对应于所在桶的标号。假设二进制数的低两位用来计算桶下标志，总共有 4 个桶，此时有一个用户的 ID 的二进制数是：&lt;code>1001011000011&lt;/code>。它的所在桶下标为：&lt;code>1*2^1 + 1*2^0 = 3&lt;/code>，处于第 3 个桶，即第 3 轮中。&lt;/p>
&lt;p>上面例子中，计算出桶号后，剩下的二进制数是：&lt;code>10010110000&lt;/code>，从右往左，从低位到高位看，第一次出现 1 的位置是 5 。也就是说，此时第 3 个桶中，&lt;code>k_max = 5&lt;/code>。5 对应的二进制是：101，将 101 存入第 3 个桶。&lt;/p>
&lt;p>模仿上面的流程，多个不同的用户 ID，就被分散到不同的桶中去了，且每个桶有其 &lt;code>k_max&lt;/code>。然后当要统计出某个页面有多少用户点击量的时候，就是一次估算。最终结合所有桶中的 &lt;code>k_max&lt;/code>，代入估算公式，便能得出估算值。&lt;/p>
&lt;h3>Redis 中的 HyperLogLog 实现&lt;span class="hx-absolute -hx-mt-20" id="redis-中的-hyperloglog-实现">&lt;/span>
&lt;a href="#redis-%e4%b8%ad%e7%9a%84-hyperloglog-%e5%ae%9e%e7%8e%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis 的实现中，&lt;strong>HyperLogLog 占据 &lt;code>12KB&lt;/code>&lt;/strong> 的大小，共设有 16384 个桶，即：&lt;code>2^14 = 16384&lt;/code>，每个桶有 6 位 (&lt;code>占用内存=16834 * 6 / 8 / 1024 = 12K&lt;/code>)，每个桶可以表达的&lt;strong>最大数字是：&lt;code>111111=63&lt;/code>&lt;/strong>。&lt;/p>
&lt;p>对于命令：&lt;code>pfadd key value&lt;/code>，它的工作原理是：&lt;/p>
&lt;p>在存入时，&lt;strong>&lt;code>value&lt;/code> 会被 hash 成 64 位的二进制数&lt;/strong>，&lt;strong>前 14 位用来分桶&lt;/strong>，剩下 50 位用来记录第一个 1 出现的位置。&lt;strong>之所以选 14 位来表达桶编号是因为分了 16384 个桶，而 &lt;code>2^14 = 16384&lt;/code>，刚好地，最大的时候可以把桶利用完&lt;/strong>，不造成浪费。假设一个字符串的前 14 位是：&lt;code>00000000000010&lt;/code> (从右往左看) ，其十进制值为 2。那么 value 对应转化后的值放到编号为 2 的桶。&lt;/p>
&lt;p>&lt;code>index&lt;/code> 的转化规则：&lt;/p>
&lt;p>首先因为完整的 value 比特字符串是 64 位形式，减去 14 后，剩下 50 位，&lt;strong>假设极端情况，出现 1 的位置，是在第 50 位，即位置是 50。此时 &lt;code>index = 50&lt;/code>。此时先将 index 转为 2 进制，它是：&lt;code>50=110010&lt;/code>&lt;/strong>，所以 6 bit 的桶足够表示。&lt;/p>
&lt;p>因为 16384 个桶中，每个桶是 6 bit 组成的。于是 &lt;code>110010&lt;/code> 就被设置到了第 2 号桶中去了。请注意，50 已经是最坏的情况，且它都被容纳进去了。那么其他的不用想也肯定能被容纳进去。&lt;/p>
&lt;p>因为 &lt;code>pfadd&lt;/code> 的 key 可以设置多个 value。例如下面的例子：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pfadd lgh golang
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pfadd lgh python
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pfadd lgh java&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>根据上面的做法，不同的 value，会被设置到不同桶中去，如果出现了在&lt;strong>同一个桶的&lt;/strong>，即前 14 位值是一样的，但是后面出现 1 的位置不一样。那么&lt;strong>比较原来的 index 是否比新 index 大。是，则替换。否，则不变&lt;/strong>。&lt;/p>
&lt;p>最终，一个 key 所对应的 16384 个桶都设置了很多的 value 了，每个桶有一个 &lt;code>k_max&lt;/code>。此时调用 &lt;code>pfcount&lt;/code> 时，按照调和平均数进行估算，同时加以偏差修正，便可以计算出 key 的设置了多少次 value，也就是统计值。&lt;/p>
&lt;p>value 被转为 64 位的比特串，最终被按照上面的做法记录到每个桶中去。64 位转为十进制就是：&lt;code>2^64&lt;/code>，HyperLogLog 仅用了：&lt;code>16384 * 6 /8 / 1024 =12K&lt;/code> 存储空间就能统计多达 &lt;code>2^64&lt;/code> 个数。&lt;/p></description></item><item><title>Redis 的过期策略和内存淘汰机制</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/10_redis_expire_strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/10_redis_expire_strategy/</guid><description>
&lt;p>Redis 是怎么删除过期的 key 的？而且 Redis 是单线程的，删除 key 过于频繁会不会造成阻塞？&lt;/p>
&lt;p>Redis 有三种清除策略&lt;/p>
&lt;ul>
&lt;li>&lt;strong>懒惰删除&lt;/strong>就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除。&lt;/li>
&lt;li>&lt;strong>定时删除&lt;/strong>是集中处理，惰性删除是零散处理。&lt;/li>
&lt;li>当前已用内存超过 maxmemory 限定时，触发主动清理策略&lt;/li>
&lt;/ul>
&lt;h2>定期删除策略&lt;span class="hx-absolute -hx-mt-20" id="定期删除策略">&lt;/span>
&lt;a href="#%e5%ae%9a%e6%9c%9f%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 会将每个&lt;strong>设置了过期时间的 key 放入到一个独立的字典&lt;/strong>中，默认每 &lt;code>100ms&lt;/code> 进行一次过期扫描：&lt;/p>
&lt;ol>
&lt;li>随机抽取 &lt;code>20&lt;/code> 个 key。&lt;/li>
&lt;li>删除这 &lt;code>20&lt;/code> 个 key 中过期的 key。&lt;/li>
&lt;li>如果过期的 key 比例超过 &lt;code>1/4&lt;/code>，就重复步骤 &lt;code>1&lt;/code>，继续删除。&lt;/li>
&lt;/ol>
&lt;p>之所以&lt;strong>不扫描所有的 key，是因为 Redis 是单线程，全部扫描会导致线程卡死&lt;/strong>。&lt;/p>
&lt;p>而且为了防止每次扫描过期的 key 比例都超过 &lt;code>1/4&lt;/code>，导致不停循环卡死线程，Redis 为每次扫描添加了&lt;strong>上限时间&lt;/strong>，默认是 &lt;code>25ms&lt;/code>。&lt;/p>
&lt;h3>如果一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果&lt;span class="hx-absolute -hx-mt-20" id="如果一个大型的-redis-实例中所有的-key-在同一时间过期了会出现怎样的结果">&lt;/span>
&lt;a href="#%e5%a6%82%e6%9e%9c%e4%b8%80%e4%b8%aa%e5%a4%a7%e5%9e%8b%e7%9a%84-redis-%e5%ae%9e%e4%be%8b%e4%b8%ad%e6%89%80%e6%9c%89%e7%9a%84-key-%e5%9c%a8%e5%90%8c%e4%b8%80%e6%97%b6%e9%97%b4%e8%bf%87%e6%9c%9f%e4%ba%86%e4%bc%9a%e5%87%ba%e7%8e%b0%e6%80%8e%e6%a0%b7%e7%9a%84%e7%bb%93%e6%9e%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>大量的 key 在同一时间过期，那么 Redis 会&lt;strong>持续扫描过期字典 (循环多次)，直到过期字典中过期的 key 变得稀疏&lt;/strong>，才会停止 (循环次数明显下降)。这会导致线上读写请求出现&lt;strong>明显的卡顿&lt;/strong>现象。导致这种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的 CPU 消耗。&lt;/p>
&lt;p>而且，如果客户端将请求超时时间设置的比较短，比如 10ms，但是请求以为过期扫描导致至少等待 25ms 后才会进行处理，那么就会出现大量的请求因为超时而关闭，业务端就会出现很多异常。这时你还&lt;strong>无法从 Redis 的 &lt;code>slowlog&lt;/code> 中看到慢查询记录，因为慢查询指的是逻辑处理过程慢，不包含等待时间&lt;/strong>。&lt;/p>
&lt;p>所以要避免大批量的 key 同时过期，可以给过期时间设置一个随机范围，分散过期处理的压力。&lt;/p>
&lt;h2>内存淘汰机制&lt;span class="hx-absolute -hx-mt-20" id="内存淘汰机制">&lt;/span>
&lt;a href="#%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)。交换会让 Redis 的性能急剧下降，对于 Redis 来说，这样龟速的存取效率基本上等于不可用。&lt;/p>
&lt;p>Redis 为了限制最大使用内存，提供了配置参数 &lt;code>maxmemory&lt;/code>，可以在 &lt;code>redis.conf&lt;/code> 中配置。当内存超出 &lt;code>maxmemory&lt;/code>，Redis 提供了几种策略（maxmemory-policy）让用户选择：&lt;/p>
&lt;ul>
&lt;li>&lt;code>noeviction&lt;/code>：当内存超出 &lt;code>maxmemory&lt;/code>，写入请求会报错，但是删除和读请求可以继续。（这个可是默认的策略）。&lt;/li>
&lt;li>&lt;code>allkeys-lru&lt;/code>：当内存超出 &lt;code>maxmemory&lt;/code>，在所有的 key 中，移除最少使用的 key。&lt;/li>
&lt;li>&lt;code>allkeys-random&lt;/code>：当内存超出 &lt;code>maxmemory&lt;/code>，在所有的 key 中，随机移除某个 key。（应该没人用吧）&lt;/li>
&lt;li>&lt;code>volatile-lru&lt;/code>：当内存超出 &lt;code>maxmemory&lt;/code>，在设置了过期时间 key 的字典中，移除最少使用的 key。&lt;/li>
&lt;li>&lt;code>volatile-random&lt;/code>：当内存超出 &lt;code>maxmemory&lt;/code>，在设置了过期时间 key 的字典中，随机移除某个key。&lt;/li>
&lt;li>&lt;code>volatile-ttl&lt;/code>：当内存超出 &lt;code>maxmemory&lt;/code>，在设置了过期时间 key 的字典中，优先移除 &lt;code>ttl&lt;/code> 小的。&lt;/li>
&lt;/ul>
&lt;h3>volatile 和 allkeys 的区别&lt;span class="hx-absolute -hx-mt-20" id="volatile-和-allkeys-的区别">&lt;/span>
&lt;a href="#volatile-%e5%92%8c-allkeys-%e7%9a%84%e5%8c%ba%e5%88%ab" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;code>volatile-xxx&lt;/code> 策略只会针对带过期时间的 key 进行淘汰。&lt;/li>
&lt;li>&lt;code>allkeys-xxx&lt;/code> 策略会对所有的 key 进行淘汰。&lt;/li>
&lt;/ul>
&lt;p>如果只是拿 Redis 做缓存，那应该使用 &lt;code>allkeys-xxx&lt;/code>，客户端写缓存时不必携带过期时间。如果还想同时使用 Redis 的持久化功能，那就使用 &lt;code>volatile-xxx&lt;/code> 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰。&lt;/p>
&lt;h3>LFU&lt;span class="hx-absolute -hx-mt-20" id="lfu">&lt;/span>
&lt;a href="#lfu" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis 4.0 里引入了一个新的淘汰策略 —— LFU（Least Frequently Used） 模式。&lt;/p>
&lt;p>LFU 表示按最近的访问频率进行淘汰，它比 LRU 更加精准地表示了一个 key 被访问的热度。&lt;/p>
&lt;p>如果一个 key 长时间不被访问，只是刚刚偶然被用户访问了一下，那么在使用 LRU 算法下它是不容易被淘汰的，因为 LRU 算法认为当前这个 key 是很热的。而 LFU 是需要追踪最近一段时间的访问频率，如果某个 key 只是偶然被访问一次是不足以变得很热的，它需要在近期一段时间内被访问很多次才有机会被认为很热。&lt;/p>
&lt;h4>启用 LFU&lt;span class="hx-absolute -hx-mt-20" id="启用-lfu">&lt;/span>
&lt;a href="#%e5%90%af%e7%94%a8-lfu" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>Redis 4.0 给淘汰策略配置参数 &lt;code>maxmemory-policy&lt;/code> 增加了 2 个选项，&lt;/p>
&lt;ul>
&lt;li>&lt;code>volatile-lfu&lt;/code>：对带过期时间的 key 执行 lfu 淘汰算法&lt;/li>
&lt;li>&lt;code>allkeys-lfu&lt;/code>：对所有的 key 执行 lfu 淘汰算法&lt;/li>
&lt;/ul>
&lt;p>使用 &lt;code>object freq&lt;/code> 指令获取对象的 lfu 计数值：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&amp;gt; config &lt;span class="nb">set&lt;/span> maxmemory-policy allkeys-lfu
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; &lt;span class="nb">set&lt;/span> codehole yeahyeahyeah
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 获取计数值，初始化为 &lt;span class="nv">LFU_INIT_VAL&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; object freq codehole
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 访问一次
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; get codehole
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;yeahyeahyeah&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 计数值增加了
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; object freq codehole
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">6&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>懒惰删除&lt;span class="hx-absolute -hx-mt-20" id="懒惰删除">&lt;/span>
&lt;a href="#%e6%87%92%e6%83%b0%e5%88%a0%e9%99%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>Redis 为什么要懒惰删除(lazy free)&lt;span class="hx-absolute -hx-mt-20" id="redis-为什么要懒惰删除lazy-free">&lt;/span>
&lt;a href="#redis-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%87%92%e6%83%b0%e5%88%a0%e9%99%a4lazy-free" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>删除指令 &lt;code>del&lt;/code> 会直接释放对象的内存，大部分情况下，这个指令非常快，没有明显延迟。不过如果删除的 key 是一个非常大的对象，比如一个包含了千万元素的 &lt;code>hash&lt;/code>，又或者在使用 &lt;code>FLUSHDB&lt;/code> 和 &lt;code>FLUSHALL&lt;/code> 删除包含大量键的数据库时，那么删除操作就会导致线程卡顿。&lt;/p>
&lt;p>redis 4.0 引入了 &lt;code>lazyfree&lt;/code> 的机制，它可以将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞。&lt;/p>
&lt;h3>unlink&lt;span class="hx-absolute -hx-mt-20" id="unlink">&lt;/span>
&lt;a href="#unlink" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>unlink&lt;/code> 指令，它能对删除操作进行懒处理，丢给后台线程来异步回收内存。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&amp;gt; unlink key
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>flush&lt;span class="hx-absolute -hx-mt-20" id="flush">&lt;/span>
&lt;a href="#flush" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>flushdb&lt;/code> 和 &lt;code>flushall&lt;/code> 指令，用来清空数据库，这也是极其缓慢的操作。Redis 4.0 同样给这两个指令也带来了异步化，在指令后面增加 &lt;code>async&lt;/code> 参数就可以扔给后台线程慢慢处理。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&amp;gt; flushall async
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>管道</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/11_pipeline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/11_pipeline/</guid><description>
&lt;p>Redis 管道 (Pipeline) 这个技术本质上是由&lt;strong>客户端&lt;/strong>提供的，跟服务器没有什么直接的关系。&lt;/p>
&lt;h2>Redis 的消息交互&lt;span class="hx-absolute -hx-mt-20" id="redis-的消息交互">&lt;/span>
&lt;a href="#redis-%e7%9a%84%e6%b6%88%e6%81%af%e4%ba%a4%e4%ba%92" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>当使用客户端对 Redis 进行一次操作时，客户端将请求传送给服务器，服务器处理完毕后，再将响应回复给客户端。这要花费一个网络数据包来回的时间。&lt;/p>
&lt;p>如果连续执行多条指令，那就会花费多个网络数据包来回的时间。&lt;/p>
&lt;p>管道操作的本质，服务器根本没有任何区别对待，还是收到一条消息，执行一条消息，回复一条消息的正常的流程。客户端通过对管道中的指令列表改变读写顺序，合并 write 和 read 操作，就可以大幅节省 IO 时间。&lt;/p>
&lt;p>打包的命令越多，缓存消耗内存也越多。所以并不是打包的命令越多越好。&lt;/p>
&lt;p>&lt;code>pipeline&lt;/code> 中发送的每个 &lt;code>command&lt;/code> 都会被 server立即执行，如果执行失败，将会在此后的响应中得到信息；也就是 &lt;code>pipeline&lt;/code> 并不是表达“所有 command 都一起成功”的语义，&lt;strong>管道中前面命令失败，后面命令不会有影响&lt;/strong>，继续执行。也就是说&lt;strong>管道不具备原子性&lt;/strong>。&lt;/p>
&lt;h2>管道压力测试&lt;span class="hx-absolute -hx-mt-20" id="管道压力测试">&lt;/span>
&lt;a href="#%e7%ae%a1%e9%81%93%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 自带了一个压力测试工具 &lt;code>redis-benchmark&lt;/code>，使用这个工具就可以进行管道测试。&lt;/p>
&lt;p>首先我们对一个普通的 set 指令进行压测，QPS 大约 5w/s。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&amp;gt; redis-benchmark -t &lt;span class="nb">set&lt;/span> -q
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET: 51975.05 requests per second&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>加入管道选项 &lt;code>-P&lt;/code> 参数，它表示单个管道内并行的请求数量，看下面 &lt;code>P=2&lt;/code>，QPS 达到了 9w/s。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&amp;gt; redis-benchmark -t &lt;span class="nb">set&lt;/span> -P &lt;span class="m">2&lt;/span> -q
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET: 91240.88 requests per second&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>再看看 &lt;code>P=3&lt;/code>，QPS 达到了 10w/s。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&amp;gt; redis-benchmark -t &lt;span class="nb">set&lt;/span> -P &lt;span class="m">3&lt;/span> -q
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET: 102354.15 requests per second&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>但如果再继续提升 P 参数，发现 QPS 已经上不去了。因为这里 CPU 处理能力已经达到了瓶颈，无法再继续提升了。&lt;/p></description></item><item><title>Redis 线程模型</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/12_io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/12_io/</guid><description>
&lt;p>Redis 为什么快？&lt;/p>
&lt;ul>
&lt;li>单线程&lt;/li>
&lt;li>基于内存的操作&lt;/li>
&lt;li>高效的 IO 模型，非阻塞 IO&lt;/li>
&lt;li>RESP 协议简单高效&lt;/li>
&lt;/ul>
&lt;h2>Reacrtor 模型&lt;span class="hx-absolute -hx-mt-20" id="reacrtor-模型">&lt;/span>
&lt;a href="#reacrtor-%e6%a8%a1%e5%9e%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Reactor 反应器模型是一种事件驱动的编程模型，用于处理网络事件。&lt;/p>
&lt;p>具体事件处理程序不调用反应器，而向反应器&lt;strong>注册一个事件处理器&lt;/strong>，表示自己对某些事件感兴趣，有使件来了，具体事件处理程序通过事件处理器对某个指定的事件发生做出反应。&lt;/p>
&lt;p>例如，路人甲去做男士 SPA，前台的接待小姐接待了路人甲，路人甲现在只对 10000 技师感兴趣，但是路人甲去的比较早，就告诉接待小姐，等 10000 技师上班了或者是空闲了，通知我。等路人甲接到接待小姐通知，做出了反应，把 10000 技师占住了。然后，路人甲想起上一次的那个 10000 号房间不错，设备舒适，灯光暧昧，又告诉前台的接待小姐，我对 10000 号房间很感兴趣，房间空出来了就告诉我，我现在先和 10000 这个小姐聊下人生，10000 号房间空出来了，路人甲再次接到接待小姐通知，路人甲再次做出了反应。路人甲就是具体事件处理程序，前台的接待小姐就是所谓的&lt;strong>反应器&lt;/strong>，“10000技师上班了”和“10000号房间空闲了”就是&lt;strong>事件&lt;/strong>，路人甲只对这两个事件感兴趣，其他，比如 10001 号技师或者 10002 号房间空闲了也是事件，但是路人甲不感兴趣。&lt;/p>
&lt;p>前台的接待小姐不仅仅服务路人甲 1 人，他还可以同时服务路人乙、丙……..，每个人所感兴趣的事件是不一样的，前台的接待小姐会根据每个人感兴趣的事件通知对应的每个人。&lt;/p>
&lt;h3>单线程 Reactor 模式&lt;span class="hx-absolute -hx-mt-20" id="单线程-reactor-模式">&lt;/span>
&lt;a href="#%e5%8d%95%e7%ba%bf%e7%a8%8b-reactor-%e6%a8%a1%e5%bc%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>服务器端的 Reactor 是一个线程对象，该线程会启动事件循环，并使用 Acceptor 事件处理器关注 &lt;code>ACCEPT&lt;/code> 事件，这样 Reactor 会监听客户端向服务器端发起的连接请求事件 (&lt;code>ACCEPT&lt;/code> 事件)。&lt;/p>
&lt;ol>
&lt;li>客户端向服务器端发起一个连接请求，Reactor 监听到了该 &lt;code>ACCEPT&lt;/code> 事件的发生并将该 &lt;code>ACCEPT&lt;/code> 事件派发给相应的 Acceptor 处理器来进行处理。&lt;/li>
&lt;li>建立连接后关注 &lt;code>READ&lt;/code> 事件，这样一来 &lt;code>Reactor&lt;/code> 就会监听该连接的 &lt;code>READ&lt;/code> 事件了。&lt;/li>
&lt;li>当 Reactor 监听到有读 &lt;code>READ&lt;/code> 事件发生时，将相关的事件派发给对应的处理器进行处理。比如，读处理器会通过读取数据，此时 &lt;code>read()&lt;/code> 操作可以直接读取到数据，而不会堵塞与等待可读的数据到来。&lt;/li>
&lt;/ol>
&lt;p>在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor 线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O 请求的响应。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/single-thread.png" alt="single-thread" loading="lazy" />&lt;/p>
&lt;h3>单线程 Reactor，工作者线程池&lt;span class="hx-absolute -hx-mt-20" id="单线程-reactor工作者线程池">&lt;/span>
&lt;a href="#%e5%8d%95%e7%ba%bf%e7%a8%8b-reactor%e5%b7%a5%e4%bd%9c%e8%80%85%e7%ba%bf%e7%a8%8b%e6%b1%a0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>与单线程 Reactor 模式不同的是，添加了一个工作者线程池，并将&lt;strong>非 I/O 操作从 Reactor 线程中移出转交给工作者线程池&lt;/strong>来执行。这样能够提高 Reactor 线程的 I/O 响应，不至于因为一些耗时的业务逻辑而延迟对后面 I/O 请求的处理。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/thread-pool.png" alt="thread-pool" loading="lazy" />&lt;/p>
&lt;p>对于一些小容量应用场景，可以使用单线程模型，对于高负载、大并发或大数据量的应用场景却不合适，主要原因如下：&lt;/p>
&lt;ol>
&lt;li>一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，即便 NIO 线程的 CPU 负荷达到 100%，也无法满足海量消息的读取和发送；&lt;/li>
&lt;li>当 NIO 线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了 NIO 线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；&lt;/li>
&lt;/ol>
&lt;h3>多线程 Reactor 模式&lt;span class="hx-absolute -hx-mt-20" id="多线程-reactor-模式">&lt;/span>
&lt;a href="#%e5%a4%9a%e7%ba%bf%e7%a8%8b-reactor-%e6%a8%a1%e5%bc%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Reactor 线程池中的每一个 Reactor 线程都会有自己的 Selector、线程和分发的事件循环逻辑。&lt;/p>
&lt;p>MainReactor 可以只有一个，但 SubReactor 一般会有多个。&lt;strong>Main Reactor 线程主要负责接收客户端的连接请求&lt;/strong>，然后将接收到的 SocketChannel 传递给 SubReactor，由 &lt;strong>SubReactor 来完成和客户端的通信&lt;/strong>。&lt;/p>
&lt;p>多 Reactor 线程模式将“接受客户端的连接请求”和“与该客户端的通信”分在了两个 Reactor 线程来完成。MainReactor 完成接收客户端连接请求的操作，它不负责与客户端的通信，而是将建立好的连接转交给 SubReactor 线程来完成与客户端的通信，这样一来就不会因为 &lt;code>read()&lt;/code> 数据量太大而导致后面的客户端连接请求得不到即时处理的情况。并且多 Reactor 线程模式在海量的客户端并发请求的情况下，还可以通过实现 SubReactor 线程池来将海量的连接分发给多个 SubReactor 线程，在多核的操作系统中这能大大提升应用的负载和吞吐量。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/multi-reactors.png" alt="multi-reactors" loading="lazy" />&lt;/p>
&lt;h2>Redis 的线程和 IO 概述&lt;span class="hx-absolute -hx-mt-20" id="redis-的线程和-io-概述">&lt;/span>
&lt;a href="#redis-%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%92%8c-io-%e6%a6%82%e8%bf%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 基于 Reactor 模式开发了自己的网络事件处理器 - 文件事件处理器（file event handler，后文简称为 FEH），而该处理器又是单线程的，所以 Redis 设计为单线程模型。&lt;/p>
&lt;p>采用 I/O 多路复用同时监听多个 socket，根据 socket 当前执行的事件来为 socket 选择对应的事件处理器。&lt;/p>
&lt;p>当被监听的 socket 准备好执行 &lt;code>accept&lt;/code>、&lt;code>read&lt;/code>、&lt;code>write&lt;/code>、&lt;code>close&lt;/code> 等操作时，和操作对应的文件事件就会产生，这时 FEH 就会调用 socket 之前关联好的事件处理器来处理对应事件。&lt;/p>
&lt;p>所以虽然 FEH 是单线程运行，但通过 I/O 多路复用监听多个 socket，不仅实现高性能的网络通信模型，又能和 Redis 服务器中其它同样单线程运行的模块交互，保证了 Redis 内部单线程模型的简洁设计。&lt;/p>
&lt;h2>Redis 6 中的多线程&lt;span class="hx-absolute -hx-mt-20" id="redis-6-中的多线程">&lt;/span>
&lt;a href="#redis-6-%e4%b8%ad%e7%9a%84%e5%a4%9a%e7%ba%bf%e7%a8%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>Redis 6 之前的版本真的是单线程么？&lt;span class="hx-absolute -hx-mt-20" id="redis-6-之前的版本真的是单线程么">&lt;/span>
&lt;a href="#redis-6-%e4%b9%8b%e5%89%8d%e7%9a%84%e7%89%88%e6%9c%ac%e7%9c%9f%e7%9a%84%e6%98%af%e5%8d%95%e7%ba%bf%e7%a8%8b%e4%b9%88" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis 在处理客户端的请求时，所有操作（网络 I/O、命令解析、执行、响应）均由单个主线程顺序处理，这就是所谓的 “&lt;strong>单线程&lt;/strong>”。通过 epoll/kqueue 等系统调用实现非阻塞 I/O，监听多个客户端连接。&lt;/p>
&lt;p>但如果严格来讲从 &lt;strong>Redis 4 之后并不是单线程&lt;/strong>，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等。&lt;/p>
&lt;h3>Redis 单线程为什么还能这么快？&lt;span class="hx-absolute -hx-mt-20" id="redis-单线程为什么还能这么快">&lt;/span>
&lt;a href="#redis-%e5%8d%95%e7%ba%bf%e7%a8%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%98%e8%83%bd%e8%bf%99%e4%b9%88%e5%bf%ab" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>因为它所有的数据都在内存中，所有的运算都是&lt;strong>内存级别的运算&lt;/strong>，而且&lt;strong>单线程避免了多线程的切换性能损耗&lt;/strong>问题。正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如 keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。&lt;/p>
&lt;h3>Redis 6 之前为什么一直不使用多线程？&lt;span class="hx-absolute -hx-mt-20" id="redis-6-之前为什么一直不使用多线程">&lt;/span>
&lt;a href="#redis-6-%e4%b9%8b%e5%89%8d%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%80%e7%9b%b4%e4%b8%8d%e4%bd%bf%e7%94%a8%e5%a4%9a%e7%ba%bf%e7%a8%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>官方曾做过类似问题的回复：使用 Redis 时，&lt;strong>几乎不存在 CPU 成为瓶颈的情况&lt;/strong>，&lt;strong>Redis 主要受限于内存和网络&lt;/strong>。例如在一个普通的 Linux 系统上，Redis 通过使用 pipeline 每秒可以处理 100 万个请求，所以如果应用程序主要使用 &lt;code>O(N)&lt;/code> 或 &lt;code>O(log(N))&lt;/code> 的命令，它几乎不会占用太多 CPU。&lt;/p>
&lt;p>&lt;strong>多线程模型虽然在某些方面表现优异&lt;/strong>，但是它却&lt;strong>引入了程序执行顺序的不确定性&lt;/strong>，带来了&lt;strong>并发读写&lt;/strong>的一系列问题，增加了系统复杂度、同时可能存在&lt;strong>线程上下文切换&lt;/strong>、甚至&lt;strong>加锁解锁、死锁造成的性能损耗&lt;/strong>。Redis 通过 AE 事件模型以及 IO 多路复用等技术，处理性能非常高，因此没有必要使用多线程。&lt;/p>
&lt;p>&lt;strong>单线程&lt;/strong>机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。&lt;/p>
&lt;h3>Redis 6 为什么要引入多线程？&lt;span class="hx-absolute -hx-mt-20" id="redis-6-为什么要引入多线程">&lt;/span>
&lt;a href="#redis-6-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%bc%95%e5%85%a5%e5%a4%9a%e7%ba%bf%e7%a8%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis 将所有数据放在内存中，内存的响应时长大约为 100 纳秒，对于小数据包，Redis 服务器可以处理 80,000 到 100,000 QPS，这也是 Redis 处理的极限了，对于 80% 的公司来说，单线程的 Redis 已经足够使用了。&lt;/p>
&lt;p>但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的 QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如：&lt;/p>
&lt;ol>
&lt;li>要管理的 Redis 服务器太多，维护代价大；&lt;/li>
&lt;li>某些适用于单个 Redis 服务器的&lt;strong>命令（&lt;code>mset&lt;/code>）不适用于数据分区&lt;/strong>；&lt;/li>
&lt;li>数据分区无法解决热点读/写问题，例如：虽然使用了集群，但是只是将不同的数据分散在不同的节点上，但是&lt;strong>如果某个 key 被频繁访问，这个 key 还是会被分配到同一个节点上，这样访问压力还是会集中在一个节点上&lt;/strong>。&lt;/li>
&lt;li>数据偏斜，重新分配和放大/缩小变得更加复杂等等。Redis 集群虽然尽量平均分配槽位，但是&lt;strong>每个 key 对应的 value 的数据大小不同&lt;/strong>。例如：一个 key 的值是 10 KB，而另一个 key 的值是 1MB，这就会导致&lt;strong>数据倾斜&lt;/strong>，导致部分节点的内存占用率很高，而其他节点的内存占用率很低。&lt;/li>
&lt;/ol>
&lt;p>从 Redis 自身角度来说，因为读写网络的 &lt;code>read/write&lt;/code> 系统调用占用了 Redis 执行期间大部分 CPU 时间，&lt;strong>瓶颈主要在于网络的 IO 消耗&lt;/strong>, 优化主要有两个方向:&lt;/p>
&lt;ol>
&lt;li>提高网络 IO 性能，典型的实现比如使用 DPDK（跳过操作系统的网络栈，直接处理网卡的内容）来替代内核网络栈的方式。&lt;/li>
&lt;li>使用多线程充分利用多核，典型的实现比如 Memcached。&lt;/li>
&lt;/ol>
&lt;p>DPDK 协议栈优化的这种方式相当复杂，Redis 没有选择，很明显支持多线程是一种最有效最便捷的操作方式。所以总结起来，Redis 支持多线程主要就是两个原因：&lt;/p>
&lt;ol>
&lt;li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核。&lt;/li>
&lt;li>多线程任务可以分摊 Redis 同步 IO 读写负荷。&lt;/li>
&lt;/ol>
&lt;h3>Redis 6 是否默认开启了多线程？&lt;span class="hx-absolute -hx-mt-20" id="redis-6-是否默认开启了多线程">&lt;/span>
&lt;a href="#redis-6-%e6%98%af%e5%90%a6%e9%bb%98%e8%ae%a4%e5%bc%80%e5%90%af%e4%ba%86%e5%a4%9a%e7%ba%bf%e7%a8%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>没有，默认是单线程，但是可以通过配置文件开启多线程。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 开启多线程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">io-threads-do-reads yes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 线程数量，必须设置线程数，否则是不生效的。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">io-threads 4&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>关于线程数的设置，官方有一个建议：4 核的机器建议设置为 2 或 3 个线程，8 核的建议设置为 6 个线程，&lt;strong>线程数一定要小于机器核数&lt;/strong>。还需要注意的是，线程数并不是越大越好，官方认为超过了 8 个基本就没什么意义。&lt;/p>
&lt;h3>Redis 6 多线程的实现机制&lt;span class="hx-absolute -hx-mt-20" id="redis-6-多线程的实现机制">&lt;/span>
&lt;a href="#redis-6-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%9c%ba%e5%88%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>多线程网络 I/O：主线程负责接收连接，将就绪的 socket 分发给多个 I/O 线程（配置项 io-threads 控制线程数）。&lt;/li>
&lt;li>单线程命令执行：命令解析、执行、响应构建仍由主线程处理，保持原子性。&lt;/li>
&lt;/ul>
&lt;p>流程简述如下：&lt;/p>
&lt;ol>
&lt;li>主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列。&lt;/li>
&lt;li>主线程处理完读事件之后，通过 RR (Round Robin) 将这些连接分配给这些 IO 线程。&lt;/li>
&lt;li>主线程阻塞等待 IO 线程读取 socket 完毕。&lt;/li>
&lt;li>主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行回写 socket。&lt;/li>
&lt;li>主线程阻塞等待 IO 线程将数据回写 socket 完毕。&lt;/li>
&lt;li>解除绑定，清空等待队列。&lt;/li>
&lt;/ol>
&lt;p>该设计有如下特点：&lt;/p>
&lt;ol>
&lt;li>IO 线程要么同时在读 socket，要么同时在写，不会同时读或写。&lt;/li>
&lt;li>&lt;strong>IO 线程只负责读写 socket 解析命令，不负责命令处理&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>可以看出 Redis 6 的多线程类似于&lt;strong>多线程 Reactor 模式&lt;/strong>，不过它的 &lt;strong>Sub Reactor 只负责读写 socket，不负责命令处理&lt;/strong>。&lt;/p>
&lt;h3>开启多线程后，是否会存在线程并发安全问题？&lt;span class="hx-absolute -hx-mt-20" id="开启多线程后是否会存在线程并发安全问题">&lt;/span>
&lt;a href="#%e5%bc%80%e5%90%af%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%90%8e%e6%98%af%e5%90%a6%e4%bc%9a%e5%ad%98%e5%9c%a8%e7%ba%bf%e7%a8%8b%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e9%97%ae%e9%a2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>从上面的实现机制可以看出，Redis 的&lt;strong>多线程部分只是用来处理网络数据的读写和协议解析&lt;/strong>，&lt;strong>执行命令仍然是单线程顺序执行&lt;/strong>。所以不需要去考虑控制 key、lua、事务，&lt;code>LPUSH/LPOP&lt;/code> 等等的并发及线程安全问题。&lt;/p>
&lt;h3>Redis 6 的多线程和 Memcached 多线程模型进行对比&lt;span class="hx-absolute -hx-mt-20" id="redis-6-的多线程和-memcached-多线程模型进行对比">&lt;/span>
&lt;a href="#redis-6-%e7%9a%84%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%92%8c-memcached-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e8%bf%9b%e8%a1%8c%e5%af%b9%e6%af%94" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Memcached 主线程负责接收建立连接请求，然后 socket 的读写，命令的执行，都交给子线程去处理。&lt;/p>
&lt;p>Redis 主线程负责接收建立连接请求，然后 socket 的读写，交给子线程去处理。但是命令的执行还是由主线程来执行的。&lt;/p></description></item><item><title>事务</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/13_transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/13_transaction/</guid><description>
&lt;p>事务表示一组动作，要么全部执行，要么全部不执行。&lt;/p>
&lt;h2>Redis 事务&lt;span class="hx-absolute -hx-mt-20" id="redis-事务">&lt;/span>
&lt;a href="#redis-%e4%ba%8b%e5%8a%a1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 提供了简单的事务功能，将一组需要一起执行的命令放到 &lt;code>multi&lt;/code> 和 &lt;code>exec&lt;/code> 两个命令之间。&lt;/p>
&lt;p>&lt;code>multi&lt;/code> 命令代表事务开始，&lt;code>exec&lt;/code> 命令代表事务结束，如果要停止事务的执行，可以使用 &lt;code>discard&lt;/code> 命令代替 &lt;code>exec&lt;/code> 命令即可。它们之间的命令是原子顺序执行的，例如：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; multi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; sadd u:a:follow ub
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUEUED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; sadd u:b:fans ua
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUEUED&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>命令返回的是 &lt;code>QUEUED&lt;/code>，代表命令并&lt;strong>没有真正执行，而是暂时保存在 Redis 中的一个缓存队列&lt;/strong>（所以 &lt;strong>&lt;code>discard&lt;/code> 也只是丢弃这个缓存队列中的未执行命令&lt;/strong>，并&lt;strong>不会回滚已经操作过的数据&lt;/strong>，这一点要和关系型数据库的 rollback 操作区分开）。&lt;/p>
&lt;p>如果此时另一个客户端执行 &lt;code>sismember u:a:follow ub&lt;/code> 返回结果应该为 0，因为上面的命令还没有执行。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; sismember u:a:follow ub
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>只有当执行 &lt;code>exec&lt;/code> 命令后，会将缓存队列中的命令按照顺序执行，并返回执行结果。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">exec&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>另一个客户端：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; sismember u:a:follow ub
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>如果事务中的命令出现错误,Redis 的处理机制也不尽相同。如果是 MySQL 数据库，事务中的错误会导致整个事务的执行失败，并且会回滚到事务开始之前的状态。&lt;/p>
&lt;p>而 Redis 中，事务中的错误分为两种情况：&lt;/p>
&lt;ol>
&lt;li>命令错误&lt;/li>
&lt;/ol>
&lt;p>例如下面操作错将 &lt;code>set&lt;/code> 写成了 &lt;code>sett&lt;/code>，属于语法错误，会造成整个事务无法执行，key 和counter 的值未发生变化：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">set&lt;/span> txkey hello
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">set&lt;/span> txcount &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; mget txkey txcount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;100&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; multi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">set&lt;/span> k v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUEUED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; sett txkey world
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>error&lt;span class="o">)&lt;/span> ERR unknown &lt;span class="nb">command&lt;/span> &lt;span class="sb">`&lt;/span>sett&lt;span class="sb">`&lt;/span>, with args beginning with: &lt;span class="sb">`&lt;/span>txkey&lt;span class="sb">`&lt;/span>, &lt;span class="sb">`&lt;/span>world&lt;span class="sb">`&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; incr txcount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUEUED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">exec&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>error&lt;span class="o">)&lt;/span> EXECABORT Transaction discarded because of previous errors.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; mget txkey txcount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;100&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>可以看出，对于&lt;strong>命令错误，Redis 会将整个事务的放弃，不执行任何命令&lt;/strong>，并且返回错误信息。&lt;/p>
&lt;ol start="2">
&lt;li>运行时错误&lt;/li>
&lt;/ol>
&lt;p>例如用户 B 在添加粉丝列表时，误把 &lt;code>sadd&lt;/code> 命令 (针对集合) 写成了 &lt;code>zadd&lt;/code> 命令 (针对有序集合)，这种就是运行时命令，因为语法是正确的：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; multi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; sadd u:a:follow ub
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUEUED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; zadd u:b:fans &lt;span class="m">1&lt;/span> uc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUEUED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">exec&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>error&lt;span class="o">)&lt;/span> WRONGTYPE Operation against a key holding the wrong kind of value
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; sismember u:c:follow ub
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>u:b:fans&lt;/code> 在前面已经是一个集合了，但是 &lt;code>zadd&lt;/code> 是操作有序集合的命令，虽然命令没有错，但是运行时会出现错误。&lt;/p>
&lt;p>可以看出，命令没有错，在运行时才出现的错误，Redis 会&lt;strong>将其他命令正常执行&lt;/strong>，并没有全部回滚。如果碰到这种问题，需要开发人员根据具体情况进行处理。&lt;/p>
&lt;h3>watch 命令&lt;span class="hx-absolute -hx-mt-20" id="watch-命令">&lt;/span>
&lt;a href="#watch-%e5%91%bd%e4%bb%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>有些应用场景需要在事务之前，确保事务中的 key 没有被其他客户端修改过，才执行事务，否则不执行 (类似乐观锁)。&lt;/p>
&lt;p>可以使用 &lt;code>watch&lt;/code> 命令来实现，例如：&lt;/p>
&lt;p>客户端 1：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">set&lt;/span> testwatch java
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; watch testwatch
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; multi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>客户端 2：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; append testwatch python
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">10&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>客户端 1：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">redis&amp;gt; append testwatch jedis
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUEUED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; &lt;span class="nb">exec&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>nil&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis&amp;gt; get testwatch
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;javapython&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>可以看到“客户端-1”在执行 &lt;code>multi&lt;/code> 之前执行了 &lt;code>watch&lt;/code> 命令，“客户端-2”在“客户端-1”执行 &lt;code>exec&lt;/code> 之前修改了 key 值，造成“客户端-1”事务没有执行 ( &lt;code>exec&lt;/code> 结果为 &lt;code>nil&lt;/code>，就是因为 &lt;code>watch&lt;/code> 命令观察到 key 值被修改了，导致事务没有执行)。&lt;/p>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">Redis 禁止在 &lt;code>multi&lt;/code> 和 &lt;code>exec&lt;/code> 之间执行 &lt;code>watch&lt;/code> 指令，而必须在 &lt;code>multi&lt;/code> 之前做好盯住关键变量，否则会出错。&lt;/div>
&lt;/div>
&lt;/div>
&lt;h2>Pipeline 和事务的区别&lt;span class="hx-absolute -hx-mt-20" id="pipeline-和事务的区别">&lt;/span>
&lt;a href="#pipeline-%e5%92%8c%e4%ba%8b%e5%8a%a1%e7%9a%84%e5%8c%ba%e5%88%ab" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>pipeline 是客户端的行为，对于服务器来说无法区分客户端发送来的查询命令是以普通命令的形式还是以 pipeline 的形式发送到服务器的。&lt;/li>
&lt;li>事务则是实现在服务器端的行为，用户执行 &lt;code>MULTI&lt;/code> 命令时，服务器会将对应这个用户的客户端对象设置为一个特殊的状态，在这个状态下后续用户执行的查询命令不会被真的执行，而是被服务器缓存起来，直到用户执行 &lt;code>EXEC&lt;/code> 命令为止，服务器会将这个用户对应的客户端对象中缓存的命令按照提交的顺序依次执行。&lt;/li>
&lt;li>应用 pipeline 可以提服务器的吞吐能力，并提高 Redis 处理查询请求的能力。但是无法保证原子性。&lt;/li>
&lt;/ol>
&lt;h2>优化&lt;span class="hx-absolute -hx-mt-20" id="优化">&lt;/span>
&lt;a href="#%e4%bc%98%e5%8c%96" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>可以&lt;strong>将事务和 pipeline 结合起来&lt;/strong>使用，&lt;strong>减少事务的命令在网络上的传输时间&lt;/strong>，将多次网络 IO 缩减为一次网络 IO。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">pipe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">redis&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pipeline&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">transaction&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">pipe&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">multi&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">pipe&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">incr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;books&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">pipe&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">incr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;books&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">values&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pipe&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">execute&lt;/span>&lt;span class="p">()&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>总结&lt;span class="hx-absolute -hx-mt-20" id="总结">&lt;/span>
&lt;a href="#%e6%80%bb%e7%bb%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 的事务过于简单，可以使用 Lua 脚本实现复杂的事务。&lt;/p></description></item><item><title>Stream</title><link>https://shipengqi.github.io/db-learn/docs/redis/advance/14_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/advance/14_stream/</guid><description>
&lt;p>Redis 5.0 最大的新特性就是多出了一个数据结构 Stream，它是一个新的强大的支持多播的可持久化的消息队列（MQ），借鉴了 Kafka 的设计。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-stream.png" alt="redis-stream" loading="lazy" />&lt;/p>
&lt;p>Redis Stream 的结构如上图所示：&lt;/p>
&lt;ul>
&lt;li>每一个 Stream 都有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。消息是&lt;strong>持久化&lt;/strong>的，Redis 重启后，内容还在。&lt;/li>
&lt;li>每个 Stream 都有唯一的名称，它就是 Redis 的 key，首次使用 &lt;strong>&lt;code>xadd&lt;/code> 指令追加消息时自动创建&lt;/strong>。&lt;/li>
&lt;li>每个 Stream 都可以挂&lt;strong>多个消费组&lt;/strong>，每个消费组会有个游标 &lt;code>last_delivered_id&lt;/code> 在 Stream 数组之上往前移动，表示当前消费组已经消费到哪条消息了。每个消费组都有一个 Stream 内唯一的名称，&lt;strong>消费组不会自动创建&lt;/strong>，它需要单独的指令 &lt;code>xgroup create&lt;/code> 进行创建，需要指定从 Stream 的某个消息 ID 开始消费，这个 ID 用来初始化 &lt;code>last_delivered_id&lt;/code> 变量。&lt;/li>
&lt;li>每个消费组 (Consumer Group) 的状态都是&lt;strong>独立&lt;/strong>的，相互不受影响。也就是说&lt;strong>同一份 Stream 内部的消息，可以被不同消费组消费&lt;/strong>。&lt;/li>
&lt;li>同一个消费组 (Consumer Group) 可以挂接&lt;strong>多个消费者&lt;/strong> (Consumer)，这些消费者之间是&lt;strong>竞争关系&lt;/strong>，任意一个消费者读取了消息都会使游标 &lt;code>last_delivered_id&lt;/code> 往前移动。每个消费者有一个组内唯一名称。也就是说&lt;strong>一份消息只会被组内的一个消费者消费&lt;/strong>。&lt;/li>
&lt;li>消费者 (Consumer) 内部会有个状态变量 &lt;strong>&lt;code>pending_ids&lt;/code>，它记录了当前已经被客户端读取,但是还没有 ack 的消息&lt;/strong>。如果客户端没有 ack，这个变量里面的消息 ID 会越来越多，一旦某个消息被 ack，它就开始减少。这个 &lt;code>pending_ids&lt;/code> 变量在 Redis 官方被称之为 &lt;strong>PEL（Pending Entries List）&lt;/strong>，这是一个很核心的数据结构，它用来&lt;strong>确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理&lt;/strong>。&lt;/li>
&lt;li>消息 ID 的形式是 &lt;strong>&lt;code>timestampInMillis-sequence&lt;/code>&lt;/strong>，例如 &lt;code>1527846880572-5&lt;/code>，它表示当前的消息在毫米时间戳 &lt;code>1527846880572&lt;/code> 时产生，并且是该毫秒内产生的第 5 条消息。消息 ID 可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是 &lt;code>整数-整数&lt;/code>，而且必须是后面加入的消息的 ID 要大于前面的消息 ID。&lt;/li>
&lt;li>消息内容就是键值对，形如 hash 结构的键值对，这没什么特别之处。&lt;/li>
&lt;/ul>
&lt;h2>常用命令&lt;span class="hx-absolute -hx-mt-20" id="常用命令">&lt;/span>
&lt;a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>生产端&lt;span class="hx-absolute -hx-mt-20" id="生产端">&lt;/span>
&lt;a href="#%e7%94%9f%e4%ba%a7%e7%ab%af" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;code>xadd&lt;/code>：追加消息。&lt;/li>
&lt;li>&lt;code>xdel&lt;/code>：删除消息，这里的删除&lt;strong>仅仅是设置了标志位，不会实际删除消息&lt;/strong>。&lt;/li>
&lt;li>&lt;code>xrange&lt;/code>：获取消息列表，会&lt;strong>自动过滤已经删除的消息&lt;/strong>。&lt;/li>
&lt;li>&lt;code>xlen&lt;/code>：消息长度。&lt;/li>
&lt;li>&lt;code>del&lt;/code>：删除 Stream。&lt;/li>
&lt;/ul>
&lt;p>示例：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xadd streamtest * name mark age &lt;span class="m">18&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;1626705954593-0&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>streamtest&lt;/code> 表示当前这个队列的名字，也就是 Redis 中的 &lt;code>key&lt;/code>。&lt;/li>
&lt;li>&lt;strong>&lt;code>*&lt;/code> 号表示服务器自动生成 ID&lt;/strong>，&lt;/li>
&lt;li>&lt;code>name mark age 18&lt;/code>，是存入当前 &lt;code>streamtest&lt;/code> 这个队列的消息，采用的也是 &lt;code>key/value&lt;/code> 的存储形式。&lt;/li>
&lt;li>返回值 &lt;code>1626705954593-0&lt;/code> 则是生成的消息 ID，由两部分组成：&lt;code>时间戳-序号&lt;/code>。时间戳时毫秒级单位，是生成消息的 Redis 服务器时间，它是个 64 位整型。序号是在这个毫秒时间点内的消息序号。它也是个 64 位整型。&lt;/li>
&lt;/ul>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">为了保证消息是有序的，Redis 生成的 ID 是单调递增有序的。由于 ID 中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis 的&lt;strong>每个 Stream 类型数据都维护一个 &lt;code>latest_generated_id&lt;/code> 属性，用于记录最后一个消息的 ID&lt;/strong>。若发现当前时间戳退后（小于 &lt;code>latest_generated_id&lt;/code> 所记录的），则采用时间戳不变而序号递增的方案来作为新消息 ID（这也是序号为什么使用 int64 的原因，保证有足够多的的序号），从而保证 ID 的单调递增性质。&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>如果不是非常特别的需求，强烈建议使用 Redis 的方案生成消息 ID，因为这种 &lt;code>时间戳+序号&lt;/code> 的单调递增的 ID 方案，几乎可以满足全部的需求，但 ID 是支持自定义的。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xadd streamtest * name james age &lt;span class="m">20&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;1626706380924-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xadd streamtest * name pooky age &lt;span class="m">33&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;1626706393957-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xlen streamtest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xrange streamtest - +
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626705954593-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;mark&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;18&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706380924-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;james&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;20&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706393957-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pooky&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;33&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>xrange streamtest - +&lt;/code> 中的 &lt;code>-&lt;/code> 表示从消息 ID 最小的开始，&lt;code>+&lt;/code> 表示到消息 ID 最大的结束。&lt;/p>
&lt;p>也可以&lt;strong>指定消息 ID 范围&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xrange streamtest 1626706380924-0 1626706393957-0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706380924-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;james&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;20&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706393957-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pooky&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;33&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xrange streamtest - 1626706380924-0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626705954593-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;mark&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;18&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706380924-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;james&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;20&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xrange streamtest 1626706380924-0 +
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706380924-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;james&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;20&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706393957-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pooky&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;33&amp;#34;&lt;/span> &lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>删除指定的消息&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xdel streamtest 1626706380924-0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>消费端&lt;span class="hx-absolute -hx-mt-20" id="消费端">&lt;/span>
&lt;a href="#%e6%b6%88%e8%b4%b9%e7%ab%af" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>单消费者&lt;span class="hx-absolute -hx-mt-20" id="单消费者">&lt;/span>
&lt;a href="#%e5%8d%95%e6%b6%88%e8%b4%b9%e8%80%85" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>虽然 Stream 中有消费者组的概念，但是&lt;strong>可以在不定义消费组的情况下进行 Stream 消息的独立消费&lt;/strong>，当 Stream 没有新消息时，甚至可以阻塞等待。Redis 设计了一个单独的消费指令&lt;code>xread&lt;/code>，可以将 Stream 当成普通的消息队列 (&lt;code>list&lt;/code>) 来使用。使用 &lt;code>xread&lt;/code> 时，我们可以完全忽略消费组 (Consumer Group) 的存在，就好比 Stream 就是一个普通的列表 (&lt;code>list&lt;/code>)。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xread count &lt;span class="m">1&lt;/span> streams stream2 0-0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;stream2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706393957-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pooky&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;33&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>count 1&lt;/code> 表示获取一条消息&lt;/li>
&lt;li>&lt;code>streams&lt;/code> Redis 关键字&lt;/li>
&lt;li>&lt;code>stream2 0-0&lt;/code> 表示从 &lt;code>stream2&lt;/code> 这个 Stream 中，从消息 ID 为 &lt;code>0-0&lt;/code> 的消息开始读取。&lt;code>0-0&lt;/code> 表示从头开始读取。&lt;/li>
&lt;/ul>
&lt;p>从指定的消息 ID 开始读取(&lt;strong>不包括命令中的消息 ID&lt;/strong>)：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xread count &lt;span class="m">2&lt;/span> streams stream2 1626705954593-0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;stream2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706380924-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;james&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;20&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;stream2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706393957-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pooky&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;33&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>从尾部读取最新的一条消息，&lt;code>$&lt;/code> 代表从尾部读取，此时&lt;strong>默认不返回任何消息&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xread count &lt;span class="m">1&lt;/span> streams stream2 $
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>nil&lt;span class="o">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>所以最好&lt;strong>以阻塞的方式读取尾部最新的一条消息&lt;/strong>，直到新的消息的到来：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xread block &lt;span class="m">0&lt;/span> count &lt;span class="m">1&lt;/span> streams stream2 $&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>block&lt;/code> 后面的数字代表阻塞时间，单位毫秒。&lt;code>0&lt;/code> 表示一直阻塞，直到有新的消息的到来。&lt;/li>
&lt;/ul>
&lt;p>新开一个客户端，往 &lt;code>stream2&lt;/code> 中写入一条消息：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ ./redis-cli -p
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xadd stream2 * name xiaoqiang age &lt;span class="m">18&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;1626706489131-0&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>再回到原来的客户端，就可以看到新的消息：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xread block &lt;span class="m">0&lt;/span> count &lt;span class="m">1&lt;/span> streams stream2 $
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;stream2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706489131-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;xiaoqiang&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;18&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>127.87s&lt;span class="o">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>可以看到阻塞解除了，返回了新的消息内容，而且还显示了一个等待时间，这里等待了 &lt;code>127.87s&lt;/code>&lt;/p>
&lt;p>客户端如果想要使用 &lt;code>xread&lt;/code> 进行顺序消费，一定&lt;strong>要记住当前消费到哪里了，也就是返回的消息 ID&lt;/strong>（Redis 是不会记住消费者消费的位置的）。下次继续调用 &lt;code>xread&lt;/code> 时，将上次返回的最后一个消息 ID 作为参数传递进去，就可以继续消费后续的消息。&lt;/p>
&lt;h4>消费组&lt;span class="hx-absolute -hx-mt-20" id="消费组">&lt;/span>
&lt;a href="#%e6%b6%88%e8%b4%b9%e7%bb%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>创建消费组，&lt;strong>需要传递起始消息 ID 参数用来初始化 &lt;code>last_delivered_id&lt;/code> 变量&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xgroup create stream2 cg1 0-0&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>stream2&lt;/code> 指定要读取的队列&lt;/li>
&lt;li>&lt;code>cg1&lt;/code> 消费组的名称&lt;/li>
&lt;li>&lt;code>0-0&lt;/code> 表示从头开始消费&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xgroup create stream2 cg2 $&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>$&lt;/code> 表示从尾部开始消费，**只接受新消息*8，当前 Stream 消息会全部忽略。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;code>xinfo&lt;/code> 命令查看队列的情况&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xinfo stream stream2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;length&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="c1"># 消息长度为 3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;radix-tree-keys&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1"># 基数树键为 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;radix-tree-nodes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 6&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="c1"># 基数树节点为 2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 7&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;last-generated-id&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 8&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706489131-0&amp;#34;&lt;/span> &lt;span class="c1"># 最后一个消息 ID 为 1626706489131-0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 9&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;groups&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 10&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="c1"># 2 个消费组&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 11&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;first-entry&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 12&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626705954593-0&amp;#34;&lt;/span> &lt;span class="c1"># 第一个消息 ID 为 1626705954593-0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;mark&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;18&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 13&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;last-entry&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 14&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706489131-0&amp;#34;&lt;/span> &lt;span class="c1"># 最后一个消息 ID 为 1626706489131-0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;xiaoqiang&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;18&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>查看队列的消费组信息&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">S127.0.0.1:6880&amp;gt; xinfo groups stream2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;cg1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;consumers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pending&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 6&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 7&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;last-delivered-id&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 8&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;0-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;cg2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;consumers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pending&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 6&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 7&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;last-delivered-id&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 8&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706489131-0&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>消费消息&lt;span class="hx-absolute -hx-mt-20" id="消费消息">&lt;/span>
&lt;a href="#%e6%b6%88%e8%b4%b9%e6%b6%88%e6%81%af" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>有了消费组，自然还需要消费者，Stream 提供了 &lt;code>xreadgroup&lt;/code> 指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息 ID。&lt;/p>
&lt;p>它&lt;strong>同 &lt;code>xread&lt;/code> 一样&lt;/strong>，也可以阻塞等待新消息。读到新消息后，对应的消息 ID 就会进入消费者的 PEL(正在处理的消息) 结构里，客户端处理完毕后使用 &lt;code>xack&lt;/code> 指令通知服务器，本条消息已经处理完毕，该消息 ID 就会从 PEL 中移除。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xreadgroup GROUP cg1 c1 count &lt;span class="m">1&lt;/span> streams stream2 &amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;stream2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;1626706489131-0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;xiaoqiang&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;age&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;18&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>GROUP&lt;/code> 关键字&lt;/li>
&lt;li>&lt;code>cg1&lt;/code> 消费组名称&lt;/li>
&lt;li>&lt;code>c1&lt;/code> 消费者名称&lt;/li>
&lt;li>&lt;code>&amp;gt;&lt;/code> 表示从当前消费组的 &lt;code>last_delivered_id&lt;/code> 后面开始读，每当消费者读取一条消息，&lt;code>last_delivered_id&lt;/code> 变量就会前进。创建消费者组的时候设置了 &lt;code>last_delivered_id&lt;/code>。&lt;/li>
&lt;li>&lt;code>count 1&lt;/code> 表示获取一条消息。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设置阻塞等待&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xreadgroup GROUP cg1 c1 block &lt;span class="m">0&lt;/span> count &lt;span class="m">1&lt;/span> streams stream2 &amp;gt;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>和 &lt;code>xread&lt;/code> 一样，&lt;code>block&lt;/code> 后面的数字代表阻塞时间，单位毫秒。&lt;code>0&lt;/code> 表示一直阻塞，直到有新的消息的到来。&lt;/p>
&lt;p>如果同一个消费组有多个消费者，我们还可以通过 &lt;strong>&lt;code>xinfo consumers&lt;/code> 指令观察每个消费者的状态&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xinfo consumers stream2 cg1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;c1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pending&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;idle&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 6&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">15440&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>pending&lt;/code> 表示当前消费者的 PEL 里面有多少条消息，也就是说有 5 条消息在等待 ACK 确认。&lt;/li>
&lt;li>&lt;code>idle&lt;/code> 表示这个消费者已经空闲了多少秒了。上面的例子是空闲了 15440 秒。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>确认消息&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xack stream2 cg1 1626706489131-0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>再次查看确认消息变成了 4 条：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xinfo consumers stream2 cg1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;c1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;pending&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 5&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;idle&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 6&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">91528&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>&lt;code>xack&lt;/code> 允许带多个消息 ID&lt;/strong>：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6880&amp;gt; xack stream2 cg1 1626706489131-0 1626706489131-1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">2&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>更多的 Redis 的 Stream 命令参考 Redis 官方文档：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://redis.io/topics/streams-intro" target="_blank" rel="noopener">https://redis.io/topics/streams-intro&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2>Redis 队列的几种实现&lt;span class="hx-absolute -hx-mt-20" id="redis-队列的几种实现">&lt;/span>
&lt;a href="#redis-%e9%98%9f%e5%88%97%e7%9a%84%e5%87%a0%e7%a7%8d%e5%ae%9e%e7%8e%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>基于 List 的 LPUSH+BRPOP 的实现&lt;span class="hx-absolute -hx-mt-20" id="基于-list-的-lpushbrpop-的实现">&lt;/span>
&lt;a href="#%e5%9f%ba%e4%ba%8e-list-%e7%9a%84-lpushbrpop-%e7%9a%84%e5%ae%9e%e7%8e%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>优点：&lt;/p>
&lt;p>足够简单，消费消息延迟几乎为零。&lt;/p>
&lt;p>缺点：&lt;/p>
&lt;ol>
&lt;li>不支持广播模式，不能重复消费，一旦消费就会被删除。&lt;/li>
&lt;li>不支持分组消费。&lt;/li>
&lt;li>如果线程一直阻塞在那里，Redis 客户端的连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用，这个时候 &lt;code>blpop&lt;/code> 和 &lt;code>brpop&lt;/code> 或抛出异常，所以在编写客户端消费者的时候要小心，如果
捕获到异常需要重试。&lt;/li>
&lt;li>做消费者确认 ACK 麻烦，不能保证消费者消费消息后是否成功处理的问题（宕机或处理异常等），通常需要维护一个 Pending 列表，保证消息处理确认。&lt;/li>
&lt;/ol>
&lt;h3>基于 ZSet 的实现&lt;span class="hx-absolute -hx-mt-20" id="基于-zset-的实现">&lt;/span>
&lt;a href="#%e5%9f%ba%e4%ba%8e-zset-%e7%9a%84%e5%ae%9e%e7%8e%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>多用来实现延迟队列，当然也可以实现有序的普通的消息队列，但是消费者无法阻塞的获取消息，只能轮询，不允许重复消息。&lt;/p>
&lt;p>实现延迟队列时将消息序列化成一个字符串作为 zset 的 &lt;code>value&lt;/code>，这个消息的到期处理时间作为 &lt;code>score&lt;/code>。按照时间来排序，到期的消息会排在前面。消费消息时，只需要轮询 zset，获取到到期的消息进行处理即可。&lt;/p>
&lt;h3>订阅/发布模式&lt;span class="hx-absolute -hx-mt-20" id="订阅发布模式">&lt;/span>
&lt;a href="#%e8%ae%a2%e9%98%85%e5%8f%91%e5%b8%83%e6%a8%a1%e5%bc%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>优点：&lt;/p>
&lt;ol>
&lt;li>典型的广播模式，一个消息可以发布到多个消费者。&lt;/li>
&lt;li>多信道订阅，消费者可以同时订阅多个信道，从而接收多类消息。&lt;/li>
&lt;li>消息即时发送，消息不用等待消费者读取，消费者会自动接收到信道发布的消息。&lt;/li>
&lt;/ol>
&lt;p>缺点：&lt;/p>
&lt;ol>
&lt;li>消息一旦发布，&lt;strong>发布时若客户端不在线，则消息丢失&lt;/strong>。&lt;/li>
&lt;li>不能保证每个消费者接收的时间是一致的。&lt;/li>
&lt;li>若消费者客户端出现消息积压，到一定程度，会被强制断开，导致消息意外丢失。通常发生在消息的生产远大于消费速度时。&lt;/li>
&lt;/ol>
&lt;p>可见，Pub/Sub 模式不适合做消息存储，消息积压类的业务，而是&lt;strong>擅长处理广播，即时通讯&lt;/strong>，即时反馈的业务。&lt;/p>
&lt;h3>基于 Stream 类型的实现&lt;span class="hx-absolute -hx-mt-20" id="基于-stream-类型的实现">&lt;/span>
&lt;a href="#%e5%9f%ba%e4%ba%8e-stream-%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ae%9e%e7%8e%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>基本上已经有了一个消息中间件的雏形，可以考虑在生产过程中使用，当然真正要在生产中应用，要做的事情还很多，比如消息队列的管理和监控就需要花大力气去实现，而专业消息队列都已经自带或者存在着很好的第三方方案和插件。&lt;/p>
&lt;h2>Stream 的问题&lt;span class="hx-absolute -hx-mt-20" id="stream-的问题">&lt;/span>
&lt;a href="#stream-%e7%9a%84%e9%97%ae%e9%a2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Stream 已经具备了一个消息队列的基本要素，生产者 API、消费者 API，消息 Broker，消息的确认机制等等，所以在使用消息中间件中产生的问题，这里一样也会遇到。&lt;/p>
&lt;h3>消息太多怎么办?&lt;span class="hx-absolute -hx-mt-20" id="消息太多怎么办">&lt;/span>
&lt;a href="#%e6%b6%88%e6%81%af%e5%a4%aa%e5%a4%9a%e6%80%8e%e4%b9%88%e5%8a%9e" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>吐过消息积累太多，Stream 的链表很长，内存会不会爆掉? 而且 &lt;code>xdel&lt;/code> 指令又不会删除消息，它只是给消息做了个标志位。&lt;/p>
&lt;p>Redis 它提供了一个定长 Stream 功能。在 &lt;code>xadd&lt;/code> 的指令提供一个定长长度 &lt;code>maxlen&lt;/code>，就可以将老的消息干掉，确保最多不超过指定长度。&lt;/p>
&lt;h3>消息如果忘记 ACK 会怎样?&lt;span class="hx-absolute -hx-mt-20" id="消息如果忘记-ack-会怎样">&lt;/span>
&lt;a href="#%e6%b6%88%e6%81%af%e5%a6%82%e6%9e%9c%e5%bf%98%e8%ae%b0-ack-%e4%bc%9a%e6%80%8e%e6%a0%b7" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Stream 在每个消费者结构中保存了正在处理中的消息 ID 列表 PEL，如果消费者收到了消息处理完了但是&lt;strong>没有回复 ack，就会导致 PEL 列表不断增长&lt;/strong>，如果有很多消费组的话，那么这个 PEL 占用的内存越来越大。所以&lt;strong>消息要尽可能的快速消费并确认&lt;/strong>。&lt;/p>
&lt;p>PEL 是&lt;strong>已被消费者组获取但未被确认 (ACK) 的消息 ID 集合&lt;/strong>，这些消息处于&amp;quot;处理中&amp;quot;状态，具有以下特征：&lt;/p>
&lt;ul>
&lt;li>已被某个消费者 (Consumer) 通过 &lt;code>xreadgroup&lt;/code> 获取&lt;/li>
&lt;li>尚未被 &lt;code>xack&lt;/code> 确认处理完成&lt;/li>
&lt;li>仍在消费者的&amp;quot;责任范围&amp;quot;内&lt;/li>
&lt;li>会被包含在 &lt;code>xpenging&lt;/code> 命令的返回结果中&lt;/li>
&lt;/ul>
&lt;h3>PEL 如何避免消息丢失?&lt;span class="hx-absolute -hx-mt-20" id="pel-如何避免消息丢失">&lt;/span>
&lt;a href="#pel-%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e6%b6%88%e6%81%af%e4%b8%a2%e5%a4%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>在消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID。待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 &lt;code>xreadgroup&lt;/code> 的起始消息 ID 不能为参数 &lt;code>&amp;gt;&lt;/code>，而必须是任意有效的消息 ID，一般将参数设为 &lt;code>0-0&lt;/code>，表示读取所有的 PEL 消息以及自 &lt;code>last_delivered_id&lt;/code> 之后的新消息。&lt;/p>
&lt;h3>死信问题&lt;span class="hx-absolute -hx-mt-20" id="死信问题">&lt;/span>
&lt;a href="#%e6%ad%bb%e4%bf%a1%e9%97%ae%e9%a2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>如果某个消息，不能被消费者处理，也就是&lt;strong>不能被 &lt;code>XACK&lt;/code>，这是要长时间处于 Pending 列表中&lt;/strong>，即使被反复的转移给各个消费者也是如此。此时该消息的 &lt;code>delivery counter&lt;/code>（&lt;strong>通过 &lt;code>XPENDING&lt;/code> 可以查询到&lt;/strong>）就会累加，当累加到某个预设的临界值时，就认为是坏消息（也叫&lt;strong>死信&lt;/strong>，DeadLetter，无法投递的消息），由于有了判定条件，我们将坏消息处理掉即可，&lt;strong>删除即可&lt;/strong>。删除一个消息，&lt;strong>使用 &lt;code>XDEL&lt;/code> 语法，注意，这个命令并没有删除 Pending 中的消息，因此查看 Pending，消息还会在，可以在执行执行 &lt;code>XDEL&lt;/code> 之后，&lt;code>XACK&lt;/code> 这个消息标识其处理完毕&lt;/strong>。&lt;/p>
&lt;p>专业的 MQ 中间件，例如 RabbitMQ，有死信队列的概念，当消息在一定时间内没有被消费，就会被投递到死信队列中，有专门的死信队列消费者来处理。但是 &lt;strong>Stream 没有提供死信队列的概念，需要我们自己处理&lt;/strong>。&lt;/p>
&lt;h3>Stream 的高可用&lt;span class="hx-absolute -hx-mt-20" id="stream-的高可用">&lt;/span>
&lt;a href="#stream-%e7%9a%84%e9%ab%98%e5%8f%af%e7%94%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Stream 的高可用是建立主从复制基础上的，它和其它数据结构的复制机制没有区别，也就是说在 Sentinel 和 Cluster 集群环境下 Stream 是可以支持高可用的。不过&lt;strong>由于 Redis 的指令复制是异步的，在 failover 发生时，Redis 可能会丢失极小部分数据&lt;/strong>，这点 Redis 的其它数据结构也是一样的。&lt;/p>
&lt;h3>分区 Partition&lt;span class="hx-absolute -hx-mt-20" id="分区-partition">&lt;/span>
&lt;a href="#%e5%88%86%e5%8c%ba-partition" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis 的服务器没有原生支持分区能力，如果想要使用分区，那就需要分配多个 Stream，然后在客户端使用一定的策略来生产消息到不同的 Stream。&lt;/p>
&lt;h2>什么时候选择 Redis Stream？&lt;span class="hx-absolute -hx-mt-20" id="什么时候选择-redis-stream">&lt;/span>
&lt;a href="#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%80%89%e6%8b%a9-redis-stream" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Stream 的消费模型借鉴了 Kafka 的消费分组的概念，它弥补了 Redis Pub/Sub 不能持久化消息的缺陷。但是它又不同于 kafka，Kafka 的消息可以分 partition，而 Stream 不行。如果非要分 parition 的话，得在客户端做，提供不同的 Stream 名称，对消息进行 hash 取模来选择往哪个 Stream 里塞。&lt;/p>
&lt;p>如果是中小项目和企业，在工作中已经使用了 Redis，在业务量不是很大，而又需要消息中间件功能的情况下，可以考虑使用 Redis 的 Stream 功能。但是如果并发量很高，资源足够支持下，还是以专业的消息中间件，比如 RocketMQ、Kafka 等来支持业务更好。&lt;/p></description></item></channel></rss>