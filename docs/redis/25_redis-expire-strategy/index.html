<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Redis 的过期策略和内存淘汰机制#在日常开发中，我们使用 Redis 存储 key 时通常会设置一个过期时间，但是 Redis 是怎么删除过期的 key，而且 Redis 是单线程的， 删除 key 过于频繁会不会造成阻塞。要搞清楚这些，就要了解 Redis 的过期策略和内存淘汰机制。
Redis 采用的是定期删除加懒惰删除策略。懒惰删除就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了 就立即删除。定时删除是集中处理，惰性删除是零散处理。
定期删除策略#Redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，默认每 100ms 进行一次过期扫描：
 随机抽取 20 个 key 删除这 20 个 key 中过期的 key 如果过期的 key 比例超过 1/4，就重复步骤 1，继续删除。  之所以不扫描所有的 key，是因为 Redis 是单线程，全部扫描会导致线程卡死。
而且为了防止每次扫描过期的 key 比例都超过 1/4，导致不停循环卡死线程，Redis 为每次扫描添加了上限时间，默认是 25ms。
如果一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果？#大量的 key 在同一时间过期，那么 Redis 会持续扫描过期字典 (循环多次)，直到过期字典中过期的 key 变得稀疏，才会停止 (循环次数明显下降)。 这会导致线上读写请求出现明显的卡顿现象。导致这种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的 CPU 消耗。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="Redis 的过期策略和内存淘汰机制" />
<meta property="og:description" content="Redis 的过期策略和内存淘汰机制#在日常开发中，我们使用 Redis 存储 key 时通常会设置一个过期时间，但是 Redis 是怎么删除过期的 key，而且 Redis 是单线程的， 删除 key 过于频繁会不会造成阻塞。要搞清楚这些，就要了解 Redis 的过期策略和内存淘汰机制。
Redis 采用的是定期删除加懒惰删除策略。懒惰删除就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了 就立即删除。定时删除是集中处理，惰性删除是零散处理。
定期删除策略#Redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，默认每 100ms 进行一次过期扫描：
 随机抽取 20 个 key 删除这 20 个 key 中过期的 key 如果过期的 key 比例超过 1/4，就重复步骤 1，继续删除。  之所以不扫描所有的 key，是因为 Redis 是单线程，全部扫描会导致线程卡死。
而且为了防止每次扫描过期的 key 比例都超过 1/4，导致不停循环卡死线程，Redis 为每次扫描添加了上限时间，默认是 25ms。
如果一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果？#大量的 key 在同一时间过期，那么 Redis 会持续扫描过期字典 (循环多次)，直到过期字典中过期的 key 变得稀疏，才会停止 (循环次数明显下降)。 这会导致线上读写请求出现明显的卡顿现象。导致这种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的 CPU 消耗。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/db-learn/docs/redis/25_redis-expire-strategy/" />
<meta property="article:modified_time" content="2020-06-17T17:45:14+08:00" />
<title>Redis 的过期策略和内存淘汰机制 | Database Learning</title>
<link rel="manifest" href="/db-learn/manifest.json">
<link rel="icon" href="/db-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/db-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/db-learn/en.search.min.79aa4caec43110b70bc10866de8e262ae56a148e0d75708b1522265755d59b70.js" integrity="sha256-eapMrsQxELcLwQhm3o4mKuVqFI4NdXCLFSImV1XVm3A="></script>

<script defer src="/db-learn/sw.min.b93542a5760842e2e25439dfb3c014a53a75c12fc8ef2e8e01a71b378f98e127.js" integrity="sha256-uTVCpXYIQuLiVDnfs8AUpTp1wS/I7y6OAacbN4&#43;Y4Sc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/db-learn"><span>Database Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/db-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li>
<p><strong>Mysql</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mysql/01_getting_started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mysql/02_install/">安裝</a></li>
<li>
  <a href="/db-learn/docs/mysql/03_query/">简单查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/04_advanced_query/">复杂查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/05_write_operation/">写操作</a></li>
<li>
  <a href="/db-learn/docs/mysql/06_other/">其他</a></li>
<li>
  <a href="/db-learn/docs/mysql/07_architecture/">基础架构</a></li>
<li>
  <a href="/db-learn/docs/mysql/08_config/">启动选项和配置文件</a></li>
<li>
  <a href="/db-learn/docs/mysql/09_character/">字符集和比较规则</a></li>
<li>
  <a href="/db-learn/docs/mysql/10_innodb-record-store-structure/">InnoDB 记录存储结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/11_innodb-page-structure/">InnoDB 数据页结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/12_b-tree/">B+ 树索引</a></li>
<li>
  <a href="/db-learn/docs/mysql/13_isolation-level/">事务的隔离级别</a></li>
<li>
  <a href="/db-learn/docs/mysql/14_lock/">锁</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>Redis</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/redis/01_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/redis/02_redis-config/">安装配置</a></li>
<li>
  <a href="/db-learn/docs/redis/03_redis-string/">数据类型 String</a></li>
<li>
  <a href="/db-learn/docs/redis/04_redis-hash/">数据类型 Hash</a></li>
<li>
  <a href="/db-learn/docs/redis/05_redis-set/">数据类型 Set</a></li>
<li>
  <a href="/db-learn/docs/redis/06_redis-sortedset/">数据类型 SortedSet</a></li>
<li>
  <a href="/db-learn/docs/redis/07_redis-list/">数据类型 List</a></li>
<li>
  <a href="/db-learn/docs/redis/08_redis-key/">Key 操作</a></li>
<li>
  <a href="/db-learn/docs/redis/09_sds/">简单动态字符串</a></li>
<li>
  <a href="/db-learn/docs/redis/10_dict/">字典</a></li>
<li>
  <a href="/db-learn/docs/redis/11_redis-object/">对象</a></li>
<li>
  <a href="/db-learn/docs/redis/12_bitmap/">位图</a></li>
<li>
  <a href="/db-learn/docs/redis/13_distributed-lock/">分布式锁</a></li>
<li>
  <a href="/db-learn/docs/redis/14_queue/">延时队列</a></li>
<li>
  <a href="/db-learn/docs/redis/15_hyperloglog/">HyperLogLog</a></li>
<li>
  <a href="/db-learn/docs/redis/16_bloom-filter/">布隆过滤器</a></li>
<li>
  <a href="/db-learn/docs/redis/17_current-limit/">限流</a></li>
<li>
  <a href="/db-learn/docs/redis/18_geohash/">GeoHash</a></li>
<li>
  <a href="/db-learn/docs/redis/19_persistence/">持久化</a></li>
<li>
  <a href="/db-learn/docs/redis/20_pipeline/">管道</a></li>
<li>
  <a href="/db-learn/docs/redis/21_transaction/">事务</a></li>
<li>
  <a href="/db-learn/docs/redis/22_sync/">主从同步</a></li>
<li>
  <a href="/db-learn/docs/redis/23_cluster/">集群</a></li>
<li>
  <a href="/db-learn/docs/redis/24_info/">INFO 指令</a></li>
<li>
  <a href="/db-learn/docs/redis/25_redis-expire-strategy/"class=active>过期策略和内存淘汰机制</a></li>
<li>
  <a href="/db-learn/docs/redis/26_protect-redis/">保护 Redis</a></li>
<li>
  <a href="/db-learn/docs/redis/27_skills/">一些命令行技巧</a></li>
<li>
  <a href="/db-learn/docs/redis/28_slowlog/">慢查询日志</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>MongoDB</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mongo/01_overview/">介绍</a></li>
<li>
  <a href="/db-learn/docs/mongo/02_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mongo/03_advance/">使用</a></li>
<li>
  <a href="/db-learn/docs/mongo/04_migrate/">数据迁移</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/db-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Redis 的过期策略和内存淘汰机制</strong>

  <label for="toc-control">
    
    <img src="/db-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#定期删除策略">定期删除策略</a>
      <ul>
        <li><a href="#如果一个大型的-redis-实例中所有的-key-在同一时间过期了会出现怎样的结果">如果一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果？</a></li>
        <li><a href="#从库的过期策略">从库的过期策略</a></li>
      </ul>
    </li>
    <li><a href="#内存淘汰机制">内存淘汰机制</a>
      <ul>
        <li><a href="#近似-lru-算法">近似 LRU 算法</a></li>
        <li><a href="#lfu">LFU</a></li>
      </ul>
    </li>
    <li><a href="#内存回收机制">内存回收机制</a></li>
    <li><a href="#懒惰删除">懒惰删除</a>
      <ul>
        <li><a href="#redis-为什么要懒惰删除lazy-free">Redis 为什么要懒惰删除(lazy free)？</a></li>
        <li><a href="#unlink">unlink</a></li>
        <li><a href="#flush">flush</a></li>
        <li><a href="#异步队列">异步队列</a></li>
        <li><a href="#aof-sync">AOF Sync</a></li>
        <li><a href="#更多异步删除点">更多异步删除点</a></li>
        <li><a href="#异步删除的实现">异步删除的实现</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="redis-的过期策略和内存淘汰机制">
  Redis 的过期策略和内存淘汰机制
  <a class="anchor" href="#redis-%e7%9a%84%e8%bf%87%e6%9c%9f%e7%ad%96%e7%95%a5%e5%92%8c%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6">#</a>
</h1>
<p>在日常开发中，我们使用 Redis 存储 <code>key</code> 时通常会设置一个过期时间，但是 Redis 是怎么删除过期的 <code>key</code>，而且 Redis 是单线程的，
删除 <code>key</code> 过于频繁会不会造成阻塞。要搞清楚这些，就要了解 Redis 的过期策略和内存淘汰机制。</p>
<p>Redis 采用的是<strong>定期删除</strong>加<strong>懒惰删除</strong>策略。懒惰删除就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了
就立即删除。<strong>定时删除是集中处理，惰性删除是零散处理</strong>。</p>
<h2 id="定期删除策略">
  定期删除策略
  <a class="anchor" href="#%e5%ae%9a%e6%9c%9f%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5">#</a>
</h2>
<p>Redis 会将每个<strong>设置了过期时间的 <code>key</code> 放入到一个独立的字典</strong>中，默认每 <code>100ms</code> 进行一次过期扫描：</p>
<ol>
<li>随机抽取 <code>20</code> 个 <code>key</code></li>
<li>删除这 <code>20</code> 个 <code>key</code> 中过期的 <code>key</code></li>
<li>如果过期的 <code>key</code> 比例超过 <code>1/4</code>，就重复步骤 <code>1</code>，继续删除。</li>
</ol>
<p>之所以不扫描所有的 <code>key</code>，是因为 Redis 是单线程，全部扫描会导致线程卡死。</p>
<p>而且为了防止每次扫描过期的 <code>key</code> 比例都超过 <code>1/4</code>，导致不停循环卡死线程，Redis 为每次扫描添加了<strong>上限时间</strong>，默认是 <code>25ms</code>。</p>
<h3 id="如果一个大型的-redis-实例中所有的-key-在同一时间过期了会出现怎样的结果">
  如果一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果？
  <a class="anchor" href="#%e5%a6%82%e6%9e%9c%e4%b8%80%e4%b8%aa%e5%a4%a7%e5%9e%8b%e7%9a%84-redis-%e5%ae%9e%e4%be%8b%e4%b8%ad%e6%89%80%e6%9c%89%e7%9a%84-key-%e5%9c%a8%e5%90%8c%e4%b8%80%e6%97%b6%e9%97%b4%e8%bf%87%e6%9c%9f%e4%ba%86%e4%bc%9a%e5%87%ba%e7%8e%b0%e6%80%8e%e6%a0%b7%e7%9a%84%e7%bb%93%e6%9e%9c">#</a>
</h3>
<p>大量的 key 在同一时间过期，那么 Redis 会持续扫描过期字典 (循环多次)，直到过期字典中过期的 key 变得稀疏，才会停止 (循环次数明显下降)。
这会导致线上读写请求出现明显的卡顿现象。导致这种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的 CPU 消耗。</p>
<p>而且，如果客户端将请求超时时间设置的比较短，比如 10ms，但是请求以为过期扫描导致至少等待 25ms 后才会进行处理，那么就会出现大量的请求因为
超时而关闭，业务端就会出现很多异常。这时你还无法从 Redis 的 <code>slowlog</code> 中看到慢查询记录，因为慢查询指的是逻辑处理过程慢，不包含等待时间。</p>
<p>所以要避免大批量的 key 同时过期，可以给过期时间设置一个随机范围，分散过期处理的压力。</p>
<h3 id="从库的过期策略">
  从库的过期策略
  <a class="anchor" href="#%e4%bb%8e%e5%ba%93%e7%9a%84%e8%bf%87%e6%9c%9f%e7%ad%96%e7%95%a5">#</a>
</h3>
<p>从库不会进行过期扫描，从库对过期的处理是被动的。主库在 key 到期时，会在 AOF 文件里增加一条 <code>del</code> 指令，同步到所有的从库，从库通过执行
这条 <code>del</code> 指令来删除过期的 key。</p>
<p>因为指令同步是异步进行的，所以主库过期的 key 的 <code>del</code> 指令没有及时同步到从库的话，会出现主从数据的不一致。</p>
<h2 id="内存淘汰机制">
  内存淘汰机制
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6">#</a>
</h2>
<p>当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)。交换会让 Redis 的性能急剧下降，对于 Redis 来说，这样
龟速的存取效率基本上等于不可用。</p>
<p>Redis 为了限制最大使用内存，提供了配置参数 <code>maxmemory</code>，可以在 <code>redis.conf</code> 中配置。当内存超出 <code>maxmemory</code>，Redis 提供了几种
策略（maxmemory-policy）让用户选择：</p>
<ul>
<li><code>noeviction</code>：当内存超出 <code>maxmemory</code>，写入请求会报错，但是删除和读请求可以继续。（这个可是默认的策略）。</li>
<li><code>allkeys-lru</code>：当内存超出 <code>maxmemory</code>，在所有的 <code>key</code> 中，移除最少使用的 <code>key</code>。</li>
<li><code>allkeys-random</code>：当内存超出 <code>maxmemory</code>，在所有的 <code>key</code> 中，随机移除某个 <code>key</code>。（应该没人用吧）</li>
<li><code>volatile-lru</code>：当内存超出 <code>maxmemory</code>，在设置了过期时间 <code>key</code> 的字典中，移除最少使用的 <code>key</code>。</li>
<li><code>volatile-random</code>：当内存超出 <code>maxmemory</code>，在设置了过期时间 <code>key</code> 的字典中，随机移除某个<code> key</code>。</li>
<li><code>volatile-ttl</code>：当内存超出 <code>maxmemory</code>，在设置了过期时间 <code>key</code> 的字典中，优先移除 <code>ttl</code> 小的。</li>
</ul>
<p>volatile-xxx 策略只会针对带过期时间的 key 进行淘汰，allkeys-xxx 策略会对所有的 key 进行淘汰。如果只是拿 Redis 做缓存，那应该使
用 allkeys-xxx，客户端写缓存时不必携带过期时间。如果还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx 策略，这样可以保留没
有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰。</p>
<h3 id="近似-lru-算法">
  近似 LRU 算法
  <a class="anchor" href="#%e8%bf%91%e4%bc%bc-lru-%e7%ae%97%e6%b3%95">#</a>
</h3>
<p>Redis 使用的并不是完全 <code>LRU</code> 算法。不使用 <code>LRU</code> 算法，是为了节省内存，Redis 采用的是随机 <code>LRU</code> 算法，Redis 为每一个 <code>key</code> 增加了
一个 24 bit 的字段，用来记录这个 <code>key</code> 最后一次被访问的时间戳。<strong>注意 Redis 的 <code>LRU</code> 淘汰策略是懒惰处理</strong>，也就是不会主动执行淘汰
策略，当 Redis 执行写操作时，发现内存超出 <code>maxmemory</code>，就会执行 <code>LRU</code> 淘汰算法。这个算法就是随机采样出 <code>5</code> (默认值)个 <code>key</code>，然后移
除最旧的 <code>key</code>，如果移除后内存还是超出 <code>maxmemory</code>，那就继续随机采样淘汰，直到内存低于 <code>maxmemory</code> 为止。</p>
<p>如何采样就是看 <code>maxmemory-policy</code> 的配置，如果是 <code>allkeys</code> 就是从所有的 key 字典中随机，如果是 <code>volatile</code> 就从带过期时间的 key 字
典中随机。每次采样多少个 key 看的是 <code>maxmemory_samples</code> 的配置，默认为 5。</p>
<h3 id="lfu">
  LFU
  <a class="anchor" href="#lfu">#</a>
</h3>
<p>Redis 4.0 里引入了一个新的淘汰策略 —— LFU（Least Frequently Used） 模式，作者认为它比 LRU 更加优秀。</p>
<p>LFU 表示按最近的访问频率进行淘汰，它比 LRU 更加精准地表示了一个 key 被访问的热度。</p>
<p>如果一个 key 长时间不被访问，只是刚刚偶然被用户访问了一下，那么在使用 LRU 算法下它是不容易被淘汰的，因为 LRU 算法认为当前这个 key 是
很热的。而 LFU 是需要追踪最近一段时间的访问频率，如果某个 key 只是偶然被访问一次是不足以变得很热的，它需要在近期一段时间内被访问很多
次才有机会被认为很热。</p>
<h4 id="redis-对象的热度">
  Redis 对象的热度
  <a class="anchor" href="#redis-%e5%af%b9%e8%b1%a1%e7%9a%84%e7%83%ad%e5%ba%a6">#</a>
</h4>
<p>Redis 的所有对象结构头中都有一个 24 bit 的字段，这个字段用来记录对象的<strong>热度</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// redis 的对象头
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisObject {
    <span style="color:#66d9ef">unsigned</span> type:<span style="color:#ae81ff">4</span>; <span style="color:#75715e">// 对象类型如 zset/set/hash 等等
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> encoding:<span style="color:#ae81ff">4</span>; <span style="color:#75715e">// 对象编码如 ziplist/intset/skiplist 等等
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> lru:<span style="color:#ae81ff">24</span>; <span style="color:#75715e">// 对象的「热度」
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> refcount; <span style="color:#75715e">// 引用计数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr; <span style="color:#75715e">// 对象的 body
</span><span style="color:#75715e"></span>} robj;
</code></pre></div><h4 id="lru-模式">
  LRU 模式
  <a class="anchor" href="#lru-%e6%a8%a1%e5%bc%8f">#</a>
</h4>
<p>在 LRU 模式下，<code>lru</code> 字段存储的是 Redis 时钟 <code>server.lruclock</code>，Redis 时钟是一个 24 bit 的整数，默认是 Unix 时间戳对 <code>2^24</code> 取
模的结果，大约 97 天清零一次。当某个 key 被访问一次，它的对象头的 <code>lru</code> 字段值就会被更新为 <code>server.lruclock</code>。</p>
<h4 id="lfu-模式">
  LFU 模式
  <a class="anchor" href="#lfu-%e6%a8%a1%e5%bc%8f">#</a>
</h4>
<p>在 LFU 模式下，<code>lru</code> 字段 24 个 bit 用来存储两个值，分别是 <code>ldt(last decrement time)</code> 和 <code>logc(logistic counter)</code>。</p>
<p>
  <img src="../../../images/redis-lfu.jpg" alt="" /></p>
<p><code>logc</code> 是 8 个 <code>bit</code>，用来存储访问频次，因为 8 个 <code>bit</code> 能表示的最大整数值为 255，存储频次肯定远远不够，所以这 8 个 <code>bit</code> 存储的
是频次的对数值，并且这个值还会随时间衰减。如果它的值比较小，那么就很容易被回收。<strong>为了确保新创建的对象不被回收，新对象的这 8 个 <code>bit</code> 会
初始化为一个大于零的值，默认是 <code>LFU_INIT_VAL=5</code></strong>。</p>
<p><code>ldt</code> 是 16 个位，用来存储上一次 <code>logc</code> 的更新时间，因为只有 16 位，所以精度不可能很高。它取的是分钟时间戳对 2^16 进行取模，大约每
隔 45 天就会折返。同 LRU 模式一样，我们也可以使用这个逻辑计算出对象的空闲时间，只不过精度是分钟级别的。图中的 <code>server.unixtime</code> 是
当前 redis 记录的系统时间戳，和 <code>server.lruclock</code> 一样，它也是每毫秒更新一次。</p>
<h4 id="启用-lfu">
  启用 LFU
  <a class="anchor" href="#%e5%90%af%e7%94%a8-lfu">#</a>
</h4>
<p>Redis 4.0 给淘汰策略配置参数 maxmemory-policy 增加了 2 个选项，</p>
<ul>
<li><code>volatile-lfu</code>：对带过期时间的 key 执行 lfu 淘汰算法</li>
<li><code>allkeys-lfu</code>：对所有的 key 执行 lfu 淘汰算法</li>
</ul>
<p>使用 <code>object freq</code> 指令获取对象的 lfu 计数值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">&gt; config set maxmemory-policy allkeys-lfu
OK
&gt; set codehole yeahyeahyeah
OK
// 获取计数值，初始化为 LFU_INIT_VAL<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>
&gt; object freq codehole
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">5</span>
// 访问一次
&gt; get codehole
<span style="color:#e6db74">&#34;yeahyeahyeah&#34;</span>
// 计数值增加了
&gt; object freq codehole
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">6</span>
</code></pre></div><h4 id="为什么-redis-要缓存系统时间戳">
  为什么 Redis 要缓存系统时间戳？
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88-redis-%e8%a6%81%e7%bc%93%e5%ad%98%e7%b3%bb%e7%bb%9f%e6%97%b6%e9%97%b4%e6%88%b3">#</a>
</h4>
<p>因为每一次获取系统时间戳都是一次系统调用。系统调用相对来说是比较费时间的，作为单线程的 Redis 表示承受不起，所以它需要对时间进行缓存，获
取时间都直接从缓存中直接拿。</p>
<h2 id="内存回收机制">
  内存回收机制
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6">#</a>
</h2>
<p>Redis 并不总是可以将空闲内存立即归还给操作系统。</p>
<p>如果当前 Redis 内存有 10G，当你删除了 1GB 的 key 后，再去观察内存，你会发现内存变化不会太大。原因是操作系统回收内存是以页为单位，
如果这个页上只要有一个 key 还在使用，那么它就不能被回收。Redis 虽然删除了 1GB 的 key，但是这些 key 分散到了很多页面中，每个页面
都还有其它 key 存在，这就导致了内存不会立即被回收。</p>
<p>不过，如果你执行 flushdb，然后再观察内存会发现内存确实被回收了。原因是所有的 key 都干掉了，大部分之前使用的页面都完全干净了，会立
即被操作系统回收。</p>
<p>Redis <strong>虽然无法保证立即回收已经删除的 key 的内存，但是它会重用那些尚未回收的空闲内存</strong>。</p>
<h2 id="懒惰删除">
  懒惰删除
  <a class="anchor" href="#%e6%87%92%e6%83%b0%e5%88%a0%e9%99%a4">#</a>
</h2>
<h3 id="redis-为什么要懒惰删除lazy-free">
  Redis 为什么要懒惰删除(lazy free)？
  <a class="anchor" href="#redis-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%87%92%e6%83%b0%e5%88%a0%e9%99%a4lazy-free">#</a>
</h3>
<p>删除指令 <code>del</code> 会直接释放对象的内存，大部分情况下，这个指令非常快，没有明显延迟。不过如果删除的 key 是一个非常大的对象，比如一个包
含了千万元素的 <code>hash</code>，又或者在使用 <code>FLUSHDB</code> 和 <code>FLUSHALL</code> 删除包含大量键的数据库时，那么删除操作就会导致线程卡顿。</p>
<p>redis 4.0 引入了 <code>lazyfree</code> 的机制，它可以将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞。</p>
<h3 id="unlink">
  unlink
  <a class="anchor" href="#unlink">#</a>
</h3>
<p><code>unlink</code> 指令，它能对删除操作进行懒处理，丢给后台线程来异步回收内存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">&gt; unlink key
OK
</code></pre></div><h3 id="flush">
  flush
  <a class="anchor" href="#flush">#</a>
</h3>
<p><code>flushdb</code> 和 <code>flushall</code> 指令，用来清空数据库，这也是极其缓慢的操作。Redis 4.0 同样给这两个指令也带来了异步化，在指令后面增
加 <code>async</code> 参数就可以扔给后台线程慢慢处理。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">&gt; flushall async
OK
</code></pre></div><h3 id="异步队列">
  异步队列
  <a class="anchor" href="#%e5%bc%82%e6%ad%a5%e9%98%9f%e5%88%97">#</a>
</h3>
<p>主线程将对象的引用从有效数据中删除后，会将这个 key 的内存回收操作包装成一个任务，塞进异步任务队列，后台线程会从这个异步队列中取任务。任
务队列被主线程和异步线程同时操作，所以必须是一个线程安全的队列。</p>
<p>不是所有的 <code>unlink</code> 操作都会延后处理，如果对应 key 所占用的内存很小，延后处理就没有必要了，这时候 Redis 会将对应的 key 内存立即回收，
跟 <code>del</code> 指令一样。</p>
<h3 id="aof-sync">
  AOF Sync
  <a class="anchor" href="#aof-sync">#</a>
</h3>
<p>Redis 需要每秒一次(可配置)同步 AOF 日志到磁盘，确保消息尽量不丢失，需要调用 sync 函数，这个操作会比较耗时，会导致主线程的效率下降，
所以 Redis 也将这个操作移到异步线程来完成。执行 AOF Sync 操作的线程是一个独立的异步线程，它也有一个属于自己的任务队列，队列里只用
来存放 AOF Sync 任务。</p>
<h3 id="更多异步删除点">
  更多异步删除点
  <a class="anchor" href="#%e6%9b%b4%e5%a4%9a%e5%bc%82%e6%ad%a5%e5%88%a0%e9%99%a4%e7%82%b9">#</a>
</h3>
<p>Redis 回收内存除了 <code>del</code> 指令和 <code>flush</code> 之外，还会存在 key 的过期、LRU 淘汰、<code>rename</code> 指令以及从库全量同步时接受完 rdb 文件后会
立即进行的 <code>flush</code> 操作。</p>
<p>Redis4.0 为这些删除点也带来了异步删除机制，打开这些点需要额外的配置选项。</p>
<ul>
<li><code>slave-lazy-flush</code> 从库接受完 rdb 文件后的 <code>flush</code> 操作</li>
<li><code>lazyfree-lazy-eviction</code> 内存达到 <code>maxmemory</code> 时进行淘汰</li>
<li><code>lazyfree-lazy-expire</code> key 过期删除</li>
<li><code>lazyfree-lazy-server-del</code> <code>rename</code> 指令删除 <code>destKey</code></li>
</ul>
<h3 id="异步删除的实现">
  异步删除的实现
  <a class="anchor" href="#%e5%bc%82%e6%ad%a5%e5%88%a0%e9%99%a4%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h3>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/db-learn/commit/391abafbb55e9e09f274b9823c6b411133314e4f" title='Last modified by shipengqi | June 17, 2020' target="_blank" rel="noopener">
      <img src="/db-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 17, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/db-learn/edit/master/content//docs/redis/25_redis-expire-strategy.md" target="_blank" rel="noopener">
      <img src="/db-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#定期删除策略">定期删除策略</a>
      <ul>
        <li><a href="#如果一个大型的-redis-实例中所有的-key-在同一时间过期了会出现怎样的结果">如果一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果？</a></li>
        <li><a href="#从库的过期策略">从库的过期策略</a></li>
      </ul>
    </li>
    <li><a href="#内存淘汰机制">内存淘汰机制</a>
      <ul>
        <li><a href="#近似-lru-算法">近似 LRU 算法</a></li>
        <li><a href="#lfu">LFU</a></li>
      </ul>
    </li>
    <li><a href="#内存回收机制">内存回收机制</a></li>
    <li><a href="#懒惰删除">懒惰删除</a>
      <ul>
        <li><a href="#redis-为什么要懒惰删除lazy-free">Redis 为什么要懒惰删除(lazy free)？</a></li>
        <li><a href="#unlink">unlink</a></li>
        <li><a href="#flush">flush</a></li>
        <li><a href="#异步队列">异步队列</a></li>
        <li><a href="#aof-sync">AOF Sync</a></li>
        <li><a href="#更多异步删除点">更多异步删除点</a></li>
        <li><a href="#异步删除的实现">异步删除的实现</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












