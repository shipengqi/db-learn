<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Database Learning – 实战</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/</link><description>Recent content in 实战 on Database Learning</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><atom:link href="https://shipengqi.github.io/db-learn/docs/redis/practice/index.xml" rel="self" type="application/rss+xml"/><item><title>持久化</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/06_persistence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/06_persistence/</guid><description>
&lt;p>Redis 的数据全部在内存里，如果突然宕机，数据就会全部丢失，Redis 的持久化机制就是用来来保证 Redis 的数据不会因为故障而丢失。&lt;/p>
&lt;p>Redis 的持久化机制有两种：&lt;/p>
&lt;ul>
&lt;li>快照，快照是一次全量备份。&lt;/li>
&lt;li>AOF 日志，AOF 日志是连续的增量备份。&lt;/li>
&lt;/ul>
&lt;h2>RDB&lt;span class="hx-absolute -hx-mt-20" id="rdb">&lt;/span>
&lt;a href="#rdb" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;strong>快照（RDB）是内存数据的二进制序列化形式，在存储上非常紧凑&lt;/strong>。&lt;/p>
&lt;h3>自动快照&lt;span class="hx-absolute -hx-mt-20" id="自动快照">&lt;/span>
&lt;a href="#%e8%87%aa%e5%8a%a8%e5%bf%ab%e7%85%a7" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>在默认情况下， Redis 将内存数据库快照保存在名字为 &lt;code>dump.rdb&lt;/code> 的二进制文件中。&lt;/p>
&lt;p>可以对 Redis 进行设置， 让它在 “N 秒内数据集至少有 M 个改动” 这一条件被满足时，自动保存一次数据集。&lt;/p>
&lt;p>比如说，以下设置会让 Redis 在满足 “60 秒内有至少有 1000 个键被改动” 这一条件时，自动保存一次数据集：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># save 60 1000 // 关闭 RDB 只需要将所有的 save 保存策略注释掉即可&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>手动快照&lt;span class="hx-absolute -hx-mt-20" id="手动快照">&lt;/span>
&lt;a href="#%e6%89%8b%e5%8a%a8%e5%bf%ab%e7%85%a7" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>RDB 快照还可以手动执行命令生成，进入 Redis 客户端执行命令 &lt;code>save&lt;/code> 或 &lt;code>bgsave&lt;/code> 可以生成 &lt;code>dump.rdb&lt;/code> 文件，每次命令执行都会将所有 Redis 内存快照到一个新的 rdb 文件里，并覆盖原有 rdb 快照文件。&lt;/p>
&lt;p>&lt;code>save&lt;/code> 与 &lt;code>bgsave&lt;/code> 对比：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th>save&lt;/th>
&lt;th>bgsave&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>IO 类型&lt;/td>
&lt;td>同步&lt;/td>
&lt;td>异步&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>是否阻塞 Redis 其它命令&lt;/td>
&lt;td>是&lt;/td>
&lt;td>否 (在生成子进程执行调用 &lt;code>fork&lt;/code> 函数时会有短暂阻塞)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>复杂度&lt;/td>
&lt;td>&lt;code>O(n)&lt;/code>&lt;/td>
&lt;td>&lt;code>O(n)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>优点&lt;/td>
&lt;td>不会消耗额外内存&lt;/td>
&lt;td>不阻塞客户端命令&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>缺点&lt;/td>
&lt;td>阻塞客户端命令&lt;/td>
&lt;td>需要 &lt;code>fork&lt;/code> 子进程，消耗内存&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>bgsave 的写时复制 (COW) 机制&lt;span class="hx-absolute -hx-mt-20" id="bgsave-的写时复制-cow-机制">&lt;/span>
&lt;a href="#bgsave-%e7%9a%84%e5%86%99%e6%97%b6%e5%a4%8d%e5%88%b6-cow-%e6%9c%ba%e5%88%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理其他写命令。简单来说，&lt;code>bgsave&lt;/code> 子进程是由主线程 &lt;code>fork&lt;/code> 生成的，可以&lt;strong>共享主线程的所有内存数据&lt;/strong>。&lt;/p>
&lt;p>&lt;code>bgsave&lt;/code> 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，&lt;strong>如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本&lt;/strong>。然后，&lt;code>bgsave&lt;/code> 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。&lt;/p>
&lt;h4>写时复制&lt;span class="hx-absolute -hx-mt-20" id="写时复制">&lt;/span>
&lt;a href="#%e5%86%99%e6%97%b6%e5%a4%8d%e5%88%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>fork 时全量内存拷贝是难以接受的，假设需要在一个进程中通过 &lt;code>fork&lt;/code> 创建一个新的进程执行一段逻辑，&lt;code>fork&lt;/code> 拷贝的大量内存空间对于子进程来说可能完全没有任何作用的，但是却引入了巨大的额外开销。&lt;/p>
&lt;p>写时拷贝（Copy-on-Write）的出现就是为了解决这一问题，&lt;strong>写时拷贝的主要作用就是将拷贝推迟到写操作真正发生时&lt;/strong>，这也就避免了大量无意义的拷贝操作。在一些早期的 unix 系统上，系统调用 &lt;code>fork&lt;/code> 确实会立刻对父进程的内存空间进行复制，但是在今天的多数系统中，fork 并不会立刻触发这一过程。&lt;/p>
&lt;p>在 &lt;code>fork&lt;/code> 函数调用时，父进程和子进程会被 Kernel 分配到不同的虚拟内存空间中，所以在两个进程看来它们访问的是不同的内存。&lt;/p>
&lt;p>在&lt;strong>真正访问虚拟内存空间时，Kernel 会将虚拟内存映射到同一块物理内存上&lt;/strong>，所以父子进程共享了物理上的内存空间。&lt;/p>
&lt;p>当父进程或者子进程对共享的内存进行修改时，共享的内存才会&lt;strong>以页为单位进行拷贝&lt;/strong>，&lt;strong>父进程会保留原有的物理空间&lt;/strong>，而&lt;strong>子进程会使用拷贝后的新物理空间&lt;/strong>。&lt;/p>
&lt;h2>AOF 日志&lt;span class="hx-absolute -hx-mt-20" id="aof-日志">&lt;/span>
&lt;a href="#aof-%e6%97%a5%e5%bf%97" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>RDB 快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将修改的每一条指令记录进文件 &lt;code>appendonly.aof&lt;/code> 中 (先写入 os page cache，每隔一段时间 &lt;code>fsync&lt;/code> 到磁盘)。&lt;/p>
&lt;p>通过修改配置文件来打开 AOF 功能：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># appendonly yes&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>每当 Redis 执行一个改变数据集的命令时（比如 &lt;code>SET&lt;/code>）， 这个命令就会被追加到 AOF 文件的末尾。这样的话，当 Redis 重新启动时，程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。&lt;/p>
&lt;p>AOF 日志存储的是 Redis 服务器的&lt;strong>顺序指令&lt;/strong>序列，AOF 日志&lt;strong>只记录对内存进行修改的指令记录&lt;/strong>。&lt;/p>
&lt;h3>fsync&lt;span class="hx-absolute -hx-mt-20" id="fsync">&lt;/span>
&lt;a href="#fsync" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>AOF 日志是以文件的形式存在的，当程序对 AOF 日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后&lt;strong>内核会异步将脏数据刷到磁盘&lt;/strong>的。&lt;/p>
&lt;p>这就意味着如果机器突然宕机，AOF 日志内容可能还没有来得及完全刷到磁盘中，这个时候会丢失部分数据。&lt;/p>
&lt;p>为了避免这种情况，Redis 提供了三种 fsync 策略：&lt;/p>
&lt;ol>
&lt;li>&lt;code>appendfsync always&lt;/code>：每次有新命令追加到 AOF 文件时就执行一次 &lt;code>fsync&lt;/code> ，非常慢，也非常安全。&lt;/li>
&lt;li>&lt;code>appendfsync everysec&lt;/code>：每秒 &lt;code>fsync&lt;/code> 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。&lt;/li>
&lt;li>&lt;code>appendfsync no&lt;/code>：从不 &lt;code>fsync&lt;/code>，将数据交给操作系统来处理。更快，也更不安全的选择。&lt;/li>
&lt;/ol>
&lt;p>推荐（并且也是默认）的措施为&lt;strong>每秒 &lt;code>fsync&lt;/code> 一次， 这种 &lt;code>fsync&lt;/code> 策略可以兼顾速度和安全性&lt;/strong>。&lt;/p>
&lt;h3>AOF 重写&lt;span class="hx-absolute -hx-mt-20" id="aof-重写">&lt;/span>
&lt;a href="#aof-%e9%87%8d%e5%86%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>AOF 文件里可能有太多没用指令，所以 AOF 会定期根据内存的最新数据生成 &lt;code>aof&lt;/code> 文件。例如，执行了如下几条命令：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="m">1&lt;/span> 127.0.0.1:6379&amp;gt; incr readcount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3&lt;/span> 127.0.0.1:6379&amp;gt; incr readcount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">4&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">5&lt;/span> 127.0.0.1:6379&amp;gt; incr readcount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">6&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">7&lt;/span> 127.0.0.1:6379&amp;gt; incr readcount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">8&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">9&lt;/span> 127.0.0.1:6379&amp;gt; incr readcount
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">10&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">5&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>重写后 AOF 文件里变成：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>...
5 readcount
6 $1
7 5&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Redis 启动时如果既有 rdb 文件又有 aof 文件则优先选择 aof 文件恢复数据，因为一般来说 aof 中的数据更新一点。&lt;/p>
&lt;h4>自动重写&lt;span class="hx-absolute -hx-mt-20" id="自动重写">&lt;/span>
&lt;a href="#%e8%87%aa%e5%8a%a8%e9%87%8d%e5%86%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>下面两个配置可以控制 AOF 自动重写频率：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># auto‐aof‐rewrite‐min‐size 64mb // aof 文件至少要达到 64M 才会自动重写，文件太小恢复速度本来就很快，重写的意义不大&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># auto‐aof‐rewrite‐percentage 100 // aof 文件自上一次重写后文件大小增长了 100% 则再次触发重写&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>手动重写&lt;span class="hx-absolute -hx-mt-20" id="手动重写">&lt;/span>
&lt;a href="#%e6%89%8b%e5%8a%a8%e9%87%8d%e5%86%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>进入 Redis 客户端执行命令 &lt;code>bgrewriteaof&lt;/code> 可以手动重写 AOF 日志。其原理就是&lt;strong>开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令&lt;/strong>（比如添加一个 key，但是这时已经失效了，就不需要再添加到 AOF 日志中区），序列化到一个新的 AOF 日志文件中。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。&lt;/p>
&lt;h2>混合持久化&lt;span class="hx-absolute -hx-mt-20" id="混合持久化">&lt;/span>
&lt;a href="#%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>重启 Redis 时，一般很少使用 rdb 来恢复内存状态，因为会丢失大量数据。通常使用 AOF 日志重放，但是&lt;strong>重放 AOF 日志性能相对 rdb 来说要慢很多&lt;/strong>，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。&lt;/p>
&lt;p>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——&lt;strong>混合持久化&lt;/strong>。将 &lt;strong>rdb 文件的内容和增量的 AOF 日志文件存在一起&lt;/strong>。这里的 &lt;strong>AOF 日志不再是全量的日志，而是自 rdb 持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小&lt;/strong>。&lt;/p>
&lt;p>于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。&lt;/p>
&lt;p>开启混合持久化 (&lt;strong>必须先开启 aof&lt;/strong>)：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code># aof‐use‐rdb‐preamble yes&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>如果开启了&lt;strong>混合持久化，AOF 在重写时，不再是单纯将内存数据转换为 RESP 命令写入 AOF 文件，而是将重写这一刻之前的内存做 RDB 快照处理，并且将 RDB 快照内容和增量的 AOF（在重写时，和重写后新的命令执行）修改内存数据的命令存在一起，都写入新的 AOF 文件&lt;/strong>，新的文件一开始不叫 &lt;code>appendonly.aof&lt;/code>，等到重写完新的 AOF 文件才会进行改名，覆盖原有的 AOF 文件，完成新旧两个 AOF 文件的替换。&lt;/p>
&lt;p>于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。&lt;/p>
&lt;h2>Redis 数据备份策略&lt;span class="hx-absolute -hx-mt-20" id="redis-数据备份策略">&lt;/span>
&lt;a href="#redis-%e6%95%b0%e6%8d%ae%e5%a4%87%e4%bb%bd%e7%ad%96%e7%95%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>写 crontab 定时调度脚本，每小时都 copy 一份 rdb 或 aof 的备份到一个目录中去，仅仅保留最近 48 小时的备份。&lt;/li>
&lt;li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近 1 个月的备份。&lt;/li>
&lt;li>每次 copy 备份的时候，都把太旧的备份给删了。&lt;/li>
&lt;li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏。&lt;/li>
&lt;li>通常 &lt;strong>Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行&lt;/strong>，从节点是备份节点，没有来自客户端请求的压力。但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，所以在生产环境要做好实时监控工作，保证网络畅通或者能快速修复。&lt;/li>
&lt;/ol></description></item><item><title>集群</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/07_cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/07_cluster/</guid><description>
&lt;h2>CAP 原理&lt;span class="hx-absolute -hx-mt-20" id="cap-原理">&lt;/span>
&lt;a href="#cap-%e5%8e%9f%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ul>
&lt;li>C - Consistent ，一致性&lt;/li>
&lt;li>A - Availability ，可用性&lt;/li>
&lt;li>P - Partition tolerance ，分区容忍性&lt;/li>
&lt;/ul>
&lt;p>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着&lt;strong>网络分区&lt;/strong>。&lt;/p>
&lt;p>在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的&lt;strong>一致性&lt;/strong>将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲&lt;strong>可用性&lt;/strong>，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。&lt;/p>
&lt;p>一句话概括 CAP 原理就是——网络分区发生时，一致性和可用性两难全。&lt;/p>
&lt;h3>AP 架构&lt;span class="hx-absolute -hx-mt-20" id="ap-架构">&lt;/span>
&lt;a href="#ap-%e6%9e%b6%e6%9e%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>AP 架构是选择了&lt;strong>可用性&lt;/strong>和&lt;strong>分区容忍性&lt;/strong>。&lt;/p>
&lt;p>在 AP 架构中，分布式系统会设计成在网络分区发生时，仍然可以对外提供服务，即使此时数据的一致性无法满足。&lt;/p>
&lt;h3>CP 架构&lt;span class="hx-absolute -hx-mt-20" id="cp-架构">&lt;/span>
&lt;a href="#cp-%e6%9e%b6%e6%9e%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>CP 架构是选择了&lt;strong>一致性&lt;/strong>和&lt;strong>分区容忍性&lt;/strong>。&lt;/p>
&lt;p>在 CP 架构中，分布式系统会设计成在网络分区发生时，为了保证数据的一致性，失去联系的节点暂停对外提供服务，直到网络状况完全恢复正常再继续对外提供服务。&lt;/p>
&lt;p>Zookeeper 是一个典型的 CP 架构的分布式系统。&lt;/p>
&lt;h3>最终一致性&lt;span class="hx-absolute -hx-mt-20" id="最终一致性">&lt;/span>
&lt;a href="#%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis 保证&lt;strong>最终一致性&lt;/strong>，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。&lt;/p>
&lt;h2>主从同步&lt;span class="hx-absolute -hx-mt-20" id="主从同步">&lt;/span>
&lt;a href="#%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 支持&lt;strong>主从同步&lt;/strong>和&lt;strong>从从同步&lt;/strong>，从从同步功能是 Redis 后续版本增加的功能，为了减轻主库的同步负担。&lt;/p>
&lt;h3>Redis 主从架构搭建&lt;span class="hx-absolute -hx-mt-20" id="redis-主从架构搭建">&lt;/span>
&lt;a href="#redis-%e4%b8%bb%e4%bb%8e%e6%9e%b6%e6%9e%84%e6%90%ad%e5%bb%ba" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>1、复制一份redis.conf文件
2、将相关配置修改为如下值：
port 6380
pidfile /var/run/redis_6380.pid # 把 pid 进程号写入 pidfile 配置的文件
logfile &amp;#34;6380.log&amp;#34;
dir /usr/local/redis-5.0.3/data/6380 # 指定数据存放目录
# 需要注释掉 bind
# bind 127.0.0.1（bind 绑定的是自己机器网卡的 ip，如果有多块网卡可以配多个 ip，代表允许客户端通过机器的哪些网卡 ip 去访问，内网一般可以不配置 bind，注释掉即可）
3、配置主从复制
replicaof 192.168.0.60 6379 # 从本机 6379 的 Redis 实例复制数据，Redis 5.0之前使用 slaveof
replica-read-only yes # 配置从节点只读
4、启动从节点
redis-server redis.conf # redis.conf 文件务必用你复制并修改了之后的 redis.conf 文件
5、连接从节点
redis-cli -p 6380
6、测试在 6379 实例上写数据，6380 实例是否能及时同步新修改数据
7、可以自己再配置一个 6381 的从节点&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>主从同步原理&lt;span class="hx-absolute -hx-mt-20" id="主从同步原理">&lt;/span>
&lt;a href="#%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e5%8e%9f%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>如果你为 master 配置了一个 slave，不管这个 slave 是否是第一次连接上 master，它都会发送一个 &lt;code>PSYNC&lt;/code> 命令给 master 请求复制数据。&lt;/li>
&lt;li>master 收到 &lt;code>PSYNC&lt;/code> 命令后，会在后台进行数据持久化通过 &lt;strong>&lt;code>bgsave&lt;/code> 生成最新的 rdb 快照文件&lt;/strong>（这里的 rdb 与开不开启 rdb 持久化没有关系），持久化期间，master 会继续接收客户端的请求，它会把这些可能&lt;strong>修改数据集的请求缓存在内存中&lt;/strong>。&lt;/li>
&lt;li>当持久化进行完毕以后，master 会把这份 rdb 文件数据集发送给 slave。&lt;/li>
&lt;li>slave 会把接收到的数据进行持久化生成 rdb，然后再加载到内存中。&lt;/li>
&lt;li>然后，master 再将之前缓存在内存中的命令发送给 slave。&lt;/li>
&lt;li>当 master 与 slave 之间的连接由于某些原因而断开时，slave 能够自动重连 master，如果 master 收到了多个 slave 并发连接请求，它&lt;strong>只会进行一次持久化&lt;/strong>，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的 slave。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>为什么不使用 AOF 来做数据同步？&lt;/strong>&lt;/p>
&lt;p>因为 RDB 更快。RDB 是内存快照，而 AOF 是增量日志，重放是需要时间的，所以 RDB 更适合做数据同步。&lt;/p>
&lt;h4>增量同步&lt;span class="hx-absolute -hx-mt-20" id="增量同步">&lt;/span>
&lt;a href="#%e5%a2%9e%e9%87%8f%e5%90%8c%e6%ad%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存中，然后异步将内存中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一边向主节点反馈自己同步到哪里了 (offset)。&lt;/p>
&lt;p>因为内存的 buffer 是有限的，所以 Redis 主库不能将所有的指令都记录在内存 buffer 中。Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。&lt;/p>
&lt;h4>部分复制&lt;span class="hx-absolute -hx-mt-20" id="部分复制">&lt;/span>
&lt;a href="#%e9%83%a8%e5%88%86%e5%a4%8d%e5%88%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>就是说一个 slave 之前连接了 master，已经有部分数据了，后面又和 master 断开了连接，然后又重新连接上 master，master 会把断开连接期间修改的数据发送给 slave。&lt;/p>
&lt;p>master 会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据，&lt;strong>master 和它所有的 slave 都维护了复制的数据下标 offset 和 master 的进程 ID&lt;/strong>，因此，当网络连接断开重连后，slave 会请求 master 继续进行未完成的复制，从所记录的数据下标开始。如果 &lt;strong>master 进程 ID 变化了，或者从节点数据下标 offset 太旧&lt;/strong>，已经不在 master 的缓存队列里了，那么&lt;strong>将会进行一次全量数据的复制&lt;/strong>。&lt;/p>
&lt;h3>从从同步&lt;span class="hx-absolute -hx-mt-20" id="从从同步">&lt;/span>
&lt;a href="#%e4%bb%8e%e4%bb%8e%e5%90%8c%e6%ad%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>从从同步是从 Redis 3.0 开始支持的功能，它的出现主要是为了分担主节点的同步压力，在主从同步中，从节点也可以作为其他从节点的主节点，从而形成一个树状结构。为了缓解&lt;strong>主从复制风暴&lt;/strong> (多个从节点同时复制主节点导致主节点压力过大)。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-master-slave.png" alt="redis-master-slave" loading="lazy" />&lt;/p>
&lt;h2>Sentinel 哨兵架构&lt;span class="hx-absolute -hx-mt-20" id="sentinel-哨兵架构">&lt;/span>
&lt;a href="#sentinel-%e5%93%a8%e5%85%b5%e6%9e%b6%e6%9e%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 主从架构虽然可以实现数据的高可用，但是当主节点挂掉后，需要手动将从节点提升为主节点，这是一个比较麻烦的过程。&lt;/p>
&lt;p>为了解决这个问题，Redis 引入了 Sentinel 哨兵架构。&lt;/p>
&lt;p>Sentinel 是一个分布式架构，它由多个 Sentinel 实例组成，每个 Sentinel 实例都可以监控多个主从节点，它会持续监控主从节点的健康，当主节点挂掉后，它会自动选择一个最优的从节点切换为主节点。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-sentinel.png" alt="redis-sentinel" loading="lazy" />&lt;/p>
&lt;p>Sentinel 哨兵是特殊的 Redis 服务，&lt;strong>不提供读写服务，主要用来监控 Redis 实例节点&lt;/strong>。&lt;/p>
&lt;p>哨兵架构下 &lt;strong>Client 第一次要从哨兵获取到 Redis 的主节点，后续就直接访问 Redis 的主节点，不会每次都通过 Sentinel 代理访问 Redis 的主节点&lt;/strong>。当 Redis 的主节点发生变化，哨兵会第一时间感知到，并且将新的 Redis
主节点通知给 Client 端 (这里面 Redis 的 Client 一般都实现了订阅功能，订阅 Sentinel 发布的节点变动消息)。&lt;/p>
&lt;h3>Redis 哨兵架构搭建&lt;span class="hx-absolute -hx-mt-20" id="redis-哨兵架构搭建">&lt;/span>
&lt;a href="#redis-%e5%93%a8%e5%85%b5%e6%9e%b6%e6%9e%84%e6%90%ad%e5%bb%ba" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>1、复制一份 sentinel.conf 文件
cp sentinel.conf sentinel-26379.conf
2、将相关配置修改为如下值：
port 26379
daemonize yes
pidfile &amp;#34;/var/run/redis-sentinel-26379.pid&amp;#34;
logfile &amp;#34;26379.log&amp;#34;
dir &amp;#34;/usr/local/redis-5.0.3/data&amp;#34;
# sentinel monitor &amp;lt;master-redis-name&amp;gt; &amp;lt;master-redis-ip&amp;gt; &amp;lt;master-redis-port&amp;gt; &amp;lt;quorum&amp;gt;
# quorum 是一个数字，指明当有多少个 sentinel 认为一个 master 失效时(值一般为：sentinel总数/2 &amp;#43; 1)，master 才算真正失效
sentinel monitor mymaster 192.168.0.60 6379 2 # mymaster 这个名字随便取，客户端访问时会用到
3、启动 Sentinel 哨兵实例
src/redis-sentinel sentinel-26379.conf
4、查看 Sentinel 的 info 信息
src/redis-cli -p 26379
127.0.0.1:26379&amp;gt;info
可以看到 Sentinel 的 info 里已经识别出了 Redis 的主从
5、可以再配置两个 Sentinel，端口 26380 和 26381，注意上述配置文件里的对应数字都要修改&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Sentinel 集群都启动完毕后，会将哨兵集群的元数据信息写入所有 Sentinel 的配置文件里去(追加在文件的最下面)，查看下如下配置文件 &lt;code>sentinel-26379.conf&lt;/code>，如下所示：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sentinel known-replica mymaster 192.168.0.60 &lt;span class="m">6380&lt;/span> &lt;span class="c1"># 代表 Redis 主节点的从节点信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sentinel known-replica mymaster 192.168.0.60 &lt;span class="m">6381&lt;/span> &lt;span class="c1"># 代表 Redis 主节点的从节点信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sentinel known-sentinel mymaster 192.168.0.60 &lt;span class="m">26380&lt;/span> 52d0a5d70c1f90475b4fc03b6ce7c3c56935760f &lt;span class="c1"># 代表感知到的其它哨兵节点&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sentinel known-sentinel mymaster 192.168.0.60 &lt;span class="m">26381&lt;/span> e9f530d3882f8043f76ebb8e1686438ba8bd5ca6 &lt;span class="c1"># 代表感知到的其它哨兵节点&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>当 Redis 主节点如果挂了，哨兵集群会重新选举出新的 Redis 主节点，同时会修改所有 Sentinel 节点配置文件的集群元数据信息&lt;/strong>，比如 6379 的 Redis 如果挂了，假设选举出的新主节点是 6380，则 Sentinel 文件里的集群元数据信息会变成如下所示：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sentinel known-replica mymaster 192.168.0.60 &lt;span class="m">6379&lt;/span> &lt;span class="c1"># 代表主节点的从节点信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sentinel known-replica mymaster 192.168.0.60 &lt;span class="m">6381&lt;/span> &lt;span class="c1"># 代表主节点的从节点信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sentinel known-sentinel mymaster 192.168.0.60 &lt;span class="m">26380&lt;/span> 52d0a5d70c1f90475b4fc03b6ce7c3c56935760f &lt;span class="c1"># 代表感知到的其它哨兵节点&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sentinel known-sentinel mymaster 192.168.0.60 &lt;span class="m">26381&lt;/span> e9f530d3882f8043f76ebb8e1686438ba8bd5ca6 &lt;span class="c1"># 代表感知到的其它哨兵节点&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>同时还会修改 Sentinel 文件里之前配置的 mymaster 对应的 6379 端口，改为 6380&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sentinel monitor mymaster 192.168.0.60 &lt;span class="m">6380&lt;/span> &lt;span class="m">2&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>当 6379 的 Redis 实例再次启动时，哨兵集群根据集群元数据信息就可以将 6379 端口的 Redis 节点作为从节点加入集群。&lt;/p>
&lt;h2>Redis Cluster&lt;span class="hx-absolute -hx-mt-20" id="redis-cluster">&lt;/span>
&lt;a href="#redis-cluster" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 3.0 以前的版本要实现集群一般是借助哨兵来监控 master 节点的状态，如果 master 节点异常，则会做主从切换，将某一台 slave 作为 master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在&lt;strong>主从切换的瞬间存在访问瞬断&lt;/strong>的情况，而且&lt;strong>哨兵模式只有一个主节点对外提供服务&lt;/strong>，没法支持很高的并发，且&lt;strong>单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率（有可能会陷入快照同步的死循环）&lt;/strong>，一般推荐小于 10G。&lt;/p>
&lt;h3>Redis Cluster 架构&lt;span class="hx-absolute -hx-mt-20" id="redis-cluster-架构">&lt;/span>
&lt;a href="#redis-cluster-%e6%9e%b6%e6%9e%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis Cluster 是 Redis 官方提供的分布式集群方案。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-cluster.png" alt="redis-cluster" loading="lazy" />&lt;/p>
&lt;p>Redis 集群是一个由&lt;strong>多个主从节点&lt;/strong>组成的分布式服务器群，它具有复制、高可用和分片特性。Redis 集群不需要哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式&lt;strong>没有中心节点&lt;/strong>，可水平扩展，据官方文档称可以线性扩展到上万个节点 (&lt;strong>官方推荐不超过 1000 个节点&lt;/strong>)。Redis 集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。&lt;/p>
&lt;h3>Redis 集群搭建&lt;span class="hx-absolute -hx-mt-20" id="redis-集群搭建">&lt;/span>
&lt;a href="#redis-%e9%9b%86%e7%be%a4%e6%90%ad%e5%bb%ba" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis 集群需要至少三个 master 节点，这里搭建三个 master 节点，并且给每个 master 再搭建一个 slave 节点，总共 6 个 Redis 节点，这里用三台机器部署 6 个 Redis 实例，每台机器一主一从，搭建集群的步骤如下：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>第一步：在第一台机器的 /usr/local 下创建文件夹 redis-cluster，然后在其下面分别创建 2 个文件夾如下
（1）mkdir -p /usr/local/redis-cluster
（2）mkdir 8001 8004
第一步：把之前的 redis.conf 配置文件 copy 到 8001 下，修改如下内容：
（1）daemonize yes
（2）port 8001（分别对每个机器的端口号进行设置）
（3）pidfile /var/run/redis_8001.pid # 把 pid 进程号写入 pidfile 配置的文件
（4）dir /usr/local/redis-cluster/8001/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据）
（5）cluster-enabled yes（启动集群模式）
（6）cluster-config-file nodes-8001.conf（集群节点信息文件，这里 800x 最好和 port 对应上）
（7）cluster-node-timeout 10000
(8)# bind 127.0.0.1（bind 绑定的是自己机器网卡的 ip，如果有多块网卡可以配多个 ip，代表允许客户端通过机器的哪些网卡 ip 去访问，内网一般可以不配置 bind，注释掉即可）
(9) protected-mode no （关闭保护模式）
(10) appendonly yes
如果要设置密码需要增加如下配置：
(11) requirepass zhuge (设置 Redis 访问密码)
(12) masterauth zhuge (设置集群节点间访问密码，跟上面一致)
第三步：把修改后的配置文件，copy 到 8004，修改第 2、3、4、6 项里的端口号，可以用批量替换：
:%s/源字符串/目的字符串/g
第四步：另外两台机器也需要做上面几步操作，第二台机器用 8002 和 8005，第三台机器用 8003 和 8006
第五步：分别启动 6 个 Redis 实例，然后检查是否启动成功
（1）/usr/local/redis-5.0.3/src/redis-server /usr/local/redis-cluster/800*/redis.conf
（2）ps -ef | grep redis # 查看是否启动成功
第六步：用 redis-cli 创建整个 Redis 集群( Redis 5 以前的版本集群是依靠 ruby 脚本 redis-trib.rb 实现)
# 执行这条命令需要确认三台机器之间的 Redis 实例要能相互访问，可以先简单把所有机器防火墙关掉，如果不关闭防火墙则需要打开 Redis 服务端口和集群节点 gossip 通信端口 16379 (默认是在 Redis 端口号上加 10000)
# 关闭防火墙
# systemctl stop firewalld # 临时关闭防火墙
# systemctl disable firewalld # 禁止开机启动
# 注意：下面这条创建集群的命令大家不要直接复制，里面的空格编码可能有问题导致创建集群不成功
（1）/usr/local/redis-5.0.3/src/redis-cli -a zhuge --cluster create --cluster-replicas 1 192.168.0.61:8001 192.168.0.62:8002 192.168.0.63:8003 192.168.0.61:8004 192.168.0.62:8005 192.168.0.63:8006
# --cluster-replicas 1 表示为每个创建的主服务器节点创建一个从服务器节点，对于这里 6 个节点来说，就是 3 主 3 从
第七步：验证集群：
（1）连接任意一个客户端即可：./redis-cli -c -h -p (-a 访问服务端密码，-c 表示集群模式，指定 ip 地址和端口号）
如：/usr/local/redis-5.0.3/src/redis-cli -a zhuge -c -h 192.168.0.61 -p 800*
（2）进行验证： cluster info（查看集群信息）、cluster nodes（查看节点列表）
（3）进行数据操作验证
（4）关闭集群则需要逐个进行关闭，使用命令：
/usr/local/redis-5.0.3/src/redis-cli -a zhuge -c -h 192.168.0.60 -p 800* shutdown&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/cluster-slots.png" alt="cluster-slots" loading="lazy" />&lt;/p>
&lt;p>其中 &lt;code>slots&lt;/code> 就是分配给每个节点的槽位，只有主节点才会分配槽位。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-cluster-nodes.png" alt="redis-cluster-nodes" loading="lazy" />&lt;/p>
&lt;p>前面创建集群时，8001 和 8004 是在一个节点上的，8002 和 8005 是在一个节点上的，8003 和 8006 是在一个节点上的，但是上面的节点列表中，8001 是主节点，它的从节点却是 8005，8002 的从节点是 8006，8003 的从节点是 8004，这是为什么？&lt;/p>
&lt;p>因为更加安全，避免一个节点挂了导致小的主从集群不可用。&lt;/p>
&lt;p>&lt;code>cluster-config-file nodes-8001.conf&lt;/code> 集群创建好以后，整个集群节点的信息会被保存到这个配置文件中。&lt;/p>
&lt;p>&lt;strong>为什么要保存到这个文件中？&lt;/strong>&lt;/p>
&lt;p>因为如果整个集群如果关掉了，再次启动的时候是不能再使用 &lt;code>--cluster create&lt;/code> 命令的，只需要把每个节点的 Redis 重新启动即可。Redis 启动的时候会读取这个配置文件中的节点信息，然后再重新组件集群。&lt;/p>
&lt;h4>增加节点&lt;span class="hx-absolute -hx-mt-20" id="增加节点">&lt;/span>
&lt;a href="#%e5%a2%9e%e5%8a%a0%e8%8a%82%e7%82%b9" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>在 &lt;code>/usr/local/redis-cluster&lt;/code> 下创建 8007 和 8008 文件夹，并拷贝 8001 文件夹下的 &lt;code>redis.conf&lt;/code> 文件到 8007 和 8008 这两个文件夹下。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>mkdir 8007 8008
cd 8001
cp redis.conf /usr/local/redis-cluster/8007/
cp redis.conf /usr/local/redis-cluster/8008/
# 修改 8007 文件夹下的 redis.conf 配置文件
vim /usr/local/redis-cluster/8007/redis.conf
# 修改如下内容
port 8007
dir /usr/local/redis-cluster/8007/
cluster-config-file nodes-8007.conf
# 修改 8008 文件夹下的 redis.conf 配置文件
vim /usr/local/redis-cluster/8008/redis.conf
# 修改内容如下
port 8008
dir /usr/local/redis-cluster/8008/
cluster-config-file nodes-8008.conf
# 启动 8007 和 8008 俩个服务并查看服务状态
/usr/local/redis-5.0.3/src/redis-server /usr/local/redis-cluster/8007/redis.conf
/usr/local/redis-5.0.3/src/redis-server /usr/local/redis-cluster/8008/redis.conf
ps -el | grep redis&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>配置 8007 为集群主节点：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">/usr/local/redis-5.0.3/src/redis-cli -a zhuge --cluster add-node 192.168.0.61:8007 192.168.0.61:8001&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>使用 &lt;code>add-node&lt;/code> 命令新增一个主节点 8007 (master)，前面的 &lt;code>ip:port&lt;/code> 为新增节点，后面的 &lt;code>ip:port&lt;/code> 为已知存在节点，看到日志最后有 &amp;ldquo;[OK] New node added correctly&amp;rdquo; 提示代表新节点加入成功。&lt;/p>
&lt;p>当&lt;strong>添加节点成功以后，新增的节点不会有任何数据&lt;/strong>，因为它&lt;strong>还没有分配任何的 slot&lt;/strong>，我们需要为新节点手工分配 slot：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看集群状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/usr/local/redis-5.0.3/src/redis-cli -a zhuge -c -h 192.168.0.61 -p &lt;span class="m">8001&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">192.168.0.61:8001&amp;gt; cluster nodes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 为 8007 分配 hash 槽，找到集群中的任意一个主节点，对其进行重新分片工作&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/usr/local/redis-5.0.3/src/redis-cli -a zhuge --cluster reshard 192.168.0.61:8001&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>输出如下：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 需要多少个槽移动到新的节点上，自己设置，比如 600 个槽&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">How many slots &lt;span class="k">do&lt;/span> you want to move &lt;span class="o">(&lt;/span>from &lt;span class="m">1&lt;/span> to 16384&lt;span class="o">)&lt;/span>? &lt;span class="m">600&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 把这 600 个 hash 槽移动到哪个节点上去，需要指定节点 id&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">What is the receiving node ID? 2728a594a0498e98e4b83a537e19f9a0a3790f38
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Please enter all the &lt;span class="nb">source&lt;/span> node IDs.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  Type &lt;span class="s1">&amp;#39;all&amp;#39;&lt;/span> to use all the nodes as &lt;span class="nb">source&lt;/span> nodes &lt;span class="k">for&lt;/span> the &lt;span class="nb">hash&lt;/span> slots.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">  Type &lt;span class="s1">&amp;#39;done&amp;#39;&lt;/span> once you entered all the &lt;span class="nb">source&lt;/span> nodes IDs.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Source node 1:all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 输入 all 为从所有主节点 (8001,8002,8003) 中分别抽取相应的槽数指定到新节点中，抽取的总槽数为 600 个&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ... ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Do you want to proceed with the proposed reshard plan &lt;span class="o">(&lt;/span>yes/no&lt;span class="o">)&lt;/span>? yes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 输 入yes 确认开始执行分片任务&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>添加从节点 8008 到集群中去并查看集群状态：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">/usr/local/redis-5.0.3/src/redis-cli -a zhuge --cluster add-node 192.168.0.61:8008 192.168.0.61:8001&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>还是一个 master 节点，没有被分配任何的 hash 槽。&lt;strong>新加入的节点默认就是 master 节点&lt;/strong>。&lt;/p>
&lt;p>执行 &lt;code>replicate&lt;/code> 命令来指定当前节点(从节点)的主节点 id 为哪个,首先需要连接新加的 8008 节点的客户端，然后使用集群命令进行操作，把当前的 8008 (slave) 节点指定到一个主节点下：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">/usr/local/redis-5.0.3/src/redis-cli -a zhuge -c -h 192.168.0.61 -p &lt;span class="m">8008&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">192.168.0.61:8008&amp;gt; cluster replicate 2728a594a0498e98e4b83a537e19f9a0a3790f38 &lt;span class="c1">#后面这串 id 为 8007 的节点 id&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>集群相关命令&lt;span class="hx-absolute -hx-mt-20" id="集群相关命令">&lt;/span>
&lt;a href="#%e9%9b%86%e7%be%a4%e7%9b%b8%e5%85%b3%e5%91%bd%e4%bb%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;code>create&lt;/code>：创建一个集群环境。&lt;/li>
&lt;li>&lt;code>call&lt;/code>：可以执行 Redis 命令。&lt;/li>
&lt;li>&lt;code>add-node&lt;/code>：将一个节点添加到集群里，第一个参数为新节点的 &lt;code>ip:port&lt;/code> ，第二个参数为集群中任意一个已经存在的节点的 &lt;code>ip:port&lt;/code>。&lt;/li>
&lt;li>&lt;code>del-node&lt;/code>：移除一个节点。&lt;strong>删除主节点&lt;/strong>，必须先把该主节点的 hash 槽移动到其他主节点上，然后才能删除。&lt;/li>
&lt;li>&lt;code>reshard&lt;/code>：重新分片。&lt;/li>
&lt;li>&lt;code>check&lt;/code>：检查集群状态 。&lt;/li>
&lt;/ul>
&lt;h3>Redis 集群原理&lt;span class="hx-absolute -hx-mt-20" id="redis-集群原理">&lt;/span>
&lt;a href="#redis-%e9%9b%86%e7%be%a4%e5%8e%9f%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Redis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。&lt;/p>
&lt;p>&lt;strong>哨兵架构访问瞬断&lt;/strong>的问题在集群中也没有完全解决，但是因为集群中的&lt;strong>数据是分散存储在多个节点上的&lt;/strong>，所以当客户端访问某个节点时，如果这个节点挂了，并不会影响其他节点的数据。&lt;strong>只有这个集群内的小的主从集群会出现访问瞬断的情况&lt;/strong>。&lt;/p>
&lt;h4>槽位定位算法&lt;span class="hx-absolute -hx-mt-20" id="槽位定位算法">&lt;/span>
&lt;a href="#%e6%a7%bd%e4%bd%8d%e5%ae%9a%e4%bd%8d%e7%ae%97%e6%b3%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。&lt;/p>
&lt;p>Cluster 还允许用户强制某个 key 挂在特定槽位上，通过在 key 字符串里面嵌入 tag 标记，这就可以强制 key 所挂在的槽位等于 tag 所在的槽位。&lt;/p>
&lt;h4>跳转重定向&lt;span class="hx-absolute -hx-mt-20" id="跳转重定向">&lt;/span>
&lt;a href="#%e8%b7%b3%e8%bd%ac%e9%87%8d%e5%ae%9a%e5%90%91" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">GET x
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-MOVED &lt;span class="m">3999&lt;/span> 127.0.0.1:6381&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;code>MOVED&lt;/code> 指令的第一个参数 &lt;code>3999&lt;/code> 是 key 对应的槽位编号，后面是目标节点地址。&lt;code>MOVED&lt;/code> 指令前面有一个减号，表示该指令是一个错误消息。&lt;/p>
&lt;p>客户端收到 &lt;code>MOVED&lt;/code> 指令后，要立即纠正本地的槽位映射表。后续所有 key 将使用新的槽位映射表。&lt;/p>
&lt;h4>Redis 集群节点间的通信机制&lt;span class="hx-absolute -hx-mt-20" id="redis-集群节点间的通信机制">&lt;/span>
&lt;a href="#redis-%e9%9b%86%e7%be%a4%e8%8a%82%e7%82%b9%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1%e6%9c%ba%e5%88%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>Redis cluster 节点间采取 gossip 协议进行通信维护集群的元数据 (集群节点信息，主从角色，节点数量，各节点共享的数据等) 有两种方式：&lt;strong>集中式&lt;/strong>和 &lt;strong>gossip&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>集中式：
优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到；不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。很多中间件都会借助 zookeeper 集中式存储元数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>gossip：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>gossip 协议包含多种消息，包括 ping，pong，meet，fail 等等。 &lt;/p>
&lt;ul>
&lt;li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；&lt;/li>
&lt;li>ping：每个节点都会频繁给其他节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据(类似自己感知到的集群节点增加和移除，hash slot 信息等)； &lt;/li>
&lt;li>pong: 对 ping 和 meet 消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新； &lt;/li>
&lt;li>fail: 某个节点判断另一个节点 fail 之后，就发送 fail 给其他节点，通知其他节点，指定的节点宕机了。&lt;/li>
&lt;/ul>
&lt;p>gossip 协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力；缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。&lt;/p>
&lt;p>&lt;strong>gossip 通信的端口&lt;/strong>：
 
每个节点都有一个专门用于节点间 gossip 通信的端口，就是自己提供服务的 &lt;code>端口号+10000&lt;/code>，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 ping 消息，同时其他几点接收到 ping 消息之后返回 pong 消息。&lt;/p>
&lt;p>这也是为什么不推荐集群的节点超过 1000 个的原因，因为&lt;strong>集群内部节点的心跳通知非常频繁，这对网络带宽是一个非常大的消耗&lt;/strong>。&lt;/p>
&lt;h4>网络抖动&lt;span class="hx-absolute -hx-mt-20" id="网络抖动">&lt;/span>
&lt;a href="#%e7%bd%91%e7%bb%9c%e6%8a%96%e5%8a%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。&lt;/p>
&lt;p>为解决这种问题，Redis Cluster 提供了一种选项 &lt;code>cluster-node-timeout&lt;/code>，表示&lt;strong>当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换&lt;/strong>。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。&lt;/p>
&lt;h4>Redis 集群选举原理&lt;span class="hx-absolute -hx-mt-20" id="redis-集群选举原理">&lt;/span>
&lt;a href="#redis-%e9%9b%86%e7%be%a4%e9%80%89%e4%b8%be%e5%8e%9f%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>当 slave 发现自己的 master 变为 FAIL 状态时，便尝试进行 Failover，以期成为新的 master。由于挂掉的 master 可能会有多个 slave，从而存在多个 slave 竞争成为 master 节点的过程，其过程如下：&lt;/p>
&lt;ol>
&lt;li>slave 发现自己的 master 变为 FAIL&lt;/li>
&lt;li>将自己记录的集群 currentEpoch 加 1，并广播 &lt;code>FAILOVER_AUTH_REQUEST&lt;/code> 信息&lt;/li>
&lt;li>其他节点收到该信息，只有 master 响应，判断请求者的合法性，并发送 &lt;code>FAILOVER_AUTH_ACK&lt;/code>，对每一个 epoch 只发送一次 ack。&lt;/li>
&lt;li>尝试 failover 的 slave 收集 master 返回的 &lt;code>FAILOVER_AUTH_ACK&lt;/code>。&lt;/li>
&lt;li>slave 收到超过半数 master 的 ack 后变成新 master (这里解释了集群为什么至少需要三个主节点，&lt;strong>如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的&lt;/strong>)。&lt;/li>
&lt;li>slave 广播 Pong 消息通知其他集群节点。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>为了避免多个从节点在选举获得的票数一样&lt;/strong>：&lt;/p>
&lt;p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，&lt;strong>一定的延迟确保我们等待 FAIL 状态在集群中传播&lt;/strong>，slave 如果立即尝试选举，其它 masters 或许尚未意识到 FAIL 状态，可能会拒绝投票。&lt;/p>
&lt;p>&lt;strong>延迟计算公式&lt;/strong>：&lt;code>DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms&lt;/code>。&lt;/p>
&lt;p>&lt;code>SLAVE_RANK&lt;/code> 表示此 slave 已经从 master 复制数据的总量的 rank。Rank 越小代表已复制的数据越新。这种方式下，&lt;strong>持有最新数据的 slave 将会首先发起选举（理论上）&lt;/strong>。&lt;/p>
&lt;h3>集群脑裂数据丢失问题&lt;span class="hx-absolute -hx-mt-20" id="集群脑裂数据丢失问题">&lt;/span>
&lt;a href="#%e9%9b%86%e7%be%a4%e8%84%91%e8%a3%82%e6%95%b0%e6%8d%ae%e4%b8%a2%e5%a4%b1%e9%97%ae%e9%a2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>脑裂数据丢失问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时就会有数据丢失。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-brain-split.png" alt="redis-brain-split" loading="lazy" />&lt;/p>
&lt;p>Redis 可以通过配置 &lt;code>min-slaves-to-write&lt;/code> 参数来规避脑裂数据丢失问题 （这种方法不可能百分百避免数据丢失，参考集群 master 选举机制）：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>// 写数据成功最少同步的 slave 数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置 1，加上 master 就是 2，超过了半数（也就是说至少要有一个从节点同步成功之后，才会返回客户端写入成功）。
// 该参数在 Redis 最新版本里名字已经换成了 min-replicas-to-write。
min-slaves-to-write 1  &lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">&lt;strong>这个配置在一定程度上会影响集群的可用性，比如 slave 要是少于 1 个，这个集群就算 master 正常也不能提供服务了&lt;/strong>，需要具体场景权衡选择。一般情况下可以不用考虑这个配置，可用性是更重要的，丢一点缓存数据是可以接受的。如果因为 Redis 不可用，导致大量请求打到数据库，数据库可能会直接挂掉，这是无法接受的。&lt;/div>
&lt;/div>
&lt;/div>
&lt;h3>主从复制数据丢失问题&lt;span class="hx-absolute -hx-mt-20" id="主从复制数据丢失问题">&lt;/span>
&lt;a href="#%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e6%95%b0%e6%8d%ae%e4%b8%a2%e5%a4%b1%e9%97%ae%e9%a2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>一样是通过 &lt;code>min-slaves-to-write&lt;/code> 参数来规避：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="na">min-slaves-to-write 1  &lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>主节点必须在指定数量的从节点确认同步后，才返回写入成功&lt;/strong>。降低数据丢失风险。&lt;/p>
&lt;p>缺点：&lt;strong>写入延迟增加&lt;/strong>，如果从节点宕机或延迟高，主节点会拒绝写入。影响集群的可用性。&lt;/p>
&lt;h3>集群是否完整才能对外提供服务&lt;span class="hx-absolute -hx-mt-20" id="集群是否完整才能对外提供服务">&lt;/span>
&lt;a href="#%e9%9b%86%e7%be%a4%e6%98%af%e5%90%a6%e5%ae%8c%e6%95%b4%e6%89%8d%e8%83%bd%e5%af%b9%e5%a4%96%e6%8f%90%e4%be%9b%e6%9c%8d%e5%8a%a1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>当 &lt;code>redis.conf&lt;/code> 的配置 &lt;code>cluster-require-full-coverage&lt;/code> 为 &lt;code>no&lt;/code> 时，表示当负责一部分插槽的 master 节点下线且没有相应的 slave 节点进行故障恢复时，集群仍然可用，如果为 &lt;code>yes&lt;/code> 则集群不可用。&lt;/p>
&lt;h3>Redis 集群为什么至少需要三个 master 节点，并且推荐节点数为奇数？&lt;span class="hx-absolute -hx-mt-20" id="redis-集群为什么至少需要三个-master-节点并且推荐节点数为奇数">&lt;/span>
&lt;a href="#redis-%e9%9b%86%e7%be%a4%e4%b8%ba%e4%bb%80%e4%b9%88%e8%87%b3%e5%b0%91%e9%9c%80%e8%a6%81%e4%b8%89%e4%b8%aa-master-%e8%8a%82%e7%82%b9%e5%b9%b6%e4%b8%94%e6%8e%a8%e8%8d%90%e8%8a%82%e7%82%b9%e6%95%b0%e4%b8%ba%e5%a5%87%e6%95%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>因为新 master 的选举需要大于半数的集群 master 节点同意才能选举成功，如果只有两个 master 节点，当其中一个挂了，是达不到选举新 master 的条件的。&lt;/p>
&lt;p>奇数个 master 节点可以在满足选举该条件的基础上节省一个节点，比如三个 master 节点和四个 master 节点的集群相比，如果都挂了一个 master 节点，三个 master 节点的集群只需要两个节点就可以选举，而四个 master 节点的集群需要三个节点（过半）才能选举 。所以&lt;strong>三个 master 节点和四个 master 节点的集群都只能挂一个节点&lt;/strong>。如果都挂了两个 master 节点都没法选举新 master 节点了，所以奇数的 master 节点更多的是从节省机器资源角度出发说的。&lt;/p>
&lt;h3>Redis 集群对批量操作命令的支持&lt;span class="hx-absolute -hx-mt-20" id="redis-集群对批量操作命令的支持">&lt;/span>
&lt;a href="#redis-%e9%9b%86%e7%be%a4%e5%af%b9%e6%89%b9%e9%87%8f%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4%e7%9a%84%e6%94%af%e6%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>对于 Redis 集群，批量操作命令一定要在集群上操作，因为在集群中多个 key 可能是不同的 master 节点的 slot 上，或者在同一个 master 节点的不同的 slot 上，&lt;strong>客户端&lt;/strong>会直接返回错误。这是由于 Redis 要保证批量操作命令的原子性，要么全部成功，要么全部失败。&lt;strong>在不同的 master 节点上操作，如果其中的一个 master 节点挂了，会导致有些 key 写入成功，有些 key 写入失败，这就破坏了原子性&lt;/strong>。&lt;/p>
&lt;p>为了解决这个问题，则可以在 key 的前面加上 &lt;code>{XX}&lt;/code>，这样参数数据分片 hash 计算的只会是大括号里的值，这样能确保不同的 key 能落到同一 slot 里去，示例如下：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>mset {user1}:1:name zhuge {user1}:1:age 18&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>假设 name 和 age 计算的 hash slot 值不一样，但是这条命令在集群下执行，Redis 只会用大括号里的 &lt;code>user1&lt;/code> 做 hash slot 计算，所以算出来的 slot 值肯定相同，最后都能落在同一 slot。&lt;/p>
&lt;h3>为什么是 16384 个槽位？&lt;span class="hx-absolute -hx-mt-20" id="为什么是-16384-个槽位">&lt;/span>
&lt;a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af-16384-%e4%b8%aa%e6%a7%bd%e4%bd%8d" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>如果槽位为 65536，发送心跳信息的消息头达 8KB，发送的心跳包过于庞大。&lt;/li>
&lt;/ol>
&lt;p>当槽位为 65536 时，这块的大小是 &lt;code>65536 / 8 / 1024= 8kb&lt;/code>。因为每秒钟，Redis 节点需要发送一定数量的 ping 消息作为心跳包，如果槽位为 65536，这个 ping 消息的消息头太大了，会导致网络拥堵。&lt;/p>
&lt;ol start="2">
&lt;li>Redis 的集群主节点数量官方建议不超过 1000 个。&lt;/li>
&lt;/ol>
&lt;p>集群节点越多，心跳包的消息体内携带的数据越多。如果节点过 1000 个，也会导致网络拥堵。因此官方不建议 Redis cluster 节点数量超过 1000 个。那么，对于节点数在 1000 以内的 Redis cluster 集群，16384 个槽位够用了。没有必要拓展到 65536 个。&lt;/p>
&lt;ol start="3">
&lt;li>槽位越小，节点少的情况下，压缩率高&lt;/li>
&lt;/ol>
&lt;p>Redis 主节点的配置信息中，它所负责的哈希槽是通过一张 bitmap 的形式来保存的，在传输过程中，会对 bitmap 进行压缩，但是如果 bitmap 的填充率 &lt;code>slots / N&lt;/code> 很高的话(&lt;code>N&lt;/code> 表示节点数)，bitmap 的压缩率就很低。如果节点数很少，而哈希槽数量很多的话，bitmap 的压缩率就很低。&lt;/p>
&lt;h2>Redis 7.0&lt;span class="hx-absolute -hx-mt-20" id="redis-70">&lt;/span>
&lt;a href="#redis-70" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 7.0 对主从复制进行了优化，性能有了很大的提升。&lt;/p>
&lt;h3>Redis 7.0 之前的主从复制的问题&lt;span class="hx-absolute -hx-mt-20" id="redis-70-之前的主从复制的问题">&lt;/span>
&lt;a href="#redis-70-%e4%b9%8b%e5%89%8d%e7%9a%84%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e7%9a%84%e9%97%ae%e9%a2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>多从库时主库内存占用过多&lt;span class="hx-absolute -hx-mt-20" id="多从库时主库内存占用过多">&lt;/span>
&lt;a href="#%e5%a4%9a%e4%bb%8e%e5%ba%93%e6%97%b6%e4%b8%bb%e5%ba%93%e5%86%85%e5%ad%98%e5%8d%a0%e7%94%a8%e8%bf%87%e5%a4%9a" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>Redis 的主从复制主要分为两步：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>全量同步&lt;/strong>，主库通过 &lt;code>fork&lt;/code> 子进程产生内存快照，然后将数据序列化为 RDB 格式同步到从库，使从库的数据与主库某一时刻的数据一致。&lt;/li>
&lt;li>&lt;strong>命令传播&lt;/strong>：全量同步期间，master 会继续接收客户端的请求，它会把这些可能&lt;strong>修改数据集的请求缓存在内存中&lt;/strong>。当从库与主库完成全量同步后，进入命令传播阶段，主库将变更数据的命令发送到从库，从库将执行相应命令，使从库与主库数据持续保持一致。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-replication.png" alt="redis-replication" loading="lazy" />&lt;/p>
&lt;p>&lt;strong>复制积压区，可以理解为是一个备份&lt;/strong>，因为主从复制的过程中，如果从库的连接突然断开了，那么从库对应的&lt;strong>从库复制缓冲区&lt;/strong>会被释放掉，包括其他的网络资源。等到从库重新连接时，重新开始复制，就刻意从复制积压区找到断开连接时数据复制的位置，从这个断开的位置开始继续复制。&lt;/p>
&lt;p>如上图所示，对于 Redis 主库，当用户的写请求到达时，主库会将变更命令分别写入所有&lt;strong>从库复制缓冲区&lt;/strong>（OutputBuffer)，以及&lt;strong>复制积压区&lt;/strong> (ReplicationBacklog)。&lt;/p>
&lt;p>该实现一个明显的问题是内存占用过多，所有从库的连接在主库上是独立的，也就是说&lt;strong>每个从库 OutputBuffer 占用的内存空间也是独立的&lt;/strong>，那么&lt;strong>主从复制消耗的内存就是所有从库缓冲区内存大小之和&lt;/strong>。如果我们设定从库的 &lt;code>client-output-buffer-limit&lt;/code> 为 1GB，如果有三个从库，则在主库上可能会消耗 3GB 的内存用于主从复制。另外，&lt;strong>真实环境中从库的数量不是确定的，这也导致 Redis 实例的内存消耗不可控&lt;/strong>。&lt;/p>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">当全量复制的时间过长或者 &lt;code>client-output-buffer-limit&lt;/code> 设置的 buffer 过小，会导致增量的指令在 buffer 中被覆盖，导致全量复制后无法进行增量复制，然后会再次发起快照同步，如此极有可能会陷入快照同步的死循环。&lt;/div>
&lt;/div>
&lt;/div>
&lt;h4>OutputBuffer 拷贝和释放的堵塞问题&lt;span class="hx-absolute -hx-mt-20" id="outputbuffer-拷贝和释放的堵塞问题">&lt;/span>
&lt;a href="#outputbuffer-%e6%8b%b7%e8%b4%9d%e5%92%8c%e9%87%8a%e6%94%be%e7%9a%84%e5%a0%b5%e5%a1%9e%e9%97%ae%e9%a2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>Redis 为了提升多从库全量复制的效率和减少 fork 产生 RDB 的次数，会尽可能的让多个从库共用一个 RDB，从代码 (&lt;code>replication.c&lt;/code>) 上看：&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-copy-output-buffer.png" alt="redis-copy-output-buffer" loading="lazy" />&lt;/p>
&lt;p>当已经有一个从库触发 RDB BGSAVE 时，后续需要全量同步的从库会共享这次 BGSAVE 的 RDB，为了从库复制数据的完整性，会将第一个触发 RDB BGSAVE 从库的 OutputBuffer 拷贝到后续请求全量同步从库的 OutputBuffer 中。&lt;/p>
&lt;p>代码中的 &lt;code>copyClientOutputBuffer&lt;/code> 可能存在堵塞问题，因为 OutputBuffer 链表上的数据可达数百 MB 甚至数 GB 之多，对其拷贝的耗时可能达到百毫秒甚至秒级的时间，而且该堵塞问题没法通过日志或者 latency 观察到，但对 Redis 性能影响却很大，甚至造成 Redis 阻塞。&lt;/p>
&lt;p>同样地，当 OutputBuffer 大小触发 limit 限制时，Redis 就是关闭该从库链接，而在释放 OutputBuffer 时，也需要释放数百 MB 甚至数 GB 的数据，其耗时对 Redis 而言也很长。&lt;/p>
&lt;p>而且如果重新设置 ReplicationBacklog 大小时，Redis 会重新申请一块内存，然后将 ReplicationBacklog 中的内容拷贝过去，这也是非常耗时的操作。&lt;/p>
&lt;h4>ReplicationBacklog 的限制&lt;span class="hx-absolute -hx-mt-20" id="replicationbacklog-的限制">&lt;/span>
&lt;a href="#replicationbacklog-%e7%9a%84%e9%99%90%e5%88%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>复制积压缓冲区 ReplicationBacklog 是 Redis 实现部分重同步的基础，如果从库可以进行增量同步，则主库会从 ReplicationBacklog 中拷贝从库缺失的数据到其 OutputBuffer。拷贝的数据量最大当然是 ReplicationBacklog 的大小，为了避免拷贝数据过多的问题，通常不会让该值过大，一般百兆左右。但在大容量实例中，为了避免由于主从网络中断导致的全量同步，又希望该值大一些，这就存在矛盾了。&lt;/p>
&lt;h4>Redis 7.0 主从复制的优化&lt;span class="hx-absolute -hx-mt-20" id="redis-70-主从复制的优化">&lt;/span>
&lt;a href="#redis-70-%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e7%9a%84%e4%bc%98%e5%8c%96" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>每个从库都有自己的 OutputBuffer，但其存储的内容却是一样的，一个最直观的想法就是主库在命令传播时，将这些命令放在一个全局的复制数据缓冲区中，多个从库共享这份数据。复制积压缓冲区（ReplicationBacklog）中的内容与从库 OutputBuffer 中的数据也是一样的，所以该方案中，ReplicationBacklog 和从库一样共享一份复制缓冲区的数据，也避免了 ReplicationBacklog 的内存开销。&lt;/p>
&lt;p>&lt;strong>共享复制缓存区&lt;/strong>方案中复制缓冲区 (ReplicationBuffer) 的表示采用&lt;strong>链表&lt;/strong>的表示方法，将 ReplicationBuffer 数据切割为多个 16KB 的数据块 (&lt;code>replBufBlock&lt;/code>)，然后使用链表来维护起来。为了维护不同从库的对 ReplicationBuffer 的使用信息，在 &lt;code>replBufBlock&lt;/code> 中存在字段：&lt;/p>
&lt;ul>
&lt;li>&lt;code>refcount&lt;/code>：block 被引用的次数。&lt;/li>
&lt;li>&lt;code>id&lt;/code>：block 的 id。&lt;/li>
&lt;li>&lt;code>repl_offset&lt;/code>：block 中数据的偏移量。&lt;/li>
&lt;/ul>
&lt;p>ReplicationBuffer 由多个 &lt;code>replBufBlock&lt;/code> 组成链表，当&lt;strong>复制积压区&lt;/strong>或从库对某个 block 使用时，便对正在使用的 &lt;code>replBufBlock&lt;/code> 增加引用计数，上图中可以看到，复制积压区正在使用的 replBufBlock &lt;code>refcount&lt;/code> 是 1，从库 A 和 B 正在使用的 &lt;code>replBufBlock&lt;/code> 的 &lt;code>refcount&lt;/code> 是 2。当从库使用完当前的 &lt;code>replBufBlock&lt;/code>（已经将数据发送给从库）时，就会对其 &lt;code>refcount&lt;/code> 减 1 而且移动到下一个 &lt;code>replBufBlock&lt;/code>，并对其 &lt;code>refcount&lt;/code> 加 1。&lt;/p>
&lt;h5>堵塞问题和限制问题的解决&lt;span class="hx-absolute -hx-mt-20" id="堵塞问题和限制问题的解决">&lt;/span>
&lt;a href="#%e5%a0%b5%e5%a1%9e%e9%97%ae%e9%a2%98%e5%92%8c%e9%99%90%e5%88%b6%e9%97%ae%e9%a2%98%e7%9a%84%e8%a7%a3%e5%86%b3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>多从库消耗内存过多的问题通过共享复制缓存区方案得到了解决，对于 OutputBuffer 拷贝和释放的堵塞问题和 ReplicationBacklog 的限制问题是否解决了？&lt;/p>
&lt;p>首先来看 OutputBuffer 拷贝和释放的堵塞问题问题，这个问题很好解决，因为 ReplicationBuffer 是个链表实现，当前从库的 OutputBuffer 只需要维护共享 ReplicationBuffer 的引用信息即可。所以无需进行数据深拷贝，只需要更新引用信息，即对正在使用的 &lt;code>replBufBlock&lt;/code> 的 &lt;code>refcount&lt;/code> 加 1，这仅仅是一条简单的赋值操作，非常轻量。&lt;/p>
&lt;p>OutputBuffer 释放问题呢？在当前的方案中释放从库 OutputBuffer 就变成了对其正在使用的 &lt;code>replBufBlock&lt;/code> 的 &lt;code>refcount&lt;/code> 减 1，也是一条赋值操作，不会有任何阻塞。&lt;/p>
&lt;p>对于 ReplicationBacklog 的限制问题也很容易解决了，因为 ReplicatonBacklog 也只是记录了对 ReplicationBuffer 的引用信息，对 ReplicatonBacklog 的拷贝也仅仅成了找到正确的 &lt;code>replBufBlock&lt;/code>，然后对其 &lt;code>refcount&lt;/code> 加 1。这样的话就不用担心 ReplicatonBacklog 过大导致的拷贝堵塞问题。而且对 ReplicatonBacklog 大小的变更也仅仅是配置的变更，不会清掉数据。&lt;/p>
&lt;h5>ReplicationBuffer 的裁剪和释放&lt;span class="hx-absolute -hx-mt-20" id="replicationbuffer-的裁剪和释放">&lt;/span>
&lt;a href="#replicationbuffer-%e7%9a%84%e8%a3%81%e5%89%aa%e5%92%8c%e9%87%8a%e6%94%be" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>ReplicationBuffer 不可能无限增长，Redis 有相应的逻辑对其进行裁剪，简单来说，Redis 会从头访问 &lt;code>replBufBlock&lt;/code> 链表，如果发现 &lt;code>replBufBlock&lt;/code> 的 &lt;code>refcount&lt;/code> 为 0，则会释放它，直到迭代到第一个 &lt;code>replBufBlock&lt;/code> 的 &lt;code>refcount&lt;/code> 不为 0 才停止。所以想要释放 ReplicationBuffer，只需要减少相应 &lt;code>replBufBlock&lt;/code> 的 &lt;code>refcount&lt;/code>，会减少 &lt;code>refcount&lt;/code> 的主要情况有：&lt;/p>
&lt;ol>
&lt;li>当从库使用完当前的 &lt;code>replBufBlock&lt;/code> 会对其 &lt;code>refcount&lt;/code> 减 1；&lt;/li>
&lt;li>当从库断开链接时会对正在引用的 &lt;code>replBufBlock&lt;/code> 的 &lt;code>refcount&lt;/code> 减 1，无论是因为超过 &lt;code>client-output-buffer-limit&lt;/code> 导致的断开还是网络原因导致的断开；
3、当 ReplicationBacklog 引用的 &lt;code>replBufBlock&lt;/code> 数据量超过设置的该值大小时，会对正在引用的 &lt;code>replBufBlock&lt;/code> 的 &lt;code>refcount&lt;/code> 减 1，以尝试释放内存；&lt;/li>
&lt;/ol>
&lt;p>不过当一个从库引用的 &lt;code>replBufBlock&lt;/code> 过多，它断开时释放的 &lt;code>replBufBlock &lt;/code>可能很多，也可能造成堵塞问题，所以 Redis7 里会限制一次释放的个数，未及时释放的内存在系统的定时任务中渐进式释放。&lt;/p>
&lt;h5>数据结构的选择&lt;span class="hx-absolute -hx-mt-20" id="数据结构的选择">&lt;/span>
&lt;a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%9a%84%e9%80%89%e6%8b%a9" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>当从库尝试与主库进行增量重同步时，会发送自己的 &lt;code>repl_offset&lt;/code>，主库在每个 &lt;code>replBufBlock&lt;/code> 中记录了该其第一个字节对应的 &lt;code>repl_offset&lt;/code>，但如何高效地从数万个 &lt;code>replBufBlock&lt;/code> 的链表中找到特定的那个？&lt;/p>
&lt;p>链表只能直接从头到位遍历链表查找对应的 &lt;code>replBufBlock&lt;/code>，这个操作必然会耗费较多时间而堵塞服务。&lt;/p>
&lt;p>Redis 7 使用 rax 树实现了对 &lt;code>replBufBlock&lt;/code> 固定区间间隔的索引，每 64 个记录一个索引点。一方面，rax 索引占用的内存较少；另一方面，查询效率也是非常高，理论上查找比较次数不会超过 100，耗时在 1 毫秒以内。&lt;/p>
&lt;h5>RAX 树&lt;span class="hx-absolute -hx-mt-20" id="rax-树">&lt;/span>
&lt;a href="#rax-%e6%a0%91" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>Redis 中还有其他地方使用了 Rax 树，比如 streams 这个类型里面的 consumer group (消费者组) 的名称还有和 Redis 集群名称存储。&lt;/p>
&lt;p>RAX 叫做&lt;strong>基数树（前缀压缩树）&lt;/strong>，就是有相同前缀的字符串，其前缀可以作为一个公共的父节点，什么又叫前缀树？&lt;/p>
&lt;p>&lt;strong>Trie 树&lt;/strong>&lt;/p>
&lt;p>即&lt;strong>字典树&lt;/strong>，也有的称为前缀树，是一种树形结构。广泛应用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。&lt;/p>
&lt;p>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。&lt;/p>
&lt;p>先看一下几个场景问题：&lt;/p>
&lt;ol>
&lt;li>我们输入 n 个单词，每次查询一个单词，需要回答出这个单词是否在之前输入的 n 单词中出现过。&lt;/li>
&lt;/ol>
&lt;p>答：当然是用 map 来实现。&lt;/p>
&lt;ol start="2">
&lt;li>我们输入 n 个单词，每次查询一个单词的前缀，需要回答出这个前缀是之前输入的 n 单词中多少个单词的前缀？&lt;/li>
&lt;/ol>
&lt;p>答：还是可以用 map 做，把输入 n 个单词中的每一个单词的前缀分别存入 map 中，然后计数，这样的话复杂度会非常的高。若有 n 个单词，平均每个单词的长度为 c，那么复杂度就会达到 &lt;code>n*c&lt;/code>。&lt;/p>
&lt;p>因此我们需要更加高效的数据结构，这时候就是 Trie 树的用武之地了。现在我们通过例子来理解什么是 Trie 树。现在我们对 cat、cash、apple、aply、ok 这几个单词建立一颗Trie 树。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-trie.png" alt="redis-trie" loading="lazy" />&lt;/p>
&lt;p>从图中可以看出：&lt;/p>
&lt;ol>
&lt;li>每一个节点代表一个字符&lt;/li>
&lt;li>有相同前缀的单词在树中就有公共的前缀节点。&lt;/li>
&lt;li>整棵树的根节点是空的。&lt;/li>
&lt;li>每个节点结束的时候用一个特殊的标记来表示，这里用 &lt;code>-1&lt;/code> 来表示结束，从根节点到 &lt;code>-1&lt;/code> 所经过的所有的节点对应一个英文单词。&lt;/li>
&lt;li>查询和插入的时间复杂度为 &lt;code>O(k)&lt;/code>，k 为字符串长度，当然如果大量字符串没有共同前缀时还是很耗内存的。&lt;/li>
&lt;/ol>
&lt;p>所以，总的来说，Trie 树把很多的公共前缀独立出来共享了。这样避免了很多重复的存储。想想字典集的方式，一个个的key被单独的存储，即使他们都有公共的前缀也要单独存储。相比字典集的方式，Trie 树显然节省更多的空间。&lt;/p>
&lt;p>Trie 树其实依然比较浪费空间，比如前面所说的“如果大量字符串没有共同前缀时”。比如这个字符串列表：&amp;ldquo;deck&amp;rdquo;, &amp;ldquo;did&amp;rdquo;, &amp;ldquo;doe&amp;rdquo;, &amp;ldquo;dog&amp;rdquo;, &amp;ldquo;doge&amp;rdquo; , &amp;ldquo;dogs&amp;rdquo;。&amp;ldquo;deck&amp;rdquo; 这一个分支，有没有必要一直往下来拆分吗？还有 &amp;ldquo;did&amp;rdquo;，存在着一样的问题。像这样的不可分叉的单支分支，其实完全可以合并，也就是压缩。&lt;/p>
&lt;p>&lt;strong>Radix 树：压缩后的 Trie 树&lt;/strong>&lt;/p>
&lt;p>所以 Radix 树就是压缩后的 Trie 树，因此也叫&lt;strong>压缩 Trie 树&lt;/strong>。比如上面的字符串列表完全可以这样存储：&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redis-rax.png" alt="redis-rax" loading="lazy" />&lt;/p>
&lt;p>同时在具体存储上，Radix 树的处理是以 bit（或二进制数字）来读取的。一次被对比 r 个 bit。&lt;/p>
&lt;p>比如 &amp;ldquo;dog&amp;rdquo;, &amp;ldquo;doge&amp;rdquo; , &amp;ldquo;dogs&amp;rdquo;，按照人类可读的形式，dog 是 dogs 和 doge 的子串。但是如果按照计算机的二进制比对：&lt;/p>
&lt;p>dog: 01100100 01101111 01100111&lt;/p>
&lt;p>doge: 01100100 01101111 01100111 011&lt;font color="red">0&lt;/font>0101&lt;/p>
&lt;p>dogs: 01100100 01101111 01100111 011&lt;font color="red">1&lt;/font>0011&lt;/p>
&lt;p>可以发现 dog 和 doge 是在第二十五位的时候不一样的。dogs 和 doge 是在第二十八位不一样的。也就是说，从二进制的角度还可以进一步进行压缩。把第二十八位前面相同的 &lt;code>011&lt;/code> 进一步压缩。&lt;/p></description></item><item><title>分布式锁</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/08_distributed-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/08_distributed-lock/</guid><description>
&lt;p>分布式锁是用来解决并发问题的。比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。&lt;/p>
&lt;p>分布式锁本质上要实现的目标就是在 Redis 里面&lt;strong>占一个坑，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试&lt;/strong>。&lt;/p>
&lt;p>分布式锁一般是使用 &lt;code>SETNX&lt;/code> 命令实现，&lt;code>SETNX&lt;/code> 命令的作用是设置一个键值对，如果键不存在，则设置成功，返回 &lt;code>1&lt;/code>；如果键已经存在，则设置失败，返回 &lt;code>0&lt;/code>。释放锁可以使用 &lt;code>DEL&lt;/code> 命令删除键值对。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 加锁&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SETNX lock:order:&lt;span class="o">{&lt;/span>id&lt;span class="o">}&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 解锁&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DEL lock:order:&lt;span class="o">{&lt;/span>id&lt;span class="o">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>仅仅这么设置是不够的，因为如果逻辑执行到中间出现异常了，&lt;code>DEL&lt;/code> 没有被调用那么锁就会一直存在，导致其他线程无法获取锁，导致死锁。&lt;/p>
&lt;p>为了避免这种情况，可以使用 &lt;code>EXPIRE&lt;/code> 命令设置锁的过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 加锁并设置过期时间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SETNX lock:order:&lt;span class="o">{&lt;/span>id&lt;span class="o">}&lt;/span> &lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">EXPIRE lock:order:&lt;span class="o">{&lt;/span>id&lt;span class="o">}&lt;/span> &lt;span class="m">5&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>但是这样也会有问题，因为 &lt;code>SETNX&lt;/code> 和 &lt;code>EXPIRE&lt;/code> 是两个命令，它们不是原子性的，如果 &lt;code>SETNX&lt;/code> 成功了，但是 &lt;code>EXPIRE&lt;/code> 失败了，那么锁就会一直存在，导致死锁。&lt;/p>
&lt;p>为了避免这种情况，Redis 2.8 版本中加入了 &lt;code>SET&lt;/code> 指令的扩展参数，使得 &lt;code>SETNX&lt;/code> 和 &lt;code>EXPIRE&lt;/code> 可以一起执行。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 加锁并设置过期时间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET lock:order:&lt;span class="o">{&lt;/span>id&lt;span class="o">}&lt;/span> &lt;span class="nb">true&lt;/span> EX &lt;span class="m">5&lt;/span> NX&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>这样就可以保证 &lt;code>SETNX&lt;/code> 和 &lt;code>EXPIRE&lt;/code> 是原子性的，要么都执行成功，要么都执行失败。&lt;/p>
&lt;h2>超时问题&lt;span class="hx-absolute -hx-mt-20" id="超时问题">&lt;/span>
&lt;a href="#%e8%b6%85%e6%97%b6%e9%97%ae%e9%a2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>上面的加锁方式，还是有超时问题的。&lt;/p>
&lt;p>假设第一个进程逻辑执行时间执行了 15s，锁的过期时间为 10s，那么第一个 10s 后锁就会自动释放，第二个进程就可以拿到锁。&lt;/p>
&lt;p>如果第二个进程在执行 5s 后还没有结束，这个时候第一个进程的逻辑执行完了，释放了锁。那这个时候第一个进程就会把第二个进程的锁释放了。在高并发场景下，会出现大量的锁被错误释放的情况，也就意味会有大量的进程可以拿到这个锁。&lt;/p>
&lt;ol>
&lt;li>进程 1 获取锁成功。&lt;/li>
&lt;li>进程 1 在某个操作上阻塞了很长时间。&lt;/li>
&lt;li>过期时间到了，锁自动释放了。&lt;/li>
&lt;li>进程 2 获取到了对应同一个资源的锁。&lt;/li>
&lt;li>进程 1 从阻塞中恢复过来，释放掉了进程 2 持有的锁。&lt;/li>
&lt;/ol>
&lt;h3>解决方案&lt;span class="hx-absolute -hx-mt-20" id="解决方案">&lt;/span>
&lt;a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>这个问题的根源就是错误的释放锁。可以 &lt;code>set&lt;/code> 的 &lt;code>value&lt;/code> &lt;strong>设置为一个随机数或者唯一的 uuid，释放锁时先匹配随机数是否一致&lt;/strong>，然后再删除 &lt;code>key&lt;/code>，这是为了&lt;strong>确保当前线程占有的锁不会被其它线程释放，除非这个锁是过期了被服务器自动释放的&lt;/strong>。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-py" data-lang="py">&lt;span class="line">&lt;span class="cl">&lt;span class="n">tag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">nextint&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1"># 随机数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="n">redis&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tag&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nx&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">do_something&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">redis&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">delifequals&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tag&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 假想的 delifequals 指令&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>上面的方案还有一点小问题，就是 &lt;code>delifequals&lt;/code> 指令，这是一个自定义的指令，匹配 &lt;code>value&lt;/code> 和删除 &lt;code>key&lt;/code> 并不是一个原子操作，还是会有原子性问题。例如在匹配 &lt;code>value&lt;/code> 后，还没来得及删除 &lt;code>key&lt;/code>，锁就过期了，此时其它线程就可以获取到锁了。然后又执行了删除 &lt;code>key&lt;/code> 的操作，这样就会把其它线程的锁给释放了。&lt;/p>
&lt;p>Redis 也没有提供类似于 &lt;code>delifequals&lt;/code> 这样的指令，这就需要使用 Lua 脚本来处理了，因为 Lua 脚本可以保证连续多个指令的原子性执行。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-lua" data-lang="lua">&lt;span class="line">&lt;span class="cl">&lt;span class="o">#&lt;/span> &lt;span class="n">delifequals&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">if&lt;/span> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="kr">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;del&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">end&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>这段 Lua 脚本在执行的时候要把前面的 &lt;code>tag&lt;/code> 作为 &lt;code>ARGV[1]&lt;/code> 的值传进去，把 &lt;code>key&lt;/code> 作为 &lt;code>KEYS[1]&lt;/code> 的值传进去。&lt;/p>
&lt;h3>锁续命（Watchdog）方案&lt;span class="hx-absolute -hx-mt-20" id="锁续命watchdog方案">&lt;/span>
&lt;a href="#%e9%94%81%e7%bb%ad%e5%91%bdwatchdog%e6%96%b9%e6%a1%88" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>上面的方案，只是相对安全一点，因为如果真的超时了，当前线程的逻辑没有执行完，其它线程也会乘虚而入。&lt;/p>
&lt;p>为了解决这个问题，我们可以在获取锁之后，开启一个守护线程，用来给快要过期的锁“续命”，也就是不断的延长锁的过期时间。现在已经有很成熟的方案，例如 redisson。&lt;/p>
&lt;p>redisson 是一个在 Redis 的基础上提供了许多分布式服务。其中就包含了各种分布式锁的实现。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redisson.png" alt="redisson" loading="lazy" />&lt;/p>
&lt;p>redisson 自旋尝试加锁的逻辑，如果加锁失败，会拿到当前锁的剩余时间 ttl，然后让出 CPU 让其它线程执行，等待 ttl 时间后再继续尝试加锁。加锁失败的同时还会去订阅一个 Redis channel，监听锁释放的消息，当锁释放后会收到消息，然后重新尝试加锁。&lt;/p>
&lt;h3>Go 实现锁续命&lt;span class="hx-absolute -hx-mt-20" id="go-实现锁续命">&lt;/span>
&lt;a href="#go-%e5%ae%9e%e7%8e%b0%e9%94%81%e7%bb%ad%e5%91%bd" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>核心设计思路&lt;/p>
&lt;ul>
&lt;li>后台定时续期：获取锁成功后启动一个 goroutine 定期续期&lt;/li>
&lt;li>线程(协程)标识验证：续期时验证锁是否仍由当前协程持有&lt;/li>
&lt;li>自动停止机制：锁释放或协程退出时自动停止续期&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">redistlock&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;context&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;crypto/rand&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;encoding/hex&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;errors&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;github.com/go-redis/redis/v8&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">const&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">defaultWatchdogInterval&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">10&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span> &lt;span class="c1">// 默认续期间隔
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">defaultLockTimeout&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">30&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span> &lt;span class="c1">// 默认锁超时时间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">DistLock&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">client&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">redis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Client&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">key&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">value&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="c1">// 唯一标识，格式: UUID:goroutineID
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">watchdogActive&lt;/span> &lt;span class="kt">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">stopWatchdog&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mutex&lt;/span> &lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Mutex&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// NewDistLock 创建一个新的分布式锁实例
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewDistLock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">client&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">redis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Client&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">key&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">DistLock&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">DistLock&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">client&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">client&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">key&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">value&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nf">generateLockValue&lt;/span>&lt;span class="p">(),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">stopWatchdog&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// generateLockValue 生成锁的唯一标识值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">generateLockValue&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 生成随机 UUID 部分
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">buf&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">rand&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buf&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">uuid&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">hex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">EncodeToString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buf&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 获取当前 goroutine ID
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">goid&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getGoroutineID&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s:%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">uuid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">goid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 获取 goroutine ID (简化实现)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">getGoroutineID&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">uint64&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">buf&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">n&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Stack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buf&lt;/span>&lt;span class="p">[:],&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">idField&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">strings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fields&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">strings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">TrimPrefix&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buf&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">]),&lt;/span> &lt;span class="s">&amp;#34;goroutine &amp;#34;&lt;/span>&lt;span class="p">))[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">strconv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ParseUint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">idField&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">64&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">id&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Lock 获取分布式锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">DistLock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">timeout&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 尝试获取锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">acquired&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetNX&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">defaultLockTimeout&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">Result&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">acquired&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 启动看门狗
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startWatchdog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 等待锁释放或超时
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">timeout&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">expire&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">timeout&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ticker&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewTicker&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Millisecond&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">ticker&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Stop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ticker&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">C&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">acquired&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetNX&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">defaultLockTimeout&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">Result&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">acquired&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">startWatchdog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">After&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">expire&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;lock timeout&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Err&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">errors&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">New&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;lock acquisition failed&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// startWatchdog 启动看门狗续期机制
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">DistLock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">startWatchdog&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">watchdogActive&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">watchdogActive&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ticker&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewTicker&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">defaultWatchdogInterval&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">ticker&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Stop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">select&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ticker&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">C&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 续期操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">renewed&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">renewLock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">renewed&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 续期失败，可能是锁已释放或已失去所有权
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">watchdogActive&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stopWatchdog&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 收到停止信号
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">watchdogActive&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 上下文取消
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">watchdogActive&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// renewLock 续期锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">DistLock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">renewLock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用 Lua 脚本保证原子性
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">script&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="s">`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> if redis.call(&amp;#34;get&amp;#34;, KEYS[1]) == ARGV[1] then
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> return redis.call(&amp;#34;pexpire&amp;#34;, KEYS[1], ARGV[2])
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> return 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> end
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> `&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Eval&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">script&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">defaultLockTimeout&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Milliseconds&lt;/span>&lt;span class="p">()).&lt;/span>&lt;span class="nf">Result&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.(&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Unlock 释放锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">DistLock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">error&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mutex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unlock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 先停止看门狗
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">watchdogActive&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stopWatchdog&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">watchdogActive&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">stopWatchdog&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用 Lua 脚本保证原子性
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">script&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="s">`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> if redis.call(&amp;#34;get&amp;#34;, KEYS[1]) == ARGV[1] then
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> return redis.call(&amp;#34;del&amp;#34;, KEYS[1])
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> return 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> end
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> `&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Eval&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">script&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">Result&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// IsLocked 检查锁是否仍被当前实例持有
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">dl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">DistLock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">IsLocked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">key&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">Result&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">redis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">dl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>RedLock&lt;span class="hx-absolute -hx-mt-20" id="redlock">&lt;/span>
&lt;a href="#redlock" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 一般都是集群架构，很少有使用单机部署的。但是分布式锁在集群架构中是存在问题的。&lt;/p>
&lt;p>比如在 Sentinel 集群中，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。&lt;/p>
&lt;p>为了解决这个问题，Redis 作者 antirez 提出了 RedLock 算法。&lt;/p>
&lt;p>为了使用 Redlock，需要提供多个 Redis 实例，这些实例之前&lt;strong>相互独立没有主从关系&lt;/strong>。同很多分布式算法一样，redlock 也使用&lt;strong>大多数机制&lt;/strong>。&lt;/p>
&lt;p>加锁时，它会向过半节点发送 &lt;code>set(key, value, nx=True, ex=xxx)&lt;/code> 指令，只要过半节点 &lt;code>set&lt;/code> 成功，那就认为加锁成功。释放锁时，需要向所有节点发送 &lt;code>del&lt;/code> 指令。不过 Redlock 算法还需要考虑出错重试、时钟漂移等很多细节问题，同时&lt;strong>因为 Redlock 需要向多个节点进行读写，意味着相比单实例 Redis 性能会下降&lt;/strong>一些。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/redlock.png" alt="redlock" loading="lazy" />&lt;/p>
&lt;p>但是 RedLock 并不是一个推荐的方案，因为 RedLock 还存在一些问题：&lt;/p>
&lt;ol>
&lt;li>主从同步：如果主节点还没来得及把锁同步到从节点，主节点就挂掉了，那么这个锁就会丢失。那就又回到了 Redlock 最初要解决的问题上。&lt;/li>
&lt;li>当然也可以不部署主从节点，但是如果主节点挂了超过一半的节点，就会导致无法加锁。而且如果持久化机制是设置的每秒执行一次，如果正好在执行持久化时，主节点挂掉了，那么这个锁就会丢失。&lt;/li>
&lt;li>如果主节点太多，那么加锁和释放锁的时间就会比较长。&lt;/li>
&lt;/ol>
&lt;p>如果&lt;strong>非要这种高一致性的锁，那么可以使用 Zookeeper 来实现&lt;/strong>。&lt;/p>
&lt;h2>可重入锁&lt;span class="hx-absolute -hx-mt-20" id="可重入锁">&lt;/span>
&lt;a href="#%e5%8f%af%e9%87%8d%e5%85%a5%e9%94%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>如果一个锁支持&lt;strong>同一个线程的多次加锁&lt;/strong>，那么这个锁就是可重入的。&lt;/p>
&lt;h2>Redis Lua 脚本&lt;span class="hx-absolute -hx-mt-20" id="redis-lua-脚本">&lt;/span>
&lt;a href="#redis-lua-%e8%84%9a%e6%9c%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis在 2.6 推出了脚本功能，允许开发者使用Lua 语言编写脚本传到 Redis 中执行。使用脚本的好处如下:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>减少网络开销&lt;/strong>：本来 5 次网络请求的操作，可以用一个请求完成，原先 5 次请求的逻辑放在 Redis 服务器上完成。使用脚本，减少了网络往返时延。&lt;strong>这点跟管道类似&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>原子操作&lt;/strong>：Redis 会将整个脚本作为一个整体执行，中间不会被其他命令插入。&lt;strong>管道不是原子的，不过 Redis 的批量操作命令(类似 mset )是原子的&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>替代 Redis 的事务功能&lt;/strong>：Redis 自带的事务功能很鸡肋，而 Redis 的 lua 脚本几乎实现了常规的事务功能，官方推荐用 Redis lua 替代 Redis 的事务功能。&lt;/li>
&lt;/ol>
&lt;p>Redis 2.6 版本开始，通过内置的 Lua 解释器，可以使用 &lt;code>EVAL&lt;/code> 命令对 Lua 脚本进行求值。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>EVAL script numkeys key [key ...] arg [arg ...]&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>&lt;code>script&lt;/code> 参数是一段 Lua 脚本程序。Redis 使用 &lt;code>EVAL&lt;/code> 命令的第一个参数来传递脚本程序。这段&lt;strong>脚本不必(也不应该)定义为一个 Lua 函数&lt;/strong>。&lt;/li>
&lt;li>&lt;code>numkeys&lt;/code> 参数用于指定键名参数的个数。&lt;/li>
&lt;li>键名参数 &lt;code>key [key ...]&lt;/code> 从 &lt;code>EVAL&lt;/code> 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键 (key)，这些键名参数可以在 Lua 中通过全局变量 &lt;code>KEYS&lt;/code> 数组，用 1 为基址的形式访问( &lt;code>KEYS[1]&lt;/code> ， &lt;code>KEYS[2]&lt;/code> ，以此类推)。&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; &lt;span class="nb">eval&lt;/span> &lt;span class="s2">&amp;#34;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&amp;#34;&lt;/span> &lt;span class="m">2&lt;/span> key1 key2 first second
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;key1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;key2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;first&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;second&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>在 Lua 脚本中，可以使用 &lt;code>redis.call()&lt;/code> 函数来执行 Redis 命令：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-lua" data-lang="lua">&lt;span class="line">&lt;span class="cl">&lt;span class="n">jedis.set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;product_stock_10016&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;15&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="err">初始化商品&lt;/span>&lt;span class="mi">10016&lt;/span>&lt;span class="err">的库存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">String&lt;/span> &lt;span class="n">script&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34; local count = redis.call(&amp;#39;get&amp;#39;, KEYS[1]) &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34; local a = tonumber(count) &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34; local b = tonumber(ARGV[1]) &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34; if a &amp;gt;= b then &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34; redis.call(&amp;#39;set&amp;#39;, KEYS[1], a-b) &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34; return 1 &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34; end &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34; return 0 &amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Object&lt;/span> &lt;span class="n">obj&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">jedis.eval&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">script&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Arrays.asList&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;product_stock_10016&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">Arrays.asList&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;10&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">System.out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">&lt;strong>不要在 Lua 脚本中出现死循环和耗时的运算，否则 Redis 会阻塞&lt;/strong>，将不接受其他的命令，所以使用时要注意不能出现死循环、耗时的运算。Redis 是单进程、单线程执行脚本。管道不会阻塞 Redis。&lt;/div>
&lt;/div>
&lt;/div>
&lt;h2>优化&lt;span class="hx-absolute -hx-mt-20" id="优化">&lt;/span>
&lt;a href="#%e4%bc%98%e5%8c%96" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>分布式锁的粒度要尽量小，不需要被锁住的代码尽量并发执行。&lt;/li>
&lt;li>分段锁：比如一个商品（&lt;code>product:10011:stock&lt;/code>）有 1000 个库存，那么可以把库存分成 10 段（&lt;code>product:10011:stock1&lt;/code>、&lt;code>product:10011:stock2&lt;/code> 等等），每一段都有一个锁，这样就可以有 10 个线程并发执行了。&lt;/li>
&lt;/ol></description></item><item><title>缓存设计</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/09_design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/09_design/</guid><description>
&lt;h2>简单的冷热分离实现&lt;span class="hx-absolute -hx-mt-20" id="简单的冷热分离实现">&lt;/span>
&lt;a href="#%e7%ae%80%e5%8d%95%e7%9a%84%e5%86%b7%e7%83%ad%e5%88%86%e7%a6%bb%e5%ae%9e%e7%8e%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>比如一个电商网站，商品可能会有很多，但是真正热门的，每天都有人访问的商品可能不足 &lt;code>1%&lt;/code>，对于这种热门的商品，可以延长其缓存的有效期，这样可以减少数据库的访问次数，提高系统的性能。&lt;/p>
&lt;p>示例代码：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ValidityDuration&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">24&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Hour&lt;/span> &lt;span class="c1">// 缓存有效期
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">GetProduct&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">Product&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从缓存中获取商品信息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">product&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">GetProductFromCache&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果缓存中存在商品信息，延长有效期
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">UpdateProductExpireTime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ValidityDuration&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">product&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 从数据库中获取商品信息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">product&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">GetProductFromDB&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将商品信息存入缓存，有效期为 24 小时
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">SetProductToCache&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">product&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ValidityDuration&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">product&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>上面的代码中，&lt;strong>只要商品被访问过，并且在缓存中，那么就会延长其有效期&lt;/strong>，这样可以保证热门的商品一直存在于缓存中。&lt;/p>
&lt;h2>缓存失效（击穿）&lt;span class="hx-absolute -hx-mt-20" id="缓存失效击穿">&lt;/span>
&lt;a href="#%e7%bc%93%e5%ad%98%e5%a4%b1%e6%95%88%e5%87%bb%e7%a9%bf" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>缓存失效（击穿）是指由于大批量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，可能会造成数据库瞬间压力过大甚至挂掉。例如电商系统中，如果有一大批商品同时上架，这批商品的缓存数据可能会在同一时间失效。&lt;/p>
&lt;h3>解决方案&lt;span class="hx-absolute -hx-mt-20" id="解决方案">&lt;/span>
&lt;a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>可以在批量增加缓存时，对于这一批数据中的每一个 key 的缓存过期时间都增加为一个随机的值，这样的话，每个 key 的过期时间都不同，从而避免了大量缓存同时失效的问题。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从缓存中获取数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cacheValue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 缓存为空&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">StringUtils&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isBlank&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cacheValue&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从存储中获取&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storage&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 设置一个过期时间(300到600之间的一个随机数)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">expireTime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Random&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">nextInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">300&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">300&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">expire&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">expireTime&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 缓存非空&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cacheValue&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>缓存穿透&lt;span class="hx-absolute -hx-mt-20" id="缓存穿透">&lt;/span>
&lt;a href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>缓存穿透是指&lt;strong>查询一个根本不存在的数据&lt;/strong>（&lt;strong>缓存击穿的区别就在于数据至少在数据库中还是存在的&lt;/strong>，击穿只是击穿了缓存层，&lt;strong>穿透是整个后端都被穿透&lt;/strong>了），缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。&lt;/p>
&lt;p>缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。&lt;/p>
&lt;p>造成缓存穿透的基本原因有两个：&lt;/p>
&lt;ol>
&lt;li>自身业务代码或者数据出现问题。&lt;/li>
&lt;li>一些恶意攻击、 爬虫等造成大量空命中。&lt;/li>
&lt;/ol>
&lt;h3>解决方案&lt;span class="hx-absolute -hx-mt-20" id="解决方案-1">&lt;/span>
&lt;a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>缓存空对象&lt;span class="hx-absolute -hx-mt-20" id="缓存空对象">&lt;/span>
&lt;a href="#%e7%bc%93%e5%ad%98%e7%a9%ba%e5%af%b9%e8%b1%a1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（null）进行缓存，并且设置一个过期时间。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从缓存中获取数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cacheValue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 缓存为空&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">StringUtils&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isBlank&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cacheValue&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从存储中获取&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storage&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 如果存储数据为空， 需要设置一个过期时间 300s&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">expire&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">60&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 缓存非空&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cacheValue&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>如果是被恶意攻击，每次攻击可能都会换不一样的 key，如果缓存中存储上百万个空值，占用了大量的内存空间。可以&lt;strong>为空值缓存设置一个短的过期时间。对于空值缓存，也需要设置延期，避免同一个空值的 key 被不停的访问&lt;/strong>。&lt;/p>
&lt;h4>布隆过滤器&lt;span class="hx-absolute -hx-mt-20" id="布隆过滤器">&lt;/span>
&lt;a href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说&lt;strong>某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在&lt;/strong>。&lt;/p>
&lt;p>布隆过滤器就是一个大型的位数组和一组的无偏 &lt;code>hash&lt;/code> 函数。所谓无偏就是能够把元素的 &lt;code>hash&lt;/code> 值算得比较均匀。&lt;/p>
&lt;p>向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 &lt;code>hash&lt;/code> 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。&lt;/p>
&lt;p>向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在。如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组长度比较大，存在概率就会很大，如果这个位数组长度比较小，存在概率就会降低。&lt;/p>
&lt;p>可以用 redisson 实现布隆过滤器：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">com.redisson&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kn">import&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">org.redisson.Redisson&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kn">import&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">org.redisson.api.RBloomFilter&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kn">import&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">org.redisson.api.RedissonClient&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kn">import&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">org.redisson.config.Config&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">RedissonBloomFilter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Config&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Config&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">useSingleServer&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">setAddress&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;redis://localhost:6379&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 构造 Redisson&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">RedissonClient&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">redisson&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Redisson&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">RBloomFilter&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">redisson&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getBloomFilter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;nameList&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 初始化布隆过滤器：预计元素为 100000000L,误差率为 3%,根据这两个参数会计算出底层的 bit 数组大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">tryInit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">100000000L&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">03&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//将 zhuge 插入到布隆过滤器中&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;zhuge&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 判断下面号码是否在布隆过滤器中&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">contains&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;guojia&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="c1">//false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">contains&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;baiqi&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="c1">//false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">contains&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;zhuge&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="c1">//true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>使用布隆过滤器需要把所有数据提前放入布隆过滤器，并且在增加数据时也要往布隆过滤器里放，布隆过滤器缓存过滤伪代码：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//初始化布隆过滤器&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">RBloomFilter&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">redisson&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getBloomFilter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;nameList&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">//初始化布隆过滤器：预计元素为100000000L,误差率为3%&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">tryInit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">100000000L&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">03&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">//把所有数据存入布隆过滤器&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">init&lt;/span>&lt;span class="p">(){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">keys&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="c1">// 从布隆过滤器这一级缓存判断下 key 是否存在&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="n">Boolean&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">exist&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bloomFilter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">contains&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">exist&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="c1">// 从缓存中获取数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cacheValue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="c1">// 缓存为空&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">StringUtils&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isBlank&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cacheValue&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="c1">// 从存储中获取&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storage&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="c1">// 如果存储数据为空， 需要设置一个过期时间(300秒)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">            &lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">expire&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">60&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">storageValue&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="c1">// 缓存非空&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">        &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cacheValue&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">这种方法&lt;strong>适用于数据命中不高、数据相对固定（因为添加删除元素需要重建）、实时性低（通常是数据集较大）的应用场景&lt;/strong>，代码维护较为复杂，但是缓存空间占用很少。&lt;/div>
&lt;/div>
&lt;/div>
&lt;h2>热点缓存 key 的重建优化&lt;span class="hx-absolute -hx-mt-20" id="热点缓存-key-的重建优化">&lt;/span>
&lt;a href="#%e7%83%ad%e7%82%b9%e7%bc%93%e5%ad%98-key-%e7%9a%84%e9%87%8d%e5%bb%ba%e4%bc%98%e5%8c%96" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>开发人员使用 “缓存+过期时间” 的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。但是有两个问题如果同时出现，可能就会对应用造成致命的危害：&lt;/p>
&lt;ol>
&lt;li>当前 key 是一个热点 key（例如一个热门的娱乐新闻），并发量非常大。&lt;/li>
&lt;li>重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次 IO、多个依赖等。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大&lt;/strong>，甚至可能会让应用崩溃。&lt;/p>
&lt;h3>解决方案&lt;span class="hx-absolute -hx-mt-20" id="解决方案-2">&lt;/span>
&lt;a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>要解决这个问题主要就是要避免大量线程同时重建缓存。可以&lt;strong>利用互斥锁，（多个服务实例，使用分布式锁）&lt;strong>来解决，此方法&lt;/strong>只允许一个线程重建缓存&lt;/strong>，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从 Redis 中获取数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">redis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 如果 value 为空， 则开始重构缓存&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 只允许一个线程重建缓存， 使用 nx， 并设置过期时间 ex&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mutexKey&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;mutex:key:&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutexKey&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;ex 180&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;nx&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从数据源获取数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">db&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 回写 Redis， 并设置过期时间&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">redis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 删除 key_mutex&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">redis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">delete&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutexKey&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 其他线程休息 50 毫秒后重试，重试时缓存中已经有值了&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">50&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>对于不同的商品，可以使用不同的 key， 避免不同的商品竞争同一把锁&lt;/strong>，提高并发度。&lt;/p>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">这里要注意，如果使用了缓存空对象来解决缓存穿透的问题，那么这里在判断缓存为空的时候，要区分一下是真的不存在，还是缓存的空对象，如果是缓存的空对象，就不需要去重建缓存了，因为数据库里也没有。&lt;/div>
&lt;/div>
&lt;/div>
&lt;h2>缓存与数据库双写不一致&lt;span class="hx-absolute -hx-mt-20" id="缓存与数据库双写不一致">&lt;/span>
&lt;a href="#%e7%bc%93%e5%ad%98%e4%b8%8e%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8f%8c%e5%86%99%e4%b8%8d%e4%b8%80%e8%87%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>在大并发下，同时操作数据库与缓存会存在数据不一致性问题：&lt;/p>
&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/db-cache-demo.png" width="280px">
&lt;p>上图线程 1 先执行了更新数据库的操作，但是卡了一会还没来得及更新缓存，然后线程 2 也执行了更新数据库的操作并且更新的缓存，最后线程 1 更新了缓存。&lt;/p>
&lt;p>最后数据库中的 &lt;code>stock=6&lt;/code> 而缓存中的 &lt;code>stock=10&lt;/code>。这就是缓存与数据库的数据不一致问题。&lt;/p>
&lt;p>有些业务实现，在写完数据库之后可能不会去更新缓存，而是删除缓存，在查询数据库的时候再去更新缓存。这种方式也有一样的问题：&lt;/p>
&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/db-cache-demo2.png" width="380px">
&lt;p>图中，线程 1 写入数据库 &lt;code>stock=10&lt;/code> 并删除缓存，然后线程 3 查询数据缓存为空，接着查询数据库得到 &lt;code>stock=10&lt;/code>，这个时候如果在线程 3 更新缓存之前，线程 2 写入数据库 &lt;code>stock=6&lt;/code> 并删除缓存，最后线程 3 写入缓存 &lt;code>stock=10&lt;/code>。一样的缓存与数据库的数据不一致问题。&lt;/p>
&lt;h3>解决方案&lt;span class="hx-absolute -hx-mt-20" id="解决方案-3">&lt;/span>
&lt;a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>问题主要是出在了查询数据库和更新缓存之间，在高并发的场景下，可能会出现别的线程更新数据库的操作。&lt;/p>
&lt;p>直接使用&lt;strong>分布式锁&lt;/strong>就能解决这种问题。&lt;/p>
&lt;ol>
&lt;li>对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。&lt;/li>
&lt;li>就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，&lt;strong>缓存加上过期时间&lt;/strong>依然可以解决大部分业务对于缓存的要求。&lt;/li>
&lt;li>如果不能容忍缓存数据不一致，可以通过加&lt;strong>分布式读写锁&lt;/strong>来保证并发读写或写写的时候按顺序排好队，读读的时候相当于无锁。&lt;/li>
&lt;li>也可以用阿里开源的 canal 通过监听数据库的 binlog 日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。&lt;/li>
&lt;/ol>
&lt;h2>缓存雪崩&lt;span class="hx-absolute -hx-mt-20" id="缓存雪崩">&lt;/span>
&lt;a href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>缓存雪崩指的是缓存层支撑不住或宕掉后，流量会像奔逃的野牛一样，打向后端存储层。&lt;/p>
&lt;p>由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不能提供服务(比如超大并发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问 bigkey，导致缓存能支撑的并发急剧下降)，于是大量请求都会打到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。&lt;/p>
&lt;h3>解决方案&lt;span class="hx-absolute -hx-mt-20" id="解决方案-4">&lt;/span>
&lt;a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>预防和解决缓存雪崩问题， 可以从以下三个方面进行着手：&lt;/p>
&lt;ol>
&lt;li>保证缓存层服务&lt;strong>高可用&lt;/strong>性，比如使用 Redis Sentinel 或 Redis Cluster。&lt;/li>
&lt;li>依赖隔离组件为后端&lt;strong>限流熔断并降级&lt;/strong>。比如使用 Sentinel 或 Hystrix &lt;strong>限流降级&lt;/strong>组件。比如服务降级，我们可以针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是直接返回预定义的默认降级信息、空值或是错误提示信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。&lt;/li>
&lt;li>&lt;strong>多级缓存&lt;/strong>，&lt;code>进程内存 -&amp;gt; Redis -&amp;gt; 数据库&lt;/code>。对于进程内存缓存，可以使用一些轻量级的缓存组件，比如 Google 的 Guava Cache 或者 Caffeine，这些组件都实现了进程内缓存，并且支持多种缓存过期策略。可以避免内存泄露的问题。&lt;strong>多级缓存架构也会有数据不一致的问题&lt;/strong>，可以通过异步的方式来更新缓存。不过一点点的不一致是可以接受的，没有必要继续增加系统的复杂性。真正实践中会有一个独立的 HotKey 监测系统来监控热点 key 的，然后将热点 key 加入到多级缓存中。&lt;/li>
&lt;li>&lt;strong>提前演练&lt;/strong>。 在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。&lt;/li>
&lt;/ol>
&lt;h2>总结&lt;span class="hx-absolute -hx-mt-20" id="总结">&lt;/span>
&lt;a href="#%e6%80%bb%e7%bb%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>针对&lt;strong>读多写少的情况加入缓存提高性能&lt;/strong>，如果&lt;strong>写多读多的情况又不能容忍缓存数据不一致，那就没必要加缓存了&lt;/strong>，可以直接操作数据库。当然，如果数据库抗不住压力，还可以把缓存作为数据读写的主存储，异步将数据同步到数据库，数据库只是作为数据的备份。
放入缓存的数据应该是对实时性、一致性要求不是很高的数据。切记不要为了用缓存，同时又要保证绝对的一致性做大量的过度设计和控制，增加系统复杂性。&lt;/p></description></item><item><title>热点缓存探测系统</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/10_hotkey/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/10_hotkey/</guid><description>
&lt;h2>多级缓存&lt;span class="hx-absolute -hx-mt-20" id="多级缓存">&lt;/span>
&lt;a href="#%e5%a4%9a%e7%ba%a7%e7%bc%93%e5%ad%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>一般多级缓存分为：&lt;/p>
&lt;ol>
&lt;li>本地缓存&lt;/li>
&lt;li>远程缓存&lt;/li>
&lt;/ol>
&lt;p>本地缓存的优势：&lt;/p>
&lt;ol>
&lt;li>可以减少网络请求，提高性能。&lt;/li>
&lt;li>减少远程缓存的压力。&lt;/li>
&lt;/ol>
&lt;p>本地缓存的缺点：&lt;/p>
&lt;ol>
&lt;li>进程空间的大小有限，不能存储大量的数据。&lt;/li>
&lt;li>进程重启后，本地缓存会丢失。&lt;/li>
&lt;li>分布式场景下，本地缓存会出现数据不一致的问题。&lt;/li>
&lt;li>和远程缓存的一致性问题。&lt;/li>
&lt;/ol>
&lt;p>对于数据不一致的问题，其实只要保证&lt;strong>最终一致性&lt;/strong>即可。&lt;strong>缩短本地缓存的过期时间&lt;/strong>，根据业务能够接受不一致的时间来设置，比如 10s 或者更短的过期时间。&lt;/p>
&lt;h3>多级缓存的使用场景&lt;span class="hx-absolute -hx-mt-20" id="多级缓存的使用场景">&lt;/span>
&lt;a href="#%e5%a4%9a%e7%ba%a7%e7%bc%93%e5%ad%98%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>热点的商品详情页&lt;/li>
&lt;li>热搜&lt;/li>
&lt;li>热门帖子&lt;/li>
&lt;li>热门用户主页&lt;/li>
&lt;/ul>
&lt;p>一般都是在高并发的场景下使用。&lt;/p>
&lt;p>热点产生的条件：&lt;/p>
&lt;ol>
&lt;li>有限时间&lt;/li>
&lt;li>流量高聚&lt;/li>
&lt;/ol>
&lt;p>在互联网领域，热点被分为 2 类：&lt;/p>
&lt;ol>
&lt;li>有预期的热点：比如在电商活动中退出的爆款联名限量款商品，又或者是秒杀会场活动等。&lt;/li>
&lt;li>无预期的热点：比如受到了黑客的恶意攻击，网络爬虫的频繁访问，又或者突发新闻带来的流量冲击等。&lt;/li>
&lt;/ol>
&lt;p>对于有预期的热点，我们可以通过提前预热，提前把数据加载到缓存中，或者提前扩容，降级等方式来解决。&lt;/p>
&lt;p>对于无预期的热点，就需要热点探测系统来探测热点，在热点还没有爆火之前探测出来，提前把数据加载到缓存中，进行扩容等。&lt;/p>
&lt;h3>热点探测使用场景&lt;span class="hx-absolute -hx-mt-20" id="热点探测使用场景">&lt;/span>
&lt;a href="#%e7%83%ad%e7%82%b9%e6%8e%a2%e6%b5%8b%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>MySQL 中被频繁访问的数据 ，如热门商品的主键 id。&lt;/li>
&lt;li>Redis 缓存中被密集访问的 Key，如热门商品的详情需要 &lt;code>get goods$id&lt;/code>。&lt;/li>
&lt;li>恶意攻击或机器人爬虫的请求信息，如特定标识的 userId、机器 IP。&lt;/li>
&lt;li>频繁被访问的接口地址，如获取用户信息接口 &lt;code>/userInfo/ + userId&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h4>使用热点探测的好处&lt;span class="hx-absolute -hx-mt-20" id="使用热点探测的好处">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8%e7%83%ad%e7%82%b9%e6%8e%a2%e6%b5%8b%e7%9a%84%e5%a5%bd%e5%a4%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>提升性能，规避风险。&lt;/p>
&lt;p>对于无预期的热数据（即突发场景下形成的热 Key），可能会对业务系统带来极大的风险，可将风险分为两个层次：&lt;/p>
&lt;ol>
&lt;li>对数据层的风险&lt;/li>
&lt;/ol>
&lt;p>正常情况下，Redis 缓存单机就可支持十万左右 QPS，并能通过集群部署提高整体负载能力。对于并发量一般的系统，用 Redis 做缓存就足够了。但是对于瞬时过高并发的请求，因为 Redis 单线程原因会导致正常请求排队，或者因为热点集中导致分片集群压力过载而瘫痪，从而击穿到 DB 引起服务器雪崩。&lt;/p>
&lt;ol start="2">
&lt;li>对应用服务的风险&lt;/li>
&lt;/ol>
&lt;p>每个应用在单位时间所能接受和处理的请求量是有限的，如果受到恶意请求的攻击，让恶意用户独自占用了大量请求处理资源，就会导致其他正常用户的请求无法及时响应。&lt;/p>
&lt;p>因此，需要一套动态热 Key 检测机制，通过对需要检测的热 Key 规则进行配置，实时监听统计热 Key 数据，当无预期的热点数据出现时，第一时间发现他，并针对这些数据进行特殊处理。如本地缓存、拒绝恶意用户、接口限流/降级等&lt;/p>
&lt;h3>如何实现热点探测&lt;span class="hx-absolute -hx-mt-20" id="如何实现热点探测">&lt;/span>
&lt;a href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%83%ad%e7%82%b9%e6%8e%a2%e6%b5%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>热点产生的条件是 2 个：一个&lt;strong>时间&lt;/strong>，一个&lt;strong>流量&lt;/strong>。那么根据这个条件可以简单定义一个规则：比如 1 秒内访问 1000 次的数据算是热数据，当然这个数据需要根据具体的业务场景和过往数据进行具体评估。&lt;/p>
&lt;p>对于单机应用，检测热数据很简单，直接在本地为每个 Key 创建一个滑动窗口计数器，统计单位时间内的访问总数（频率），并通过一个集合存放检测到的热 Key。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/hotkey-window.png" alt="hotkey-window" loading="lazy" />&lt;/p>
&lt;p>对于分布式应用，对热 Key 的访问是分散在不同的机器上的，无法在本地独立地进行计算，因此，需要一个独立的、集中的热 Key 计算单元。&lt;/p>
&lt;p>可以分为五个步骤：&lt;/p>
&lt;ol>
&lt;li>热点规则：配置热 Key 的上报规则，圈出需要重点监测的 Key。&lt;/li>
&lt;li>热点上报：应用服务将自己的热 Key 访问情况上报给集中计算单元。&lt;/li>
&lt;li>热点统计：收集各应用实例上报的信息，使用滑动窗口算法计算 Key 的热度。&lt;/li>
&lt;li>热点推送：当 Key 的热度达到设定值时，推送热 Key 信息至所有应用实例。&lt;/li>
&lt;li>热点缓存：各应用实例收到热 Key 信息后，对 Key 值进行本地缓存。&lt;/li>
&lt;/ol>
&lt;h4>单机应用示例&lt;span class="hx-absolute -hx-mt-20" id="单机应用示例">&lt;/span>
&lt;a href="#%e5%8d%95%e6%9c%ba%e5%ba%94%e7%94%a8%e7%a4%ba%e4%be%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">HotKeyDetector&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">WINDOW_SIZE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 滑动窗口大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">THRESHOLD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 阈值，达到该条件时即判定为热 Key&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Cache&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Obejct&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hotCache&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CacheBuilder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">newBuilder&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 本地缓存&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">expireAfterWrite&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TimeUnit&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">maximumSize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">1000&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 缓存最大容量&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">build&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">window&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">HashMap&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 滑动窗口 &lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">counts&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">HashMap&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 用来计数，用来和阈值比较&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 判断是否为热 Key&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">boolean&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">isHotKey&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 如果缓存中有数据，说明已经是 hot key，直接返回 true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hotCache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getIfPresent&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取当前数据在计数器中的统计次数&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">counts&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getOrDefault&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 如果次数大于阈值，说明是热 Key，将数据加入本地缓存，清空队列并返回 true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">THRESHOLD&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">hotCache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 加入本地缓存&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">clear&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 清空滑动窗口中相应的队列&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 如果次数小于阈值，说明不是热 Key，将数据加入滑动窗口，并返回 false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">counts&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 次数加 1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取对应数据的时间队列&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 如果队列不存在，就创建一个新的队列&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取当前时间（秒）&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">long&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">currentTime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">currentTimeMillis&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1000&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currentTime&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 将当前时间加入队列，用于后面数据滑动窗口的统计&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 如果队列中数据的时间超过了滑动窗口的时间区间，则将该时间从队列中移除&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">currentTime&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">WINDOW_SIZE&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">poll&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 移除队列头部的时间&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">counts&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">counts&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 统计次数减 1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 不是热 Key，返回 false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 清除指定数据的队列和计数&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">clear&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">remove&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 移除指定数据的队列&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">counts&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">remove&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 移除指定数据的计数&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 添加数据到本地缓存&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">hotCache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 将数据加入本地缓存&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从本地缓存中获取数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">hotCache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getIfPresent&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从本地缓存中获取数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>上面并没有考虑并发安全的问题，只是简单的示例。&lt;/p>
&lt;p>滑动窗口示例：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">TimeWindow&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">requests&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int64&lt;/span> &lt;span class="c1">// 存储请求时间戳
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">size&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="c1">// 窗口大小（请求次数限制）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">duration&lt;/span> &lt;span class="kt">int64&lt;/span> &lt;span class="c1">// 窗口时间范围（纳秒）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewTimeWindow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">size&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">duration&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Duration&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">TimeWindow&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">TimeWindow&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">requests&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">int64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">size&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">size&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">size&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">duration&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">duration&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Nanoseconds&lt;/span>&lt;span class="p">(),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 检查是否允许通过
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">tw&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">TimeWindow&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Allow&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">now&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">UnixNano&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 移除过期请求
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">tw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requests&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">now&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="nx">tw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requests&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">tw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">duration&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">tw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requests&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">tw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requests&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 检查是否超过限制
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">tw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requests&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="nx">tw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">size&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 记录当前请求
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">tw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requests&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">tw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">requests&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">now&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>分布式应用&lt;span class="hx-absolute -hx-mt-20" id="分布式应用">&lt;/span>
&lt;a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e5%ba%94%e7%94%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;a href="https://gitee.com/jd-platform-opensource/hotkey" target="_blank" rel="noopener">JD-hotkey&lt;/a>。&lt;/li>
&lt;li>&lt;a href="https://my.oschina.net/1Gk2fdm43/blog/4331985" target="_blank" rel="noopener">https://my.oschina.net/1Gk2fdm43/blog/4331985&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/hotkey-arch.png" alt="hotkey-arch" loading="lazy" />&lt;/p>
&lt;p>该框架主要由 4 个部分组成：&lt;/p>
&lt;ol>
&lt;li>etcd 集群&lt;/li>
&lt;/ol>
&lt;p>etcd 作为一个高性能的配置中心，可以以极小的资源占用，提供高效的监听订阅服务。主要用于存放规则配置，各 worker 的 ip 地址，以及探测出的热 key、手工添加的热 key 等。&lt;/p>
&lt;ol start="2">
&lt;li>client 端 jar 包&lt;/li>
&lt;/ol>
&lt;p>就是在服务中添加的引用 jar，引入后，就可以以便捷的方式去判断某 key 是否热 key。同时，该 jar 完成了 key 上报、监听 etcd 里的 rule 变化、worker 信息变化、热 key 变化，对热 key 进行本地 caffeine 缓存等。&lt;/p>
&lt;ol start="3">
&lt;li>worker 端集群&lt;/li>
&lt;/ol>
&lt;p>worker 端是一个独立部署的 Java 程序，启动后会连接 etcd，并定期上报自己的 ip 信息，供 client 端获取地址并进行长连接。之后，主要就是对各个 client 发来的待测 key 进行累加计算，当达到 etcd 里设定的 rule 阈值后，将热 key 推送到各个 client。&lt;/p>
&lt;ol start="4">
&lt;li>dashboard 控制台&lt;/li>
&lt;/ol>
&lt;p>控制台是一个带可视化界面的 Java 程序，也是连接到 etcd，之后在控制台设置各个 APP 的 key 规则，譬如 2 秒出现 20 次算热 key。然后当 worker 探测出来热 key 后，会将 key 发往 etcd，dashboard 也会监听热 key 信息，进行入库保存记录。同时，dashboard 也可以手工添加、删除热 key，供各个 client 端监听。&lt;/p>
&lt;p>&lt;img src="https://raw.gitcode.com/shipengqi/illustrations/files/main/db/hotkey-arch2.png" alt="hotkey-arch2" loading="lazy" />&lt;/p>
&lt;p>上图中的第一步，其实是不需要的，因为这里是热点探测系统主动将热 Key 推送给应用实例，不需要应用实例去拉取。&lt;/p>
&lt;p>写操作通过 MQ 或者长连接的方式将数据推送给热点探测系统。&lt;/p></description></item><item><title>开发规范</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/11_specifications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/11_specifications/</guid><description>
&lt;h2>键值设计&lt;span class="hx-absolute -hx-mt-20" id="键值设计">&lt;/span>
&lt;a href="#%e9%94%ae%e5%80%bc%e8%ae%be%e8%ae%a1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>key 名设计&lt;span class="hx-absolute -hx-mt-20" id="key-名设计">&lt;/span>
&lt;a href="#key-%e5%90%8d%e8%ae%be%e8%ae%a1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>可读性和可管理性&lt;/li>
&lt;/ol>
&lt;p>以业务名(或数据库名)为前缀(防止 key 冲突)，用冒号分隔，比如 &lt;code>业务名:表名:id&lt;/code>：&lt;code>trade:order:1&lt;/code>。&lt;/p>
&lt;ol start="2">
&lt;li>简洁性&lt;/li>
&lt;/ol>
&lt;p>保证语义的前提下，控制 key 的长度，当 key 较多时，内存占用也不容忽视，例如：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">user:&lt;span class="o">{&lt;/span>uid&lt;span class="o">}&lt;/span>:friends:messages:&lt;span class="o">{&lt;/span>mid&lt;span class="o">}&lt;/span> 简化为 u:&lt;span class="o">{&lt;/span>uid&lt;span class="o">}&lt;/span>:fr:m:&lt;span class="o">{&lt;/span>mid&lt;span class="o">}&lt;/span>。&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="3">
&lt;li>不要包含特殊字符&lt;/li>
&lt;/ol>
&lt;p>反例：包含空格、换行、单双引号以及其他转义字符。&lt;/p>
&lt;h3>value 设计&lt;span class="hx-absolute -hx-mt-20" id="value-设计">&lt;/span>
&lt;a href="#value-%e8%ae%be%e8%ae%a1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>拒绝 bigkey&lt;span class="hx-absolute -hx-mt-20" id="拒绝-bigkey">&lt;/span>
&lt;a href="#%e6%8b%92%e7%bb%9d-bigkey" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>在 Redis 中，一个字符串最大 512MB，一个二级数据结构（例如 hash、list、set、zset）可以存储大约 40 亿个 (2^32-1) 个元素，但实际中如果下面两种情况，我就会认为它是 bigkey。&lt;/p>
&lt;ol>
&lt;li>字符串类型：它的 big 体现在单个 value 值很大，一般认为超过 10KB 就是 bigkey。&lt;/li>
&lt;li>非字符串类型：哈希、列表、集合、有序集合，它们的 big 体现在元素个数太多。&lt;/li>
&lt;/ol>
&lt;p>一般来说，string 类型控制在 10KB 以内，hash、list、set、zset 元素个数不要超过5000。&lt;/p>
&lt;div class="hx-overflow-x-auto hx-mt-6 hx-flex hx-rounded-lg hx-border hx-py-2 ltr:hx-pr-4 rtl:hx-pl-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-blue-200 hx-bg-blue-100 hx-text-blue-900 dark:hx-border-blue-200/30 dark:hx-bg-blue-900/30 dark:hx-text-blue-200">
&lt;div class="ltr:hx-pl-3 ltr:hx-pr-2 rtl:hx-pr-3 rtl:hx-pl-2">&lt;div class="hx-select-none hx-text-xl" style="font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">ℹ️&lt;/div>&lt;/div>
&lt;div class="hx-w-full hx-min-w-0 hx-leading-7">
&lt;div class="hx-mt-6 hx-leading-7 first:hx-mt-0">非字符串的 bigkey，不要使用 &lt;code>del&lt;/code> 删除，使用 &lt;code>hscan&lt;/code>、&lt;code>sscan&lt;/code>、&lt;code>zscan&lt;/code> 方式渐进式删除，同时要注意&lt;strong>防止 bigkey 过期时间自动删除问题&lt;/strong>（例如一个 200 万的 zset 设置 1 小时过期，会触发 &lt;code>del&lt;/code> 操作，造成阻塞）。&lt;/div>
&lt;/div>
&lt;/div>
&lt;h5>bigkey 的危害&lt;span class="hx-absolute -hx-mt-20" id="bigkey-的危害">&lt;/span>
&lt;a href="#bigkey-%e7%9a%84%e5%8d%b1%e5%ae%b3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ol>
&lt;li>&lt;strong>导致 Redis 阻塞&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>网络拥塞&lt;/strong>。bigkey 也就意味着每次获取要产生的网络流量较大，假设一个 bigkey 为 1MB，客户端每秒访问量为 1000，那么每秒产生 1000MB 的流量，对于普通的千兆网卡(按照字节算是 &lt;code>128MB/s&lt;/code>)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个 bigkey 可能会对其他实例也造成影响，其后果不堪设想。&lt;/li>
&lt;li>&lt;strong>过期删除&lt;/strong>。有个 bigkey，它安分守己（只执行简单的命令，例如 &lt;code>hget&lt;/code>、&lt;code>lpop&lt;/code>、&lt;code>zscore&lt;/code> 等），但它设置了过期时间，当它过期后，会被删除，如果没有使用 Redis 4.0 的&lt;strong>过期异步删除(&lt;code>lazyfree-lazy-expire yes&lt;/code>)&lt;/strong>，就会存在阻塞 Redis 的可能性。&lt;/li>
&lt;/ol>
&lt;h5>bigkey 的产生&lt;span class="hx-absolute -hx-mt-20" id="bigkey-的产生">&lt;/span>
&lt;a href="#bigkey-%e7%9a%84%e4%ba%a7%e7%94%9f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>一般来说，bigkey 的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，来看几个例子：&lt;/p>
&lt;ol>
&lt;li>社交类：粉丝列表，如果某些明星或者大 v 不精心设计下，必是 bigkey。&lt;/li>
&lt;li>统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是 bigkey。&lt;/li>
&lt;li>缓存类：将数据从数据库 &lt;code>load&lt;/code> 出来序列化放到 Redis 里，这个方式非常常用，但有两个地方需要注意，第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个 key 下，产生 bigkey。&lt;/li>
&lt;/ol>
&lt;h5>如何优化 bigkey&lt;span class="hx-absolute -hx-mt-20" id="如何优化-bigkey">&lt;/span>
&lt;a href="#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96-bigkey" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ol>
&lt;li>拆&lt;/li>
&lt;/ol>
&lt;p>big list： list1、list2、&amp;hellip;listN
big hash：可以将数据分段存储，比如一个大的 key，假设存了 1 百万的用户数据，可以拆分成 200 个 key，每个 key 下面存放 5000 个用户数据&lt;/p>
&lt;ol start="2">
&lt;li>如果 bigkey 不可避免，也要思考一下&lt;strong>要不要每次把所有元素都取出来&lt;/strong> (例如有时候仅仅需要 &lt;code>hmget&lt;/code>，而不是 &lt;code>hgetall&lt;/code>)，&lt;strong>删除也是一样&lt;/strong>，尽量使用优雅的方式来处理。&lt;/li>
&lt;/ol>
&lt;h4>选择适合的数据类型&lt;span class="hx-absolute -hx-mt-20" id="选择适合的数据类型">&lt;/span>
&lt;a href="#%e9%80%89%e6%8b%a9%e9%80%82%e5%90%88%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如 ziplist，但也要注意节省内存和性能之间的平衡)，设置合理的过期时间。&lt;/p>
&lt;p>反例：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">set&lt;/span> user:1:name tom
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">set&lt;/span> user:1:age &lt;span class="m">19&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">set&lt;/span> user:1:favor football&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>正例:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">hmset user:1 name tom age &lt;span class="m">19&lt;/span> favor football&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>控制 key 的生命周期&lt;span class="hx-absolute -hx-mt-20" id="控制-key-的生命周期">&lt;/span>
&lt;a href="#%e6%8e%a7%e5%88%b6-key-%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>使用 &lt;code>expire&lt;/code> 设置过期时间(条件允许可以打散过期时间，防止集中过期)。&lt;/p>
&lt;h2>命令使用&lt;span class="hx-absolute -hx-mt-20" id="命令使用">&lt;/span>
&lt;a href="#%e5%91%bd%e4%bb%a4%e4%bd%bf%e7%94%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>&lt;code>O(N)&lt;/code> 命令关注 N 的数量&lt;/li>
&lt;/ol>
&lt;p>例如 &lt;code>hgetall&lt;/code>、&lt;code>lrange&lt;/code>、&lt;code>smembers&lt;/code>、&lt;code>zrange&lt;/code>、&lt;code>sinter&lt;/code> 等并非不能使用，但是需要明确 N 的值。有遍历的需求可以使用 &lt;code>hscan&lt;/code>、&lt;code>sscan&lt;/code>、&lt;code>zscan&lt;/code> 代替。&lt;/p>
&lt;ol start="2">
&lt;li>禁用命令&lt;/li>
&lt;/ol>
&lt;p>禁止线上使用 &lt;code>keys&lt;/code>、&lt;code>flushall&lt;/code>、&lt;code>flushdb&lt;/code> 等，通过 Redis 的 &lt;strong>&lt;code>rename&lt;/code> 机制禁掉命令&lt;/strong>，或者使用 &lt;code>scan&lt;/code> 的方式渐进式处理。&lt;/p>
&lt;ol start="3">
&lt;li>合理使用 &lt;code>select&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>Redis 的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时&lt;strong>多业务用多数据库实际还是单线程处理&lt;/strong>，会有干扰。&lt;/p>
&lt;ol start="4">
&lt;li>使用批量操作提高效率&lt;/li>
&lt;/ol>
&lt;p>原生命令：例如 &lt;code>mget&lt;/code>、&lt;code>mset&lt;/code>。
非原生命令：可以使用 &lt;code>pipeline&lt;/code> 提高效率。&lt;/p>
&lt;p>但要注意控制一次批量操作的元素个数(例如 500 以内，实际也和元素字节数有关)。
注意两者不同：&lt;/p>
&lt;ul>
&lt;li>原生命令是原子操作，pipeline 是非原子操作。&lt;/li>
&lt;li>pipeline 可以打包不同的命令，原生命令做不到&lt;/li>
&lt;li>pipeline 需要客户端和服务端同时支持。&lt;/li>
&lt;/ul>
&lt;ol start="5">
&lt;li>Redis 事务功能较弱，不建议过多使用，可以用 lua 替代。&lt;/li>
&lt;/ol>
&lt;h2>客户端使用&lt;span class="hx-absolute -hx-mt-20" id="客户端使用">&lt;/span>
&lt;a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e4%bd%bf%e7%94%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>避免多个应用使用一个 Redis 实例。不相干的业务拆分，公共数据做服务化。&lt;/li>
&lt;li>使用带有连接池的数据库，可以有效控制连接，同时提高效率。&lt;/li>
&lt;li>高并发下建议客户端添加熔断功能(例如 sentinel、hystrix)。&lt;/li>
&lt;li>设置合理的密码，如有必要可以使用 SSL 加密访问。&lt;/li>
&lt;/ol>
&lt;h3>连接池&lt;span class="hx-absolute -hx-mt-20" id="连接池">&lt;/span>
&lt;a href="#%e8%bf%9e%e6%8e%a5%e6%b1%a0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>使用带有连接池，可以有效控制连接，同时提高效率，标准使用方式：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">JedisPoolConfig&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jedisPoolConfig&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">JedisPoolConfig&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">jedisPoolConfig&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setMaxTotal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">jedisPoolConfig&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setMaxIdle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">jedisPoolConfig&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setTestOnBorrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">JedisPool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jedisPool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">JedisPool&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">jedisPoolConfig&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;192.168.0.60&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">6379&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">3000&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jedisPool&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getResource&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//具体的命令&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">executeCommand&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Exception&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;op key {} error: &amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getMessage&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">finally&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">close&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>连接池参数含义：&lt;/p>
&lt;ul>
&lt;li>&lt;code>maxTotal&lt;/code>：最大连接数，早期的版本叫 maxActive。设置该值，需要考虑的因素
&lt;ul>
&lt;li>业务期望的 QPS&lt;/li>
&lt;li>客户端执行命令时间&lt;/li>
&lt;li>Redis 资源：例如 &lt;code>nodes(例如应用个数) * maxTotal&lt;/code> 是不能超过 Redis 的最大连接数 &lt;code>maxclients&lt;/code>。&lt;/li>
&lt;li>资源开销：例如虽然希望控制空闲连接(连接池此刻可马上使用的连接)，但是不希望因为连接池的频繁释放创建连接造成不必靠开销。&lt;/li>
&lt;li>假设: 一次命令时间（borrow|return resource + Jedis 执行命令(含网络) ）的平均耗时约为 1ms，一个连接的 QPS 大约是 1000。业务期望的 QPS 是 50000。那么理论上需要的资源池大小是 &lt;code>50000 / 1000 = 50&lt;/code> 个。但事实上这是个理论值，还要考虑到要比理论值预留一些资源，通常来讲 &lt;code>maxTotal&lt;/code> 可以比理论值大一些。但这个值不是越大越好，一方面连接太多占用客户端和服务端资源，另一方面对于 Redis 这种高 QPS 的服务器，一个大命令的阻塞即使设置再大资源池仍然会无济于事。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>maxIdle&lt;/code> 和 &lt;code>minIdle&lt;/code>：&lt;code>maxIdle&lt;/code> 实际上才是业务需要的最大连接数，&lt;code>maxTotal&lt;/code> 是为了给出&lt;strong>余量&lt;/strong>，所以 &lt;code>maxIdle&lt;/code> 不要设置过小，否则会有 &lt;code>new Jedis&lt;/code> (新连接)开销。&lt;strong>连接池的最佳性能是 &lt;code>maxTotal = maxIdle&lt;/code>&lt;/strong>。这样就避免连接池伸缩带来的性能干扰。但是如果并发量不大或者 &lt;code>maxTotal&lt;/code> 设置过高，会导致不必要的连接资源浪费。一般推荐 &lt;code>maxIdle&lt;/code> 可以设置为按业务期望 QPS 计算出来的理论连接数，&lt;code>maxTotal&lt;/code> 可以再放大一倍。&lt;/li>
&lt;li>&lt;code>minIdle&lt;/code>：&lt;code>minIdle&lt;/code>（最小空闲连接数），与其说是最小空闲连接数，不如说是&amp;quot;至少需要保持的空闲连接数&amp;quot;，在使用连接的过程中，如果连接数&lt;strong>超过了 &lt;code>minIdle&lt;/code>，那么继续建立连接&lt;/strong>，如果超过了 &lt;code>maxIdle&lt;/code>，当&lt;strong>超过的连接执行完业务后会慢慢被移出连接池释放掉&lt;/strong>。&lt;/li>
&lt;li>&lt;code>testOnBorrow&lt;/code>：在borrow一个 jedis 实例时，是否提前进行 validate 操作；如果为 true，则得到的 jedis 实例均是可用的；&lt;/li>
&lt;li>&lt;code>testOnReturn&lt;/code>：在 return 一个 jedis 实例时，是否提前进行 validate 操作；如果为 true，则返回的 jedis 实例均是可用的。&lt;/li>
&lt;/ul>
&lt;h4>连接池预热&lt;span class="hx-absolute -hx-mt-20" id="连接池预热">&lt;/span>
&lt;a href="#%e8%bf%9e%e6%8e%a5%e6%b1%a0%e9%a2%84%e7%83%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>Redis 初始化后是没有连接的，当需要使用连接时，才会创建连接。&lt;/p>
&lt;p>连接池预热在应用启动时，就创建好一定数量的连接，避免在使用时创建连接。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Jedis&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">minIdleJedisList&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Jedis&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">jedisPoolConfig&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getMinIdle&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jedisPoolConfig&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getMinIdle&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getResource&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">minIdleJedisList&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">ping&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Exception&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getMessage&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">finally&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 注意，这里不能马上close将连接还回连接池，否则最后连接池里只会建立 1 个连接。。&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// jedis.close();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 统一将预热的连接还回连接池&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jedisPoolConfig&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getMinIdle&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">minIdleJedisList&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//将连接归还回连接池&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jedis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">close&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Exception&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getMessage&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">finally&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>保护 Redis</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/12_protect_redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/12_protect_redis/</guid><description>
&lt;h2>指令安全&lt;span class="hx-absolute -hx-mt-20" id="指令安全">&lt;/span>
&lt;a href="#%e6%8c%87%e4%bb%a4%e5%ae%89%e5%85%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 有一些非常危险的指令。比如 &lt;code>keys&lt;/code> 指令会导致 Redis 卡顿，&lt;code>flushdb&lt;/code> 和 &lt;code>flushall&lt;/code> 会让 Redis 的所有数据全部清空。
如何避免人为操作失误导致这些灾难性的后果也是运维人员特别需要注意的风险点之一。&lt;/p>
&lt;p>Redis 在配置文件中提供了 &lt;code>rename-command&lt;/code> 指令用于将某些危险的指令修改成特别的名称，用来避免人为误操作。比如在配置文
件的 &lt;code>security&lt;/code> 块增加下面的内容:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>rename-command keys abckeysabc&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>如果还想执行 &lt;code>keys&lt;/code> 方法，需要键入 &lt;code>abckeysabc&lt;/code>。如果想&lt;strong>完全封杀某条指令，将指令 &lt;code>rename&lt;/code> 成空串，就无法通过任何字符串指令来执行这
条指令&lt;/strong>了：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>rename-command flushall &amp;#34;&amp;#34;&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>端口安全&lt;span class="hx-absolute -hx-mt-20" id="端口安全">&lt;/span>
&lt;a href="#%e7%ab%af%e5%8f%a3%e5%ae%89%e5%85%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 默认会监听 &lt;code>*:6379&lt;/code>，Redis 的服务地址一旦可以被外网直接访问，黑客可以通过 Redis 执行 Lua 脚本拿到服务器权限。&lt;/p>
&lt;p>所以，务必在 Redis 的配置文件中指定监听的 IP 地址。更进一步，还可以增加 Redis 的密码访问限制，客户端必须使用 &lt;code>auth&lt;/code> 指令传入正
确的密码才可以访问 Redis，这样即使地址暴露出去了，普通黑客也无法对 Redis 进行任何指令操作。&lt;/p>
&lt;h2>Lua 脚本安全&lt;span class="hx-absolute -hx-mt-20" id="lua-脚本安全">&lt;/span>
&lt;a href="#lua-%e8%84%9a%e6%9c%ac%e5%ae%89%e5%85%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>禁止 Lua 脚本由用户输入的内容 (UGC) 生成，避免黑客利用以植入恶意的攻击代码来得到 Redis 的主机权限。Redis 应该以普通用户的身份启动。&lt;/p>
&lt;h2>SSL 代理&lt;span class="hx-absolute -hx-mt-20" id="ssl-代理">&lt;/span>
&lt;a href="#ssl-%e4%bb%a3%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 并不支持 SSL 链接，意味着客户端和服务器之间交互的数据不应该直接暴露在公网上传输，否则会有被窃听的风险。如果必须要用在公网上，可
以考虑使用 SSL 代理。&lt;/p>
&lt;p>Redis 官方推荐使用 &lt;a href="http://www.tarsnap.com/spiped.html" target="_blank" rel="noopener">spiped&lt;/a> 工具，可能是因为 spiped 的功能相对比较单一，使用也比较
简单，易于理解。&lt;/p>
&lt;h3>spiped 原理&lt;span class="hx-absolute -hx-mt-20" id="spiped-原理">&lt;/span>
&lt;a href="#spiped-%e5%8e%9f%e7%90%86" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>spiped 会在客户端和服务器各启动一个 spiped 进程。&lt;/p>
&lt;p>spiped 进程 A 负责接受来自 Redis Client 发送过来的请求数据，加密后传送到右边的 spiped 进程 B。spiped B 将接收到的数据解密后传
递到 Redis Server。然后 Redis Server 再走一个反向的流程将响应回复给 Redis Client。&lt;/p></description></item><item><title>慢查询日志</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/13_slowlog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/13_slowlog/</guid><description>
&lt;p>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求，可以通过这个功能产生的日志来监视和优化查询速度。&lt;/p>
&lt;p>服务器配置有两个和慢查询日志相关的选项：&lt;/p>
&lt;ul>
&lt;li>&lt;code>slowlog-log-slower-than&lt;/code> 选项指定执行时间超过多少微秒（1 秒等于 1,000,000 微秒）的命令请求会被记录到日志上。&lt;/li>
&lt;li>&lt;code>slowlog-max-len&lt;/code> 选项指定服务器最多保存多少条慢查询日志。当服务器储存的慢查询日志数量等于 &lt;code>slowlog-max-len&lt;/code> 选项的值时，服务器在添加一条新的慢查询日志之前， 会先将最旧的一条慢查询日志删除。&lt;/li>
&lt;/ul>
&lt;h2>查看慢查询日志&lt;span class="hx-absolute -hx-mt-20" id="查看慢查询日志">&lt;/span>
&lt;a href="#%e6%9f%a5%e7%9c%8b%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>使用 &lt;code>SLOWLOG GET&lt;/code> 命令查看服务器所保存的慢查询日志：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">redis&amp;gt; SLOWLOG GET
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="c1"># 日志的唯一标识符（uid）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">1378781447&lt;/span> &lt;span class="c1"># 命令执行时的 UNIX 时间戳&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="c1"># 命令执行的时长，以微秒计算&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4&lt;span class="o">)&lt;/span> 1&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;SET&amp;#34;&lt;/span> &lt;span class="c1"># 命令以及命令参数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;database&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3&lt;span class="o">)&lt;/span> &lt;span class="s2">&amp;#34;Redis&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>漏斗限流</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/14_funnel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/14_funnel/</guid><description>
&lt;p>Redis 漏斗限流（Rate Limiter）是一种常用的限流技术，用于控制对某个资源或服务的访问频率，以防止服务被过度使用或遭受滥用。漏斗限流算法通过模拟水流从一个漏斗中流出，来限制数据的传输速率。在 Redis 中，可以通过使用 Redis 的原子操作和一些数据结构来实现漏斗限流，例如使用 Redis 的 &lt;code>INCR&lt;/code>、&lt;code>INCRBY&lt;/code>、&lt;code>EXPIRE&lt;/code>、&lt;code>SETEX&lt;/code> 等命令，或者使用 Redis 的 Lua 脚本来实现更复杂的逻辑。&lt;/p>
&lt;p>漏斗限流的基本原理&lt;/p>
&lt;ul>
&lt;li>固定容量和速率：
&lt;ul>
&lt;li>漏斗有一个固定的容量（capacity），表示在单位时间内可以处理的最大请求数。&lt;/li>
&lt;li>漏斗还有一个固定的泄漏速率（rate），表示每秒可以从漏斗中泄漏（即允许处理的）请求数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>时间窗口：
&lt;ul>
&lt;li>通常，漏斗限流是基于一个固定时间窗口（例如1秒）来计算和执行限制的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2>实现方式&lt;span class="hx-absolute -hx-mt-20" id="实现方式">&lt;/span>
&lt;a href="#%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;h3>使用 Redis 命令实现&lt;span class="hx-absolute -hx-mt-20" id="使用-redis-命令实现">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8-redis-%e5%91%bd%e4%bb%a4%e5%ae%9e%e7%8e%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;strong>存储请求数&lt;/strong>：&lt;/p>
&lt;p>使用一个 Redis 键来存储当前时间窗口内的请求数。例如，使用 &lt;code>INCR&lt;/code> 命令增加请求数。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">INCR key:requests:user_id&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>设置时间窗口&lt;/strong>：&lt;/p>
&lt;p>使用 &lt;code>EXPIRE&lt;/code> 命令设置时间窗口的过期时间，例如每秒重置一次。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">EXPIRE key:requests:user_id &lt;span class="m">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>检查请求数&lt;/strong>：&lt;/p>
&lt;p>在执行请求前，先检查当前时间窗口内的请求数是否超过了容量限制。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">GET key:requests:user_id&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>如果请求数大于等于容量，则拒绝请求；否则，继续处理。&lt;/p>
&lt;h3>使用 Lua 脚本实现更复杂的逻辑&lt;span class="hx-absolute -hx-mt-20" id="使用-lua-脚本实现更复杂的逻辑">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8-lua-%e8%84%9a%e6%9c%ac%e5%ae%9e%e7%8e%b0%e6%9b%b4%e5%a4%8d%e6%9d%82%e7%9a%84%e9%80%bb%e8%be%91" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>对于更复杂的漏斗限流逻辑（如动态调整速率），可以使用 Redis 的 Lua 脚本来实现。Lua 脚本可以在服务器端原子地执行多个命令，避免了多命令执行中的竞态条件。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-lua" data-lang="lua">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">--[[
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">漏斗限流算法核心逻辑：
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">1. KEYS[1] 限流器唯一标识
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">2. ARGV[1] rate 每秒允许的请求数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">3. ARGV[2] capacity 漏斗总容量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">--]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">local&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">-- 限流器存储 key，例如: user_123_api_limit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">local&lt;/span> &lt;span class="n">rate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tonumber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">-- 漏嘴流速（每秒允许请求数）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">local&lt;/span> &lt;span class="n">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tonumber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">-- 漏斗总容量（最大突发请求数）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 获取当前漏斗状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">local&lt;/span> &lt;span class="n">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tonumber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;get&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">-- 当前剩余容量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">local&lt;/span> &lt;span class="n">timestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tonumber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;get&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">..&lt;/span> &lt;span class="s1">&amp;#39;:timestamp&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="s2">&amp;#34;0&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">-- 上次更新时间戳&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">local&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tonumber&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;time&amp;#39;&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">-- 当前 Redis 服务器时间（秒）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 时间窗口检测（每秒重置一次漏斗）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">if&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">timestamp&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="kr">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">-- 距离上次请求超过 1 秒，重置漏斗&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">capacity&lt;/span> &lt;span class="c1">-- 恢复漏斗最大容量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">timestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="c1">-- 记录新时间窗口起点&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">-- 打印调试信息（生产环境需移除）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">-- redis.log(redis.LOG_NOTICE, &amp;#34;漏斗重置 current:&amp;#34;..current..&amp;#34; timestamp:&amp;#34;..timestamp)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">end&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 计算剩余容量（核心算法）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">if&lt;/span> &lt;span class="n">current&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="kr">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">-- 漏斗有剩余容量时：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">local&lt;/span> &lt;span class="n">allowed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1">-- 允许本次请求&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1">-- 消耗 1 个容量单位&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">-- 更新存储（带1秒过期时间）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;setex&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">-- 存储剩余容量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;setex&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">..&lt;/span> &lt;span class="s1">&amp;#39;:timestamp&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">timestamp&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">-- 存储时间窗口起点&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">-- 返回允许请求，并返回剩余容量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="c1">-- 第一个值1表示允许，第二个值返回剩余容量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">-- 漏斗容量已耗尽&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">-- 返回拒绝请求，并返回剩余容量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">end&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>总结&lt;span class="hx-absolute -hx-mt-20" id="总结">&lt;/span>
&lt;a href="#%e6%80%bb%e7%bb%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Redis 的漏斗限流通过结合原子操作和过期策略，可以有效地限制对资源的访问速率。无论是使用简单的 Redis 命令还是通过 Lua 脚本实现更复杂的逻辑，都可以根据实际需求选择合适的方法来达到限流的目的。&lt;/p></description></item><item><title>一些命令行技巧</title><link>https://shipengqi.github.io/db-learn/docs/redis/practice/19_skills/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shipengqi.github.io/db-learn/docs/redis/practice/19_skills/</guid><description>
&lt;h2>Info 指令&lt;span class="hx-absolute -hx-mt-20" id="info-指令">&lt;/span>
&lt;a href="#info-%e6%8c%87%e4%bb%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;code>Info&lt;/code> 指令，可以清晰地知道 Redis 内部一系列运行参数。&lt;/p>
&lt;p>&lt;code>Info&lt;/code> 指令显示的信息非常繁多，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是:&lt;/p>
&lt;ol>
&lt;li>Server 服务器运行的环境参数&lt;/li>
&lt;li>Clients 客户端相关信息&lt;/li>
&lt;li>Memory 服务器运行内存统计数据&lt;/li>
&lt;li>Persistence 持久化信息&lt;/li>
&lt;li>Stats 通用统计数据&lt;/li>
&lt;li>Replication 主从复制相关信息&lt;/li>
&lt;li>CPU CPU 使用情况&lt;/li>
&lt;li>Cluster 集群信息&lt;/li>
&lt;li>KeySpace 键值对统计数量信息&lt;/li>
&lt;/ol>
&lt;p>&lt;code>Info&lt;/code> 可以一次性获取所有的信息，也可以按块取信息。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取所有信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; info
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取内存相关信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; info memory
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取复制相关信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; info replication&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>直接模式&lt;span class="hx-absolute -hx-mt-20" id="直接模式">&lt;/span>
&lt;a href="#%e7%9b%b4%e6%8e%a5%e6%a8%a1%e5%bc%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>一般使用 redis-cli 都会进入交互模式，然后一问一答来读写服务器，这是&lt;strong>交互模式&lt;/strong>。还有一种&lt;strong>直接模式&lt;/strong>，通过将命令参数直接
传递给 redis-cli 来执行指令并获取输出结果。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ redis-cli incrby foo &lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">(&lt;/span>integer&lt;span class="o">)&lt;/span> &lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 输出的内容较大，可以将输出重定向到外部文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ redis-cli info &amp;gt; info.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ wc -l info.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="m">120&lt;/span> info.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 如果想指向特定的服务器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -n 2 表示使用第 2 个库，相当于 select 2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ redis-cli -h localhost -p &lt;span class="m">6379&lt;/span> -n &lt;span class="m">2&lt;/span> ping
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PONG&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>批量执行命令&lt;span class="hx-absolute -hx-mt-20" id="批量执行命令">&lt;/span>
&lt;a href="#%e6%89%b9%e9%87%8f%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ cat cmds.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">set&lt;/span> foo1 bar1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">set&lt;/span> foo2 bar2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">set&lt;/span> foo3 bar3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">......
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cat cmds.txt &lt;span class="p">|&lt;/span> redis-cli
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 或者&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ redis-cli &amp;lt; cmds.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>set 多行字符串&lt;span class="hx-absolute -hx-mt-20" id="set-多行字符串">&lt;/span>
&lt;a href="#set-%e5%a4%9a%e8%a1%8c%e5%ad%97%e7%ac%a6%e4%b8%b2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>如果一个字符串有多行，如何传入 &lt;code>set&lt;/code> 指令？使用 &lt;code>-x&lt;/code> 选项，该选项会使用标准输入的内容作为最后一个参数。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ cat str.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Ernest Hemingway once wrote,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;The world is a fine place and worth fighting for.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">I agree with the second part.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ redis-cli -x &lt;span class="nb">set&lt;/span> foo &amp;lt; str.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ redis-cli get foo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;Ernest Hemingway once wrote,\n\&amp;#34;The world is a fine place and worth fighting for.\&amp;#34;\nI agree with the second part.\n&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>重复执行指令&lt;span class="hx-absolute -hx-mt-20" id="重复执行指令">&lt;/span>
&lt;a href="#%e9%87%8d%e5%a4%8d%e6%89%a7%e8%a1%8c%e6%8c%87%e4%bb%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>redis-cli 还支持重复执行指令多次，每条指令执行之间设置一个间隔时间，如此便可以观察某条指令的输出内容随时间变化。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">// 间隔 1s，执行 &lt;span class="m">5&lt;/span> 次，观察 qps 的变化
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ redis-cli -r &lt;span class="m">5&lt;/span> -i &lt;span class="m">1&lt;/span> info &lt;span class="p">|&lt;/span> grep ops
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">instantaneous_ops_per_sec:43469
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">instantaneous_ops_per_sec:47460
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">instantaneous_ops_per_sec:47699
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">instantaneous_ops_per_sec:46434
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">instantaneous_ops_per_sec:47216&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>如果将次数设置为 &lt;code>-1&lt;/code> 那就是重复无数次永远执行下去。如果不提供 &lt;code>-i&lt;/code> 参数，那就没有间隔，连续重复执行。&lt;/p>
&lt;p>在交互模式下也可以重复执行指令，形式上比较怪异，在指令前面增加次数&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; &lt;span class="m">5&lt;/span> ping
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PONG
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PONG
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PONG
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PONG
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PONG&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>监控服务器状态&lt;span class="hx-absolute -hx-mt-20" id="监控服务器状态">&lt;/span>
&lt;a href="#%e7%9b%91%e6%8e%a7%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%8a%b6%e6%80%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>可以使用 &lt;code>--stat&lt;/code> 参数来实时监控服务器的状态，间隔 1s 实时输出一次。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ redis-cli --stat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">------- data ------ --------------------- load -------------------- - child -
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">keys mem clients blocked requests connections
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span> 6.66M &lt;span class="m">100&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">11591628&lt;/span> &lt;span class="o">(&lt;/span>+0&lt;span class="o">)&lt;/span> &lt;span class="m">335&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span> 6.66M &lt;span class="m">100&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">11653169&lt;/span> &lt;span class="o">(&lt;/span>+61541&lt;span class="o">)&lt;/span> &lt;span class="m">335&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span> 6.66M &lt;span class="m">100&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">11706550&lt;/span> &lt;span class="o">(&lt;/span>+53381&lt;span class="o">)&lt;/span> &lt;span class="m">335&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span> 6.54M &lt;span class="m">100&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">11758831&lt;/span> &lt;span class="o">(&lt;/span>+52281&lt;span class="o">)&lt;/span> &lt;span class="m">335&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span> 6.66M &lt;span class="m">100&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">11803132&lt;/span> &lt;span class="o">(&lt;/span>+44301&lt;span class="o">)&lt;/span> &lt;span class="m">335&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span> 6.66M &lt;span class="m">100&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">11854183&lt;/span> &lt;span class="o">(&lt;/span>+51051&lt;span class="o">)&lt;/span> &lt;span class="m">335&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>可以使用 &lt;code>-i&lt;/code> 参数调整输出间隔。&lt;/p>
&lt;h2>扫描大 KEY&lt;span class="hx-absolute -hx-mt-20" id="扫描大-key">&lt;/span>
&lt;a href="#%e6%89%ab%e6%8f%8f%e5%a4%a7-key" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>遇到 Redis 偶然卡顿问题，第一个想到的就是实例中是否存在大 KEY，大 KEY 的内存扩容以及释放都会导致主线程卡顿。&lt;code>--bigkeys&lt;/code> 参数可以很快扫出内存里的大 KEY，使用 &lt;code>-i&lt;/code> 参数控制扫描间隔，避免扫描指令导致服务器的 ops 陡增报警。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ ./redis-cli --bigkeys -i 0.01
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Scanning the entire keyspace to find biggest keys as well as&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># average sizes per key type. You can use -i 0.1 to sleep 0.1 sec&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># per 100 SCAN commands (not usually needed).&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>00.00%&lt;span class="o">]&lt;/span> Biggest zset found so far &lt;span class="s1">&amp;#39;hist:aht:main:async_finish:20180425:17&amp;#39;&lt;/span> with &lt;span class="m">1440&lt;/span> members
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>00.00%&lt;span class="o">]&lt;/span> Biggest zset found so far &lt;span class="s1">&amp;#39;hist:qps:async:authorize:20170311:27&amp;#39;&lt;/span> with &lt;span class="m">2465&lt;/span> members
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>00.00%&lt;span class="o">]&lt;/span> Biggest &lt;span class="nb">hash&lt;/span> found so far &lt;span class="s1">&amp;#39;job:counters:6ya9ypu6ckcl&amp;#39;&lt;/span> with &lt;span class="m">3&lt;/span> fields
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>00.01%&lt;span class="o">]&lt;/span> Biggest string found so far &lt;span class="s1">&amp;#39;rt:aht:main:device_online:68:{-4}&amp;#39;&lt;/span> with &lt;span class="m">4&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>00.01%&lt;span class="o">]&lt;/span> Biggest zset found so far &lt;span class="s1">&amp;#39;machine:load:20180709&amp;#39;&lt;/span> with &lt;span class="m">2879&lt;/span> members
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>00.02%&lt;span class="o">]&lt;/span> Biggest string found so far &lt;span class="s1">&amp;#39;6y6fze8kj7cy:{-7}&amp;#39;&lt;/span> with &lt;span class="m">90&lt;/span> bytes&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>redis-cli 对于每一种对象类型都会记录长度最大的 KEY，对于每一种对象类型，刷新一次最高记录就会立即输出一次。它能保证输出长度为 Top1 的 KEY，但是 Top2、Top3 等 KEY 是无法保证可以扫描出来的。一般的处理方法是多扫描几次，或者是消灭了 Top1 的 KEY 之后再扫描确认还有没有次大的 KEY。&lt;/p>
&lt;h2>采样服务器指令&lt;span class="hx-absolute -hx-mt-20" id="采样服务器指令">&lt;/span>
&lt;a href="#%e9%87%87%e6%a0%b7%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%8c%87%e4%bb%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>现在线上有一台 Redis 服务器的 OPS 太高，有很多业务模块都在使用这个 Redis，如何才能判断出来是哪个业务导致了 OPS 异常的高。这时可以对线上服务器的指令进行采样，观察采样的指令大致就可以分析出 OPS 占比高的业务点。这时就要使用 &lt;code>monitor&lt;/code> 指令，它会将服务器瞬间执行的指令全部显示出来。不过使用的时候要注意即使使用 &lt;code>ctrl+c&lt;/code> 中断，否则你的显示器会噼里啪啦太多的指令瞬间让你眼花缭乱。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ redis-cli --host 192.168.x.x --port &lt;span class="m">6379&lt;/span> monitor
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1539853410.458483 &lt;span class="o">[&lt;/span>&lt;span class="m">0&lt;/span> 10.100.90.62:34365&lt;span class="o">]&lt;/span> &lt;span class="s2">&amp;#34;GET&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;6yax3eb6etq8:{-7}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1539853410.459212 &lt;span class="o">[&lt;/span>&lt;span class="m">0&lt;/span> 10.100.90.61:56659&lt;span class="o">]&lt;/span> &lt;span class="s2">&amp;#34;PFADD&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;growth:dau:20181018&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;2klxkimass8w&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1539853410.462938 &lt;span class="o">[&lt;/span>&lt;span class="m">0&lt;/span> 10.100.90.62:20681&lt;span class="o">]&lt;/span> &lt;span class="s2">&amp;#34;GET&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;6yax3eb6etq8:{-7}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1539853410.467231 &lt;span class="o">[&lt;/span>&lt;span class="m">0&lt;/span> 10.100.90.61:40277&lt;span class="o">]&lt;/span> &lt;span class="s2">&amp;#34;PFADD&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;growth:dau:20181018&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;2kei0to86ps1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1539853410.470319 &lt;span class="o">[&lt;/span>&lt;span class="m">0&lt;/span> 10.100.90.62:34365&lt;span class="o">]&lt;/span> &lt;span class="s2">&amp;#34;GET&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;6yax3eb6etq8:{-7}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1539853410.473927 &lt;span class="o">[&lt;/span>&lt;span class="m">0&lt;/span> 10.100.90.61:58128&lt;span class="o">]&lt;/span> &lt;span class="s2">&amp;#34;GET&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;6yax3eb6etq8:{-7}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1539853410.475712 &lt;span class="o">[&lt;/span>&lt;span class="m">0&lt;/span> 10.100.90.61:40277&lt;span class="o">]&lt;/span> &lt;span class="s2">&amp;#34;PFADD&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;growth:dau:20181018&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;2km8sqhlefpc&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1539853410.477053 &lt;span class="o">[&lt;/span>&lt;span class="m">0&lt;/span> 10.100.90.62:61292&lt;span class="o">]&lt;/span> &lt;span class="s2">&amp;#34;GET&amp;#34;&lt;/span> &lt;span class="s2">&amp;#34;6yax3eb6etq8:{-7}&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>诊断服务器时延&lt;span class="hx-absolute -hx-mt-20" id="诊断服务器时延">&lt;/span>
&lt;a href="#%e8%af%8a%e6%96%ad%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%97%b6%e5%bb%b6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>平时诊断两台机器的时延一般是使用 Unix 的 ping 指令。Redis 也提供了时延诊断指令，不过它的原理不太一样，它是诊断当前机器和 Redis 服务器之间的指令(PING 指令)时延，它不仅仅是物理网络的时延，还和当前的 Redis 主线程是否忙碌有关。如果你发现 Unix 的 ping 指令时延很小，而 Redis 的时延很大，那说明 Redis 服务器在执行指令时有微弱卡顿。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ redis-cli --host 192.168.x.x --port &lt;span class="m">6379&lt;/span> --latency
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">min: 0, max: 5, avg: 0.08 &lt;span class="o">(&lt;/span>&lt;span class="m">305&lt;/span> samples&lt;span class="o">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>时延单位是 &lt;code>ms&lt;/code>。redis-cli 还能显示时延的分布情况，而且是图形化输出。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">redis-cli --latency-dist&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>远程 rdb 备份&lt;span class="hx-absolute -hx-mt-20" id="远程-rdb-备份">&lt;/span>
&lt;a href="#%e8%bf%9c%e7%a8%8b-rdb-%e5%a4%87%e4%bb%bd" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>执行下面的命令就可以将远程的 Redis 实例备份到本地机器，远程服务器会执行一次 bgsave 操作，然后将 rdb 文件传输到客户端。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ ./redis-cli --host 192.168.x.x --port &lt;span class="m">6379&lt;/span> --rdb ./user.rdb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SYNC sent to master, writing &lt;span class="m">2501265095&lt;/span> bytes to &lt;span class="s1">&amp;#39;./user.rdb&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Transfer finished with success.&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h2>模拟从库&lt;span class="hx-absolute -hx-mt-20" id="模拟从库">&lt;/span>
&lt;a href="#%e6%a8%a1%e6%8b%9f%e4%bb%8e%e5%ba%93" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>如果你想观察主从服务器之间都同步了那些数据，可以使用 redis-cli 模拟从库。&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">$ ./redis-cli --host 192.168.x.x --port &lt;span class="m">6379&lt;/span> --slave
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SYNC with master, discarding &lt;span class="m">51778306&lt;/span> bytes of bulk transfer...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SYNC &lt;span class="k">done&lt;/span>. Logging commands from master.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>从库连上主库的第一件事是全量同步，所以看到上面的指令卡顿这很正常，待首次全量同步完成后，就会输出增量的 aof 日志。&lt;/p></description></item></channel></rss>