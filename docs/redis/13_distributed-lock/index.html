<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="分布式锁#分布式锁是用来解决并发问题的。比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操 作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。
分布式锁本质上要实现的目标就是在 Redis 里面占一个坑，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。
占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。
&gt; setnx lock:codehole true OK ... do something critical ... &gt; del lock:codehole (integer) 1 但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。
于是我们在拿到锁之后，再给锁加上一个过期时间，这样即使中间出现异常也可以保证锁会自动释放。
&gt; set lock:codehole true ex 5 nx OK ... do something critical ... &gt; del lock:codehole 超时问题#Redis 的分布式锁不能解决超时问题，例如：
 加锁和释放锁之间的逻辑执行的太长，以至于超出了过期时间，导致锁过期了。 这时候第一个线程持有的锁过期了，但是临界区的逻辑还没有执行完。 这个时候第二个线程就提前重新持有了这把锁，导致临界区代码不能得到严格的串行执行。  解决方案#tag = random.nextint() # 随机数 if redis.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="分布式锁" />
<meta property="og:description" content="分布式锁#分布式锁是用来解决并发问题的。比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操 作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。
分布式锁本质上要实现的目标就是在 Redis 里面占一个坑，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。
占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。
&gt; setnx lock:codehole true OK ... do something critical ... &gt; del lock:codehole (integer) 1 但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。
于是我们在拿到锁之后，再给锁加上一个过期时间，这样即使中间出现异常也可以保证锁会自动释放。
&gt; set lock:codehole true ex 5 nx OK ... do something critical ... &gt; del lock:codehole 超时问题#Redis 的分布式锁不能解决超时问题，例如：
 加锁和释放锁之间的逻辑执行的太长，以至于超出了过期时间，导致锁过期了。 这时候第一个线程持有的锁过期了，但是临界区的逻辑还没有执行完。 这个时候第二个线程就提前重新持有了这把锁，导致临界区代码不能得到严格的串行执行。  解决方案#tag = random.nextint() # 随机数 if redis." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/db-learn/docs/redis/13_distributed-lock/" />
<meta property="article:modified_time" content="2020-06-17T17:45:14+08:00" />
<title>分布式锁 | Database Learning</title>
<link rel="manifest" href="/db-learn/manifest.json">
<link rel="icon" href="/db-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/db-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/db-learn/en.search.min.79aa4caec43110b70bc10866de8e262ae56a148e0d75708b1522265755d59b70.js" integrity="sha256-eapMrsQxELcLwQhm3o4mKuVqFI4NdXCLFSImV1XVm3A="></script>

<script defer src="/db-learn/sw.min.b93542a5760842e2e25439dfb3c014a53a75c12fc8ef2e8e01a71b378f98e127.js" integrity="sha256-uTVCpXYIQuLiVDnfs8AUpTp1wS/I7y6OAacbN4&#43;Y4Sc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/db-learn"><span>Database Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/db-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li>
<p><strong>Mysql</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mysql/01_getting_started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mysql/02_install/">安裝</a></li>
<li>
  <a href="/db-learn/docs/mysql/03_query/">简单查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/04_advanced_query/">复杂查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/05_write_operation/">写操作</a></li>
<li>
  <a href="/db-learn/docs/mysql/06_other/">其他</a></li>
<li>
  <a href="/db-learn/docs/mysql/07_architecture/">基础架构</a></li>
<li>
  <a href="/db-learn/docs/mysql/08_config/">启动选项和配置文件</a></li>
<li>
  <a href="/db-learn/docs/mysql/09_character/">字符集和比较规则</a></li>
<li>
  <a href="/db-learn/docs/mysql/10_innodb-record-store-structure/">InnoDB 记录存储结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/11_innodb-page-structure/">InnoDB 数据页结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/12_b-tree/">B+ 树索引</a></li>
<li>
  <a href="/db-learn/docs/mysql/13_isolation-level/">事务的隔离级别</a></li>
<li>
  <a href="/db-learn/docs/mysql/14_lock/">锁</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>Redis</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/redis/01_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/redis/02_redis-config/">安装配置</a></li>
<li>
  <a href="/db-learn/docs/redis/03_redis-string/">数据类型 String</a></li>
<li>
  <a href="/db-learn/docs/redis/04_redis-hash/">数据类型 Hash</a></li>
<li>
  <a href="/db-learn/docs/redis/05_redis-set/">数据类型 Set</a></li>
<li>
  <a href="/db-learn/docs/redis/06_redis-sortedset/">数据类型 SortedSet</a></li>
<li>
  <a href="/db-learn/docs/redis/07_redis-list/">数据类型 List</a></li>
<li>
  <a href="/db-learn/docs/redis/08_redis-key/">Key 操作</a></li>
<li>
  <a href="/db-learn/docs/redis/09_sds/">简单动态字符串</a></li>
<li>
  <a href="/db-learn/docs/redis/10_dict/">字典</a></li>
<li>
  <a href="/db-learn/docs/redis/11_redis-object/">对象</a></li>
<li>
  <a href="/db-learn/docs/redis/12_bitmap/">位图</a></li>
<li>
  <a href="/db-learn/docs/redis/13_distributed-lock/"class=active>分布式锁</a></li>
<li>
  <a href="/db-learn/docs/redis/14_queue/">延时队列</a></li>
<li>
  <a href="/db-learn/docs/redis/15_hyperloglog/">HyperLogLog</a></li>
<li>
  <a href="/db-learn/docs/redis/16_bloom-filter/">布隆过滤器</a></li>
<li>
  <a href="/db-learn/docs/redis/17_current-limit/">限流</a></li>
<li>
  <a href="/db-learn/docs/redis/18_geohash/">GeoHash</a></li>
<li>
  <a href="/db-learn/docs/redis/19_persistence/">持久化</a></li>
<li>
  <a href="/db-learn/docs/redis/20_pipeline/">管道</a></li>
<li>
  <a href="/db-learn/docs/redis/21_transaction/">事务</a></li>
<li>
  <a href="/db-learn/docs/redis/22_sync/">主从同步</a></li>
<li>
  <a href="/db-learn/docs/redis/23_cluster/">集群</a></li>
<li>
  <a href="/db-learn/docs/redis/24_info/">INFO 指令</a></li>
<li>
  <a href="/db-learn/docs/redis/25_redis-expire-strategy/">过期策略和内存淘汰机制</a></li>
<li>
  <a href="/db-learn/docs/redis/26_protect-redis/">保护 Redis</a></li>
<li>
  <a href="/db-learn/docs/redis/27_skills/">一些命令行技巧</a></li>
<li>
  <a href="/db-learn/docs/redis/28_slowlog/">慢查询日志</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>MongoDB</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mongo/01_overview/">介绍</a></li>
<li>
  <a href="/db-learn/docs/mongo/02_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mongo/03_advance/">使用</a></li>
<li>
  <a href="/db-learn/docs/mongo/04_migrate/">数据迁移</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/db-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>分布式锁</strong>

  <label for="toc-control">
    
    <img src="/db-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#超时问题">超时问题</a>
      <ul>
        <li><a href="#解决方案">解决方案</a></li>
      </ul>
    </li>
    <li><a href="#redlock-算法">Redlock 算法</a>
      <ul>
        <li><a href="#锁的有效时间">锁的有效时间</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="分布式锁">
  分布式锁
  <a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81">#</a>
</h1>
<p>分布式锁是用来解决并发问题的。比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操
作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。</p>
<p>分布式锁本质上要实现的目标就是在 Redis 里面<strong>占一个坑，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试</strong>。</p>
<p>占坑一般是使用 <strong><code>setnx</code></strong>(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 <code>del</code> 指令释放茅坑。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">&gt; setnx lock:codehole true
OK
... <span style="color:#66d9ef">do</span> something critical ...
&gt; del lock:codehole
<span style="color:#f92672">(</span>integer<span style="color:#f92672">)</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 <code>del</code> 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p>
<p>于是我们在拿到锁之后，再给锁加上一个过期时间，这样即使中间出现异常也可以保证锁会自动释放。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">&gt; set lock:codehole true ex <span style="color:#ae81ff">5</span> nx
OK
... <span style="color:#66d9ef">do</span> something critical ...
&gt; del lock:codehole
</code></pre></div><h2 id="超时问题">
  超时问题
  <a class="anchor" href="#%e8%b6%85%e6%97%b6%e9%97%ae%e9%a2%98">#</a>
</h2>
<p>Redis 的分布式锁不能解决超时问题，例如：</p>
<ol>
<li>加锁和释放锁之间的逻辑执行的太长，以至于超出了过期时间，导致锁过期了。</li>
<li>这时候第一个线程持有的锁过期了，但是临界区的逻辑还没有执行完。</li>
<li>这个时候第二个线程就提前重新持有了这把锁，导致临界区代码不能得到严格的串行执行。</li>
</ol>
<h3 id="解决方案">
  解决方案
  <a class="anchor" href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">tag <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>nextint()  <span style="color:#75715e"># 随机数</span>
<span style="color:#66d9ef">if</span> redis<span style="color:#f92672">.</span>set(key, tag, nx<span style="color:#f92672">=</span>True, ex<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>):
    do_something()
    redis<span style="color:#f92672">.</span>delifequals(key, tag)  <span style="color:#75715e"># 假想的 delifequals 指令</span>
</code></pre></div><p>或者：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">SET key random_value NX PX <span style="color:#ae81ff">30000</span>
</code></pre></div><p>为 <code>set</code> 指令的 <code>value</code> 参数<strong>设置为一个随机数，释放锁时先匹配随机数是否一致</strong>，然后再删除 <code>key</code>，这是为了<strong>确保当前线程占有的锁不会被
其它线程释放，除非这个锁是过期了被服务器自动释放的</strong>。</p>
<p>设置一个<strong>随机字符串 <code>tag</code> 是很有必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁</strong>。假如获取锁时 <code>SET</code> 的不是一个随机字
符串，而是一个固定值，那么可能会发生下面的执行序列：</p>
<ol>
<li>客户端 1 获取锁成功。</li>
<li>客户端 1 在某个操作上阻塞了很长时间。</li>
<li>过期时间到了，锁自动释放了。</li>
<li>客户端 2 获取到了对应同一个资源的锁。</li>
<li>客户端 1 从阻塞中恢复过来，释放掉了客户端 2 持有的锁。</li>
</ol>
<p>但是匹配 <code>value</code> 和删除 <code>key</code> 不是一个原子操作，Redis 也没有提供类似于 <code>delifequals</code> 这样的指令，这就需要使用 Lua 脚本来处理了，因
为 Lua 脚本可以保证连续多个指令的原子性执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#f92672">#</span> delifequals
<span style="color:#66d9ef">if</span> redis.call(<span style="color:#e6db74">&#34;get&#34;</span>,KEYS[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">==</span> ARGV[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> redis.call(<span style="color:#e6db74">&#34;del&#34;</span>,KEYS[<span style="color:#ae81ff">1</span>])
<span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>这段 Lua 脚本在执行的时候要把前面的 <code>tag</code> 作为 <code>ARGV[1]</code> 的值传进去，把 <code>key</code> 作为 <code>KEYS[1]</code> 的值传进去。</p>
<p><strong>释放锁的操作必须使用 Lua 脚本来实现</strong>。释放锁其实包含三步操作：<code>GET</code>、判断和 <code>DEL</code>，用 Lua 脚本来实现能保证这三步的原子性。
否则，如果把这三步操作放到客户端逻辑中去执行的话，就有可能发生与前面第三个问题类似的执行序列：</p>
<ol>
<li>客户端 1 获取锁成功。</li>
<li>客户端 1 访问共享资源。</li>
<li>客户端 1 为了释放锁，先执行 <code>GET</code> 操作获取随机字符串的值。</li>
<li>客户端 1 判断随机字符串的值，与预期的值相等。</li>
<li>客户端 1 由于某个原因阻塞住了很长时间。</li>
<li>过期时间到了，锁自动释放了。</li>
<li>客户端 2 获取到了对应同一个资源的锁。</li>
<li>客户端 1 从阻塞中恢复过来，执行 <code>DEL</code> 操纵，释放掉了客户端 2 持有的锁。</li>
</ol>
<p>如果不是客户端阻塞住了，而是出现了大的<strong>网络延迟，也有可能导致类似的执行序列发生</strong>。</p>
<p>这个方案，它只是相对安全一点，因为如果真的超时了，当前线程的逻辑没有执行完，其它线程也会乘虚而入。</p>
<h2 id="redlock-算法">
  Redlock 算法
  <a class="anchor" href="#redlock-%e7%ae%97%e6%b3%95">#</a>
</h2>
<p>上面的加锁方式，是有缺陷的。</p>
<p>antirez 还指出了一个问题，是由 failover 引起的，却是基于单 Redis 节点的分布式锁无法解决的。正是这个问题催生了 Redlock 的出现。</p>
<p>这个问题是这样的。假如 Redis 节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。为了提高可用性，我们可以给这个 Redis 节点挂
一个 Slave，当 Master 节点不可用的时候，系统自动切到 Slave 上（failover）。但由于 Redis 的主从复制（replication）是异步的，这可能
导致在 failover 过程中丧失锁的安全性。考虑下面的执行序列：</p>
<ol>
<li>客户端 1 从 Master 获取了锁。</li>
<li>Master 宕机了，存储锁的 key 还没有来得及同步到 Slave 上。</li>
<li>Slave 升级为 Master。</li>
<li>客户端 2 从新的 Master 获取到了对应同一个资源的锁。</li>
</ol>
<p>客户端 1 和客户端 2 同时持有了同一个资源的锁。锁的安全性被打破。</p>
<h3 id="锁的有效时间">
  锁的有效时间
  <a class="anchor" href="#%e9%94%81%e7%9a%84%e6%9c%89%e6%95%88%e6%97%b6%e9%97%b4">#</a>
</h3>
<p>锁的有效时间(lock validity time)，设置成多少合适呢？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保
护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。</p>
<h4 id="分布式锁-redlock">
  分布式锁 Redlock
  <a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81-redlock">#</a>
</h4>
<p>Redlock 分布式锁，它基于 N 个完全独立的 Redis 节点（通常情况下 N 可以设置成 5）。</p>
<p>运行 Redlock 算法的客户端依次执行下面各个步骤，来完成<strong>获取锁</strong>的操作：</p>
<ol>
<li>获取当前时间（毫秒数）。</li>
<li>按顺序依次向 N 个 Redis 节点执行获取锁的操作。这个获取操作跟前面基于单 Redis 节点的获取锁的过程相同，包含随机字符串 <code>tag</code>，也包含
过期时间(比如 PX 30000，即锁的有效时间)。为了保证在某个 Redis 节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，
它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个 Redis 节点获取锁失败以后，应该立即尝试下一个 Redis 节点。这里的失败，应该包含任
何类型的失败，比如该 Redis 节点不可用，或者该 Redis 节点上的锁已经被其它客户端持有（注：Redlock 原文中这里只提到了 Redis 节点不可用的
情况，但也应该包含其它的失败情况）。</li>
<li>计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第 1 步记录的时间。如果客户端从大多数 Redis 节点（<code>&gt;= N/2+1</code>）成功获
取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</li>
<li>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第 3 步计算出来的获取锁消耗的时间。</li>
<li>如果最终获取锁失败了（可能由于获取到锁的 Redis 节点个数少于 <code>N/2+1</code>，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客
户端应该立即向所有 Redis 节点发起释放锁的操作（即前面介绍的 Redis Lua 脚本）。</li>
</ol>
<p><strong>释放锁</strong>的过程比较简单：客户端向所有 Redis 节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/db-learn/commit/391abafbb55e9e09f274b9823c6b411133314e4f" title='Last modified by shipengqi | June 17, 2020' target="_blank" rel="noopener">
      <img src="/db-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 17, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/db-learn/edit/master/content//docs/redis/13_distributed-lock.md" target="_blank" rel="noopener">
      <img src="/db-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#超时问题">超时问题</a>
      <ul>
        <li><a href="#解决方案">解决方案</a></li>
      </ul>
    </li>
    <li><a href="#redlock-算法">Redlock 算法</a>
      <ul>
        <li><a href="#锁的有效时间">锁的有效时间</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












