<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="关系#MongoDB 中的关系表示文档之间的逻辑相关方式。关系可以通过内嵌（Embedded）或引用（Referenced）两种方式建模。 这样的关系可能是 1：1、1：N、N：1，也有可能是 N：N。
例如，一个用户可能有多个地址，这是一个 1：N 的关系。
// user 文档结构 { &#34;_id&#34;:ObjectId(&#34;52ffc33cd85242f436000001&#34;), &#34;name&#34;: &#34;Tom Hanks&#34;, &#34;contact&#34;: &#34;987654321&#34;, &#34;dob&#34;: &#34;01-01-1991&#34; } // address 文档结构 { &#34;_id&#34;:ObjectId(&#34;52ffc4a5d85242602e000000&#34;), &#34;building&#34;: &#34;22 A, Indiana Apt&#34;, &#34;pincode&#34;: 123456, &#34;city&#34;: &#34;Los Angeles&#34;, &#34;state&#34;: &#34;California&#34; } // 内嵌关系的建模 { &#34;_id&#34;:ObjectId(&#34;52ffc33cd85242f436000001&#34;), &#34;contact&#34;: &#34;987654321&#34;, &#34;dob&#34;: &#34;01-01-1991&#34;, &#34;name&#34;: &#34;Tom Benzamin&#34;, &#34;address&#34;: [ { &#34;building&#34;: &#34;22 A, Indiana Apt&#34;, &#34;pincode&#34;: 123456, &#34;city&#34;: &#34;Los Angeles&#34;, &#34;state&#34;: &#34;California&#34; }, { &#34;building&#34;: &#34;170 A, Acropolis Apt&#34;, &#34;pincode&#34;: 456789, &#34;city&#34;: &#34;Chicago&#34;, &#34;state&#34;: &#34;Illinois&#34; }] } 该方法会将所有相关数据都保存在一个文档中，从而易于检索和维护。缺点是，如果内嵌文档不断增长，会对读写性能造成影响。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="使用" />
<meta property="og:description" content="关系#MongoDB 中的关系表示文档之间的逻辑相关方式。关系可以通过内嵌（Embedded）或引用（Referenced）两种方式建模。 这样的关系可能是 1：1、1：N、N：1，也有可能是 N：N。
例如，一个用户可能有多个地址，这是一个 1：N 的关系。
// user 文档结构 { &#34;_id&#34;:ObjectId(&#34;52ffc33cd85242f436000001&#34;), &#34;name&#34;: &#34;Tom Hanks&#34;, &#34;contact&#34;: &#34;987654321&#34;, &#34;dob&#34;: &#34;01-01-1991&#34; } // address 文档结构 { &#34;_id&#34;:ObjectId(&#34;52ffc4a5d85242602e000000&#34;), &#34;building&#34;: &#34;22 A, Indiana Apt&#34;, &#34;pincode&#34;: 123456, &#34;city&#34;: &#34;Los Angeles&#34;, &#34;state&#34;: &#34;California&#34; } // 内嵌关系的建模 { &#34;_id&#34;:ObjectId(&#34;52ffc33cd85242f436000001&#34;), &#34;contact&#34;: &#34;987654321&#34;, &#34;dob&#34;: &#34;01-01-1991&#34;, &#34;name&#34;: &#34;Tom Benzamin&#34;, &#34;address&#34;: [ { &#34;building&#34;: &#34;22 A, Indiana Apt&#34;, &#34;pincode&#34;: 123456, &#34;city&#34;: &#34;Los Angeles&#34;, &#34;state&#34;: &#34;California&#34; }, { &#34;building&#34;: &#34;170 A, Acropolis Apt&#34;, &#34;pincode&#34;: 456789, &#34;city&#34;: &#34;Chicago&#34;, &#34;state&#34;: &#34;Illinois&#34; }] } 该方法会将所有相关数据都保存在一个文档中，从而易于检索和维护。缺点是，如果内嵌文档不断增长，会对读写性能造成影响。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/db-learn/docs/mongo/03_advance/" />
<meta property="article:modified_time" content="2020-06-17T17:45:14+08:00" />
<title>使用 | Database Learning</title>
<link rel="manifest" href="/db-learn/manifest.json">
<link rel="icon" href="/db-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/db-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/db-learn/en.search.min.79aa4caec43110b70bc10866de8e262ae56a148e0d75708b1522265755d59b70.js" integrity="sha256-eapMrsQxELcLwQhm3o4mKuVqFI4NdXCLFSImV1XVm3A="></script>

<script defer src="/db-learn/sw.min.b93542a5760842e2e25439dfb3c014a53a75c12fc8ef2e8e01a71b378f98e127.js" integrity="sha256-uTVCpXYIQuLiVDnfs8AUpTp1wS/I7y6OAacbN4&#43;Y4Sc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/db-learn"><span>Database Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/db-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li>
<p><strong>Mysql</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mysql/01_getting_started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mysql/02_install/">安裝</a></li>
<li>
  <a href="/db-learn/docs/mysql/03_query/">简单查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/04_advanced_query/">复杂查询</a></li>
<li>
  <a href="/db-learn/docs/mysql/05_write_operation/">写操作</a></li>
<li>
  <a href="/db-learn/docs/mysql/06_other/">其他</a></li>
<li>
  <a href="/db-learn/docs/mysql/07_architecture/">基础架构</a></li>
<li>
  <a href="/db-learn/docs/mysql/08_config/">启动选项和配置文件</a></li>
<li>
  <a href="/db-learn/docs/mysql/09_character/">字符集和比较规则</a></li>
<li>
  <a href="/db-learn/docs/mysql/10_innodb-record-store-structure/">InnoDB 记录存储结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/11_innodb-page-structure/">InnoDB 数据页结构</a></li>
<li>
  <a href="/db-learn/docs/mysql/12_b-tree/">B+ 树索引</a></li>
<li>
  <a href="/db-learn/docs/mysql/13_isolation-level/">事务的隔离级别</a></li>
<li>
  <a href="/db-learn/docs/mysql/14_lock/">锁</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>Redis</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/redis/01_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/redis/02_redis-config/">安装配置</a></li>
<li>
  <a href="/db-learn/docs/redis/03_redis-string/">数据类型 String</a></li>
<li>
  <a href="/db-learn/docs/redis/04_redis-hash/">数据类型 Hash</a></li>
<li>
  <a href="/db-learn/docs/redis/05_redis-set/">数据类型 Set</a></li>
<li>
  <a href="/db-learn/docs/redis/06_redis-sortedset/">数据类型 SortedSet</a></li>
<li>
  <a href="/db-learn/docs/redis/07_redis-list/">数据类型 List</a></li>
<li>
  <a href="/db-learn/docs/redis/08_redis-key/">Key 操作</a></li>
<li>
  <a href="/db-learn/docs/redis/09_sds/">简单动态字符串</a></li>
<li>
  <a href="/db-learn/docs/redis/10_dict/">字典</a></li>
<li>
  <a href="/db-learn/docs/redis/11_redis-object/">对象</a></li>
<li>
  <a href="/db-learn/docs/redis/12_bitmap/">位图</a></li>
<li>
  <a href="/db-learn/docs/redis/13_distributed-lock/">分布式锁</a></li>
<li>
  <a href="/db-learn/docs/redis/14_queue/">延时队列</a></li>
<li>
  <a href="/db-learn/docs/redis/15_hyperloglog/">HyperLogLog</a></li>
<li>
  <a href="/db-learn/docs/redis/16_bloom-filter/">布隆过滤器</a></li>
<li>
  <a href="/db-learn/docs/redis/17_current-limit/">限流</a></li>
<li>
  <a href="/db-learn/docs/redis/18_geohash/">GeoHash</a></li>
<li>
  <a href="/db-learn/docs/redis/19_persistence/">持久化</a></li>
<li>
  <a href="/db-learn/docs/redis/20_pipeline/">管道</a></li>
<li>
  <a href="/db-learn/docs/redis/21_transaction/">事务</a></li>
<li>
  <a href="/db-learn/docs/redis/22_sync/">主从同步</a></li>
<li>
  <a href="/db-learn/docs/redis/23_cluster/">集群</a></li>
<li>
  <a href="/db-learn/docs/redis/24_info/">INFO 指令</a></li>
<li>
  <a href="/db-learn/docs/redis/25_redis-expire-strategy/">过期策略和内存淘汰机制</a></li>
<li>
  <a href="/db-learn/docs/redis/26_protect-redis/">保护 Redis</a></li>
<li>
  <a href="/db-learn/docs/redis/27_skills/">一些命令行技巧</a></li>
<li>
  <a href="/db-learn/docs/redis/28_slowlog/">慢查询日志</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
<li>
<p><strong>MongoDB</strong></p>
<ul>
<li>
  <a href="/db-learn/docs/mongo/01_overview/">介绍</a></li>
<li>
  <a href="/db-learn/docs/mongo/02_getting-started/">入门</a></li>
<li>
  <a href="/db-learn/docs/mongo/03_advance/"class=active>使用</a></li>
<li>
  <a href="/db-learn/docs/mongo/04_migrate/">数据迁移</a>
<!-- raw HTML omitted --></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/db-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>使用</strong>

  <label for="toc-control">
    
    <img src="/db-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#关系">关系</a>
      <ul>
        <li><a href="#引用关系的建模">引用关系的建模</a></li>
      </ul>
    </li>
    <li><a href="#数据库引用">数据库引用</a>
      <ul>
        <li><a href="#使用数据库引用">使用数据库引用</a></li>
      </ul>
    </li>
    <li><a href="#查询分析">查询分析</a>
      <ul>
        <li><a href="#explain">$explain</a></li>
        <li><a href="#hint">$hint</a></li>
      </ul>
    </li>
    <li><a href="#map-reduce">Map Reduce</a>
      <ul>
        <li><a href="#使用">使用</a></li>
        <li><a href="#查看-mapreduce-查询的结果">查看 mapReduce 查询的结果</a></li>
      </ul>
    </li>
    <li><a href="#全文检索">全文检索</a>
      <ul>
        <li><a href="#启用文本搜索">启用文本搜索</a></li>
        <li><a href="#创建文本索引">创建文本索引</a></li>
        <li><a href="#删除文本索引">删除文本索引</a></li>
      </ul>
    </li>
    <li><a href="#正则表达式">正则表达式</a>
      <ul>
        <li><a href="#不区分大小写">不区分大小写</a></li>
        <li><a href="#使用正则表达式来处理数组元素">使用正则表达式来处理数组元素</a></li>
        <li><a href="#优化正则表达式查询">优化正则表达式查询</a></li>
      </ul>
    </li>
    <li><a href="#id自增">ID自增</a></li>
    <li><a href="#副本集">副本集</a>
      <ul>
        <li><a href="#推荐的配置">推荐的配置</a></li>
        <li><a href="#选举机制">选举机制</a></li>
        <li><a href="#仲裁者">仲裁者</a></li>
        <li><a href="#优先级">优先级</a></li>
        <li><a href="#延迟备份节点">延迟备份节点</a></li>
        <li><a href="#创建索引">创建索引</a></li>
        <li><a href="#同步">同步</a></li>
      </ul>
    </li>
    <li><a href="#分片">分片</a>
      <ul>
        <li><a href="#分片集群">分片集群</a></li>
        <li><a href="#mongodb-如何追踪集群数据">MongoDB 如何追踪集群数据</a></li>
        <li><a href="#均衡器">均衡器</a></li>
        <li><a href="#选择片键">选择片键</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="关系">
  关系
  <a class="anchor" href="#%e5%85%b3%e7%b3%bb">#</a>
</h2>
<p>MongoDB 中的<strong>关系表示文档之间的逻辑相关方式</strong>。关系可以通过<strong>内嵌</strong>（Embedded）或<strong>引用</strong>（Referenced）两种方式建模。
这样的<strong>关系可能是 1：1、1：N、N：1，也有可能是 N：N</strong>。</p>
<p>例如，一个用户可能有多个地址，这是一个 1：N 的关系。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// user 文档结构
</span><span style="color:#75715e"></span>{
   <span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span><span style="color:#a6e22e">ObjectId</span>(<span style="color:#e6db74">&#34;52ffc33cd85242f436000001&#34;</span>),
   <span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tom Hanks&#34;</span>,
   <span style="color:#e6db74">&#34;contact&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;987654321&#34;</span>,
   <span style="color:#e6db74">&#34;dob&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;01-01-1991&#34;</span>
}
<span style="color:#75715e">// address 文档结构
</span><span style="color:#75715e"></span>{
   <span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span><span style="color:#a6e22e">ObjectId</span>(<span style="color:#e6db74">&#34;52ffc4a5d85242602e000000&#34;</span>),
   <span style="color:#e6db74">&#34;building&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;22 A, Indiana Apt&#34;</span>,
   <span style="color:#e6db74">&#34;pincode&#34;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">123456</span>,
   <span style="color:#e6db74">&#34;city&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Los Angeles&#34;</span>,
   <span style="color:#e6db74">&#34;state&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;California&#34;</span>
}

<span style="color:#75715e">// 内嵌关系的建模
</span><span style="color:#75715e"></span>{
   <span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span><span style="color:#a6e22e">ObjectId</span>(<span style="color:#e6db74">&#34;52ffc33cd85242f436000001&#34;</span>),
   <span style="color:#e6db74">&#34;contact&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;987654321&#34;</span>,
   <span style="color:#e6db74">&#34;dob&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;01-01-1991&#34;</span>,
   <span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tom Benzamin&#34;</span>,
   <span style="color:#e6db74">&#34;address&#34;</span><span style="color:#f92672">:</span> [
      {
         <span style="color:#e6db74">&#34;building&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;22 A, Indiana Apt&#34;</span>,
         <span style="color:#e6db74">&#34;pincode&#34;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">123456</span>,
         <span style="color:#e6db74">&#34;city&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Los Angeles&#34;</span>,
         <span style="color:#e6db74">&#34;state&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;California&#34;</span>
      },
      {
         <span style="color:#e6db74">&#34;building&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;170 A, Acropolis Apt&#34;</span>,
         <span style="color:#e6db74">&#34;pincode&#34;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">456789</span>,
         <span style="color:#e6db74">&#34;city&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Chicago&#34;</span>,
         <span style="color:#e6db74">&#34;state&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Illinois&#34;</span>
      }]
}
</code></pre></div><p><strong>该方法会将所有相关数据都保存在一个文档中</strong>，从而易于检索和维护。<strong>缺点是，如果内嵌文档不断增长，会对读写性能造成影响</strong>。</p>
<h3 id="引用关系的建模">
  引用关系的建模
  <a class="anchor" href="#%e5%bc%95%e7%94%a8%e5%85%b3%e7%b3%bb%e7%9a%84%e5%bb%ba%e6%a8%a1">#</a>
</h3>
<p>这是一种设计归一化关系的方法。按照这种方法，这种引用关系也被称作<strong>手动引用</strong>，所有的用户和地址文档都将分别存放，而用户文档会包含一个字段，用来引用地址文档 id 字段。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">{
   <span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span><span style="color:#a6e22e">ObjectId</span>(<span style="color:#e6db74">&#34;52ffc33cd85242f436000001&#34;</span>),
   <span style="color:#e6db74">&#34;contact&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;987654321&#34;</span>,
   <span style="color:#e6db74">&#34;dob&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;01-01-1991&#34;</span>,
   <span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tom Benzamin&#34;</span>,
   <span style="color:#e6db74">&#34;address_ids&#34;</span><span style="color:#f92672">:</span> [
      <span style="color:#a6e22e">ObjectId</span>(<span style="color:#e6db74">&#34;52ffc4a5d85242602e000000&#34;</span>),
      <span style="color:#a6e22e">ObjectId</span>(<span style="color:#e6db74">&#34;52ffc4a5d85242602e000001&#34;</span>)
   ]
}
</code></pre></div><p>数组字段 <code>address_ids</code> 含有相应地址的 <code>ObjectId</code> 对象。利用这些 <code>ObjectId</code>，能够查询地址文档，从而获取地址细节信息。利用这种方法时，需要进行两种查询：
首先从 <code>user</code> 文档处获取 <code>address_ids</code>，其次从 <code>address</code> 集合中获取这些地址。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">users</span>.<span style="color:#a6e22e">findOne</span>({<span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;Tom Benzamin&#34;</span>},{<span style="color:#e6db74">&#34;address_ids&#34;</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>})
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">addresses</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">address</span>.<span style="color:#a6e22e">find</span>({<span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span>{<span style="color:#e6db74">&#34;$in&#34;</span><span style="color:#f92672">:</span><span style="color:#a6e22e">result</span>[<span style="color:#e6db74">&#34;address_ids&#34;</span>]}})
</code></pre></div><h2 id="数据库引用">
  数据库引用
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%95%e7%94%a8">#</a>
</h2>
<p>上一节中，我们使用引用关系实现了归一化的数据库结构，这种引用关系也被称作<strong>手动引用</strong>，即可以手动地将引用文档的 id 保存在其他文档中。
有些情况下，文档包含其他集合的引用时，我们可以使用<strong>数据库引用</strong>（MongoDB DBRefs）。</p>
<p>如何用数据库引用代替手动引用。假设一个数据库中存储有多个类型的地址（家庭地址、办公室地址、邮件地址，等等），这些地址保存在不同的集合中
（<code>address_home</code>、<code>address_office</code>、<code>address_mailing</code>，等等）。当 <code>user</code> 集合的文档引用了一个地址时，它还需要按照地址类型来指定所需要查看的集合。
这种情况下，一个文档引用了许多结合的文档，所以就应该使用 <code>DBRef</code>。</p>
<h3 id="使用数据库引用">
  使用数据库引用
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%95%e7%94%a8">#</a>
</h3>
<p><code>DBRef</code> 中有三个字段：</p>
<ul>
<li><code>$ref</code> 该字段指定所引用文档的集合。</li>
<li><code>$id</code> 该字段指定引用文档的 <code>_id</code> 字段</li>
<li><code>$db</code> 该字段是可选的，包含引用文档所在数据库的名称。</li>
</ul>
<p>假如在一个简单的 <code>user</code> 文档中包含着 <code>DBRef</code> 字段 <code>address</code>，如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">{
   <span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span><span style="color:#a6e22e">ObjectId</span>(<span style="color:#e6db74">&#34;53402597d852426020000002&#34;</span>),
   <span style="color:#e6db74">&#34;address&#34;</span><span style="color:#f92672">:</span> {
   <span style="color:#e6db74">&#34;$ref&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;address_home&#34;</span>,
   <span style="color:#e6db74">&#34;$id&#34;</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">ObjectId</span>(<span style="color:#e6db74">&#34;534009e4d852427820000002&#34;</span>),
   <span style="color:#e6db74">&#34;$db&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;tutorialspoint&#34;</span>},
   <span style="color:#e6db74">&#34;contact&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;987654321&#34;</span>,
   <span style="color:#e6db74">&#34;dob&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;01-01-1991&#34;</span>,
   <span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Tom Benzamin&#34;</span>
}
</code></pre></div><p>数据库引用字段 <code>address</code> 指定出，引用地址文档位于 <code>tutorialspoint</code> 数据库的 <code>address_home</code> 集合中，并且它的 <code>id</code> 为 <code>534009e4d852427820000002</code>。</p>
<p>在由 <code>$ref</code> 所指定的集合（本例中为 <code>address_home</code>）中，如何动态查找由 <code>$id</code> 所确定的文档。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">users</span>.<span style="color:#a6e22e">findOne</span>({<span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;Tom Benzamin&#34;</span>})
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">dbRef</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">address</span>
<span style="color:#a6e22e">db</span>[<span style="color:#a6e22e">dbRef</span>.<span style="color:#a6e22e">$ref</span>].<span style="color:#a6e22e">findOne</span>({<span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span>(<span style="color:#a6e22e">dbRef</span>.<span style="color:#a6e22e">$id</span>)})
</code></pre></div><h2 id="查询分析">
  查询分析
  <a class="anchor" href="#%e6%9f%a5%e8%af%a2%e5%88%86%e6%9e%90">#</a>
</h2>
<p>对于衡量数据库及索引设计的效率来说，分析查询是一个很重要的衡量方式。经常使用的查询有 <code>$explain</code> 和 <code>$hint</code>。</p>
<h3 id="explain">
  $explain
  <a class="anchor" href="#explain">#</a>
</h3>
<p><code>$explain</code> 操作提供的消息包括：查询消息、查询所使用的索引以及其他的统计信息。</p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 创建索引
</span><span style="color:#75715e"></span><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">users</span>.<span style="color:#a6e22e">ensureIndex</span>({<span style="color:#a6e22e">gender</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">user_name</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>})

<span style="color:#75715e">// 查询
</span><span style="color:#75715e"></span><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">users</span>.<span style="color:#a6e22e">find</span>({<span style="color:#a6e22e">gender</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;M&#34;</span>},{<span style="color:#a6e22e">user_name</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">_id</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>}).<span style="color:#a6e22e">explain</span>()

<span style="color:#75715e">// 输出
</span><span style="color:#75715e"></span>{
   <span style="color:#e6db74">&#34;cursor&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;BtreeCursor gender_1_user_name_1&#34;</span>,
   <span style="color:#e6db74">&#34;isMultiKey&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>,
   <span style="color:#e6db74">&#34;n&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>,
   <span style="color:#e6db74">&#34;nscannedObjects&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
   <span style="color:#e6db74">&#34;nscanned&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>,
   <span style="color:#e6db74">&#34;nscannedObjectsAllPlans&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
   <span style="color:#e6db74">&#34;nscannedAllPlans&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>,
   <span style="color:#e6db74">&#34;scanAndOrder&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>,
   <span style="color:#e6db74">&#34;indexOnly&#34;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
   <span style="color:#e6db74">&#34;nYields&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
   <span style="color:#e6db74">&#34;nChunkSkips&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
   <span style="color:#e6db74">&#34;millis&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
   <span style="color:#e6db74">&#34;indexBounds&#34;</span> <span style="color:#f92672">:</span> {
      <span style="color:#e6db74">&#34;gender&#34;</span> <span style="color:#f92672">:</span> [
         [
            <span style="color:#e6db74">&#34;M&#34;</span>,
            <span style="color:#e6db74">&#34;M&#34;</span>
         ]
      ],
      <span style="color:#e6db74">&#34;user_name&#34;</span> <span style="color:#f92672">:</span> [
         [
            {
               <span style="color:#e6db74">&#34;$minElement&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>
            },
            {
               <span style="color:#e6db74">&#34;$maxElement&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>
            }
         ]
      ]
   }
}
</code></pre></div><ul>
<li><code>indexOnly</code> 为<code>true</code>代表该查询使用了索引。</li>
<li><code>cursor</code> 字段指定了游标所用的类型。<code>BTreeCursor</code> 类型代表了使用了索引并且提供了所用索引的名称。<code>BasicCursor</code> 表示进行了完整扫描，没有使用任何索引。</li>
<li><code>n</code> 代表所返回的匹配文档的数量。</li>
<li><code>nscannedObjects</code> 表示已扫描文档的总数。</li>
<li><code>nscanned</code> 所扫描的文档或索引项的总数。</li>
</ul>
<h3 id="hint">
  $hint
  <a class="anchor" href="#hint">#</a>
</h3>
<p><code>$hint</code> 操作符<strong>强制索引优化器使用指定的索引运行查询</strong>。这尤其适用于测试带有多个索引的查询性能。比如，下列查询指定了用于该查询的 <code>gender</code> 和 <code>user_name</code> 字段的索引：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">users</span>.<span style="color:#a6e22e">find</span>({<span style="color:#a6e22e">gender</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;M&#34;</span>},{<span style="color:#a6e22e">user_name</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">_id</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>}).<span style="color:#a6e22e">hint</span>({<span style="color:#a6e22e">gender</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">user_name</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>})
</code></pre></div><h2 id="map-reduce">
  Map Reduce
  <a class="anchor" href="#map-reduce">#</a>
</h2>
<p><code>Map-Reduce</code>（映射归约）是一种将大量数据压缩成有用的聚合结果的数据处理范式。MongoDB 使用 <code>mapReduce</code> 命令来实现映射归约操作。映射归约通常用来处理大型数据。</p>
<p><code>mapReduce</code> 命令的基本格式为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">collection</span>.<span style="color:#a6e22e">mapReduce</span>(
   <span style="color:#66d9ef">function</span>() {<span style="color:#a6e22e">emit</span>(<span style="color:#a6e22e">key</span>,<span style="color:#a6e22e">value</span>);},  <span style="color:#75715e">//map function
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">key</span>,<span style="color:#a6e22e">values</span>) {<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">reduceFunction</span>},   <span style="color:#75715e">//reduce function
</span><span style="color:#75715e"></span>   {
      <span style="color:#a6e22e">out</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">collection</span>,
      <span style="color:#a6e22e">query</span><span style="color:#f92672">:</span> document,
      <span style="color:#a6e22e">sort</span><span style="color:#f92672">:</span> document,
      <span style="color:#a6e22e">limit</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>
   }
)
</code></pre></div><p><strong><code>mapReduce</code> 函数首先查询集合，然后将结果文档利用 <code>emit</code> 函数映射为键值对，然后再根据有多个值的键来简化</strong>。</p>
<ul>
<li><code>map</code> 一个 JavaScript 函数，将一个值与键对应起来，并生成键值对。</li>
<li><code>reduce</code> 一个 JavaScript 函数，用来减少或组合所有拥有同一键的文档。</li>
<li><code>out</code> 指定映射归约查询结果的位置。</li>
<li><code>query</code> 指定选择文档所用的选择标准（可选的）。</li>
<li><code>sort</code> 指定可选的排序标准。</li>
<li><code>limit</code> 指定返回的文档的最大数量值（可选的）。</li>
</ul>
<h3 id="使用">
  使用
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8">#</a>
</h3>
<p>例如，下面这个存储用户发帖的文档结构。该文档存储用户的用户名（user_name）和发帖状态（status）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">{
   <span style="color:#e6db74">&#34;post_text&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;tutorialspoint is an awesome website for tutorials&#34;</span>,
   <span style="color:#e6db74">&#34;user_name&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;mark&#34;</span>,
   <span style="color:#e6db74">&#34;status&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;active&#34;</span>
}
</code></pre></div><p>在 <code>posts</code> 集合上使用 <code>mapReduce</code> 函数选择所有的活跃帖子，将它们基于用户名组合起来，然后计算每个用户的发帖量。代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">mapReduce</span>(
  <span style="color:#66d9ef">function</span>() { <span style="color:#a6e22e">emit</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">user_id</span>,<span style="color:#ae81ff">1</span>); },
  <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">values</span>) {<span style="color:#66d9ef">return</span> Array.<span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">values</span>)},
  {
     <span style="color:#a6e22e">query</span><span style="color:#f92672">:</span>{<span style="color:#a6e22e">status</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;active&#34;</span>},
     <span style="color:#a6e22e">out</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;post_total&#34;</span>
  }
)
</code></pre></div><p>输出：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">{
   <span style="color:#e6db74">&#34;result&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;post_total&#34;</span>,
   <span style="color:#e6db74">&#34;timeMillis&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">9</span>,
   <span style="color:#e6db74">&#34;counts&#34;</span> <span style="color:#f92672">:</span> {
      <span style="color:#e6db74">&#34;input&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>,
      <span style="color:#e6db74">&#34;emit&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>,
      <span style="color:#e6db74">&#34;reduce&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>,
      <span style="color:#e6db74">&#34;output&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>
   },
   <span style="color:#e6db74">&#34;ok&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>,
}
</code></pre></div><p>结果显示，只有 4 个文档符合查询条件（<code>status:&quot;active&quot;</code>），于是 <code>map</code> 函数就生成了 4 个带有键值对的文档，而最终 <code>reduce</code> 函数将具有相同键值的映射文档变为了 2 个。</p>
<h3 id="查看-mapreduce-查询的结果">
  查看 mapReduce 查询的结果
  <a class="anchor" href="#%e6%9f%a5%e7%9c%8b-mapreduce-%e6%9f%a5%e8%af%a2%e7%9a%84%e7%bb%93%e6%9e%9c">#</a>
</h3>
<p>使用 <code>find</code> 操作符。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">mapReduce</span>(
   <span style="color:#66d9ef">function</span>() { <span style="color:#a6e22e">emit</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">user_id</span>,<span style="color:#ae81ff">1</span>); },
   <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">values</span>) {<span style="color:#66d9ef">return</span> Array.<span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">values</span>)},
      {
         <span style="color:#a6e22e">query</span><span style="color:#f92672">:</span>{<span style="color:#a6e22e">status</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;active&#34;</span>},
         <span style="color:#a6e22e">out</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;post_total&#34;</span>
      }
).<span style="color:#a6e22e">find</span>()
</code></pre></div><h2 id="全文检索">
  全文检索
  <a class="anchor" href="#%e5%85%a8%e6%96%87%e6%a3%80%e7%b4%a2">#</a>
</h2>
<h3 id="启用文本搜索">
  启用文本搜索
  <a class="anchor" href="#%e5%90%af%e7%94%a8%e6%96%87%e6%9c%ac%e6%90%9c%e7%b4%a2">#</a>
</h3>
<p>最初的文本搜索只是一种试验性功能，但从 2.6 版本起就成为默认功能了。但如果使用的是之前的 MongoDB，则需要使用下列代码启用文本搜索：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">adminCommand</span>({<span style="color:#a6e22e">setParameter</span><span style="color:#f92672">:</span><span style="color:#66d9ef">true</span>,<span style="color:#a6e22e">textSearchEnabled</span><span style="color:#f92672">:</span><span style="color:#66d9ef">true</span>})
</code></pre></div><h3 id="创建文本索引">
  创建文本索引
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e6%96%87%e6%9c%ac%e7%b4%a2%e5%bc%95">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">ensureIndex</span>({<span style="color:#a6e22e">post_text</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;text&#34;</span>})
</code></pre></div><p>上面的代码在 <code>post_text</code> 字段上创建文本索引，以便搜索帖子文本之内的内容。</p>
<p>在 <code>post_text</code> 字段上创建了文本索引，接下来搜索包含 <code>tutorialspoint</code> 文本内容的帖子。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">find</span>({<span style="color:#a6e22e">$text</span><span style="color:#f92672">:</span>{<span style="color:#a6e22e">$search</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;tutorialspoint&#34;</span>}})
</code></pre></div><h3 id="删除文本索引">
  删除文本索引
  <a class="anchor" href="#%e5%88%a0%e9%99%a4%e6%96%87%e6%9c%ac%e7%b4%a2%e5%bc%95">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 找到索引名称
</span><span style="color:#75715e"></span><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">getIndexes</span>()

<span style="color:#75715e">// 删掉
</span><span style="color:#75715e"></span><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">dropIndex</span>(<span style="color:#e6db74">&#34;post_text_text&#34;</span>)
</code></pre></div><h2 id="正则表达式">
  正则表达式
  <a class="anchor" href="#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f">#</a>
</h2>
<p>正则表达式在所有语言当中都是经常会用到的一个功能，可以用来搜索模式或字符串中的单词。MongoDB 也提供了这一功能，使用 $regex 运算符来匹配字符串模式。
MongoDB 使用 PCRE（可兼容 Perl 的正则表达式）作为正则表达式语言。</p>
<p>使用正则表达式不需要使用任何配置或命令。</p>
<p>假如 posts 集合有下面这个文档，它包含着帖子文本及其标签。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">{
   <span style="color:#e6db74">&#34;post_text&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;enjoy the mongodb articles on tutorialspoint&#34;</span>,
   <span style="color:#e6db74">&#34;tags&#34;</span><span style="color:#f92672">:</span> [
      <span style="color:#e6db74">&#34;mongodb&#34;</span>,
      <span style="color:#e6db74">&#34;tutorialspoint&#34;</span>
   ]
}
</code></pre></div><p>使用下列正则表达式来搜索包含 tutorialspoint 的所有帖子。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">find</span>({<span style="color:#a6e22e">post_text</span><span style="color:#f92672">:</span>{<span style="color:#a6e22e">$regex</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;tutorialspoint&#34;</span>}})

<span style="color:#75715e">// 或者
</span><span style="color:#75715e"></span><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">find</span>({<span style="color:#a6e22e">post_text</span><span style="color:#f92672">:</span><span style="color:#e6db74">/tutorialspoint/</span>})
</code></pre></div><h3 id="不区分大小写">
  不区分大小写
  <a class="anchor" href="#%e4%b8%8d%e5%8c%ba%e5%88%86%e5%a4%a7%e5%b0%8f%e5%86%99">#</a>
</h3>
<p>要想使搜索不区分大小写，使用 <code>$options</code> 参数和值 <code>$i</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">find</span>({<span style="color:#a6e22e">post_text</span><span style="color:#f92672">:</span>{<span style="color:#a6e22e">$regex</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;tutorialspoint&#34;</span>,<span style="color:#a6e22e">$options</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;$i&#34;</span>}})
</code></pre></div><h3 id="使用正则表达式来处理数组元素">
  使用正则表达式来处理数组元素
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e6%9d%a5%e5%a4%84%e7%90%86%e6%95%b0%e7%bb%84%e5%85%83%e7%b4%a0">#</a>
</h3>
<p>还可以在数组字段上使用正则表达式。在实现标签的功能时，这尤为重要。假如想搜索标签以 “tutorial” 开始（tutorial、tutorials、tutorialpoint 或 tutorialphp）的帖子，可以使用下列代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">posts</span>.<span style="color:#a6e22e">find</span>({<span style="color:#a6e22e">tags</span><span style="color:#f92672">:</span>{<span style="color:#a6e22e">$regex</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;tutorial&#34;</span>}})
</code></pre></div><h3 id="优化正则表达式查询">
  优化正则表达式查询
  <a class="anchor" href="#%e4%bc%98%e5%8c%96%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e6%9f%a5%e8%af%a2">#</a>
</h3>
<ul>
<li>如果文档字段已经设置了索引，查询将使用索引值来匹配正则表达式，从而使查询效率相对于扫描整个集合的正则表达式而言大大提高。</li>
<li>如果正则表达式为前缀表达式，所有的匹配结果都要在前面带有特殊的前缀字符串。比如，如果正则表达式为 <code>^tut</code>，那么查询将搜索所有以 <code>tut</code> 开始的字符串。</li>
</ul>
<h2 id="id自增">
  ID自增
  <a class="anchor" href="#id%e8%87%aa%e5%a2%9e">#</a>
</h2>
<p>默认情况下，MongoDB 将 <code>_id</code> 字段（使用 12 字节的 <code>ObjectId</code>）来作为文档的唯一标识。但在有些情况下，我们希望 <code>_id</code> 字段值能够自动增长，而不是固守在 <code>ObjectId</code> 值上。</p>
<p>使用 <code>counters</code> 集合来程序化地实现该功能。</p>
<ol>
<li>使用 counters 集合
假设存在下列文档 <code>products</code>，我们希望 <code>_id</code> 字段值是一个能够自动增长的整数序列（1、2、3、4 …… n）。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">{
  <span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>,
  <span style="color:#e6db74">&#34;product_name&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Apple iPhone&#34;</span>,
  <span style="color:#e6db74">&#34;category&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;mobiles&#34;</span>
}
</code></pre></div><p>创建一个 <code>counters</code> 集合，其中包含了所有序列字段最后的序列值。
现在，将文档（<code>productid</code> 是它的键）插入到 <code>counters</code> 集合中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">counters</span>.<span style="color:#a6e22e">insert</span>({<span style="color:#a6e22e">_id</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;productid&#34;</span>,<span style="color:#a6e22e">sequence_value</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>})
</code></pre></div><p><code>sequence_value</code> 字段保存了序列的最后值。</p>
<ol start="2">
<li>创建一个 <code>getNextSequenceValue</code> 函数
创建一个 <code>getNextSequenceValue</code> 函数，该函数以序列名为输入，按照 1 的幅度增加序列数，返回更新的序列数。在该例中，序列名称为 <code>productid</code>。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getNextSequenceValue</span>(<span style="color:#a6e22e">sequenceName</span>){
   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sequenceDocument</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">counters</span>.<span style="color:#a6e22e">findAndModify</span>(
      {
         <span style="color:#a6e22e">query</span><span style="color:#f92672">:</span>{<span style="color:#a6e22e">_id</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">sequenceName</span> },
         <span style="color:#a6e22e">update</span><span style="color:#f92672">:</span> {<span style="color:#a6e22e">$inc</span><span style="color:#f92672">:</span>{<span style="color:#a6e22e">sequence_value</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>}},
         <span style="color:#66d9ef">new</span><span style="color:#f92672">:</span><span style="color:#66d9ef">true</span>
      });
   <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sequenceDocument</span>.<span style="color:#a6e22e">sequence_value</span>;
}
</code></pre></div><ol start="3">
<li>使用 <code>getNextSequenceValue</code> 函数</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">products</span>.<span style="color:#a6e22e">insert</span>({<span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span><span style="color:#a6e22e">getNextSequenceValue</span>(<span style="color:#e6db74">&#34;productid&#34;</span>),<span style="color:#e6db74">&#34;product_name&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;Apple iPhone&#34;</span>,<span style="color:#e6db74">&#34;category&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;mobiles&#34;</span>})
<span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">products</span>.<span style="color:#a6e22e">insert</span>({<span style="color:#e6db74">&#34;_id&#34;</span><span style="color:#f92672">:</span><span style="color:#a6e22e">getNextSequenceValue</span>(<span style="color:#e6db74">&#34;productid&#34;</span>),<span style="color:#e6db74">&#34;product_name&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;Samsung S3&#34;</span>,<span style="color:#e6db74">&#34;category&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;mobiles&#34;</span>})
</code></pre></div><h2 id="副本集">
  副本集
  <a class="anchor" href="#%e5%89%af%e6%9c%ac%e9%9b%86">#</a>
</h2>
<p>生产环境下，把数据库放到一台服务器上是有很大风险的。Mongo 的<strong>复制</strong>功能可以把数据副本保存到多台服务器上。在 Mongo 中，只需要创建<strong>副本集</strong>
就可以使用复制功能了。副本集是一组服务器，一个是主服务器，处理客户端请求，还有多个备份服务器，用于保存数据副本。并且备份服务器可以在主服务器崩溃时
自动选举一个新的主服务器。</p>
<p>副本集中有个比较重要的概念叫做<strong>大多数</strong>（超过一半以上的成员）：<strong>选择主节点时，只有在大多数节点支持时才能继续作为主节点</strong>。写操作被复制到大多数成员时，
这个写操作就是安全的。</p>
<p>如果副本集中有些成员挂了，不会影响“大多数”，<strong>“大多数”是基于副本集的配置计算的</strong>。</p>
<p>假设有一个包含 5 个成员的副本集，3 个成员不可用，2 个正常。那么剩余的 2 个成员无法达到“大多数”的要求，就无法选举出主节点。而且<strong>如果这 2 个成员中有一个是
主节点，这个主节点也会退位</strong>。那么，之后就变成了 2 个备份节点和 3 个不可用节点。</p>
<p>这样的规则是不是弱爆了？明明有两个可用的节点，却不能选举出主节点。为什么？</p>
<p><strong>为了避免出现多个主节点</strong>。</p>
<p>因为如果 3 个不可用成员不是挂了，可能因为网络问题，造成通信不可达，这种情况下，3 个不可用的节点可能会选举出一个主节点，2 个正常的节点再选举一个主节点，
那么副本集就会出现 2 个主节点。写入数据时，就会发生混乱。</p>
<h3 id="推荐的配置">
  推荐的配置
  <a class="anchor" href="#%e6%8e%a8%e8%8d%90%e7%9a%84%e9%85%8d%e7%bd%ae">#</a>
</h3>
<p>在两个数据中心放置数量相同的成员，在第三个地方放置一个决定胜负的副本集成员。只要任意一个数据中心的服务器可以找到那一台关键的服务器，就可以达到“大多数”的要求。</p>
<h3 id="选举机制">
  选举机制
  <a class="anchor" href="#%e9%80%89%e4%b8%be%e6%9c%ba%e5%88%b6">#</a>
</h3>
<p>当一个本分节点无法与主节点连通时，它就会联系并请求其他副本集成员将自己选举为主节点。其他成员会做几个检查：</p>
<ol>
<li>自己是否能与主节点连通</li>
<li>希望被选举为主节点的成员数据是否是最新的</li>
<li>有没有优先级更高的成员可以选举为主节点</li>
</ol>
<p><strong>每个成员都只能要求自己被选举为主节点</strong>。</p>
<h3 id="仲裁者">
  仲裁者
  <a class="anchor" href="#%e4%bb%b2%e8%a3%81%e8%80%85">#</a>
</h3>
<p>可以给予每个副本集成员不一样的配置。</p>
<p>Mongo 支持<strong>仲裁者</strong>类型的成员。仲裁者只参与选举，不保存数据，因为有时候数据副本保存太多，浪费资源。只是为了帮助其他成员满足“大多数”的条件。</p>
<p>仲裁者不需要履行 Mongo 服务器的职责，所以可以放在配置比较差的服务器上。可以作为上面说到的那个决定胜负的成员。</p>
<p><strong>仲裁者只允许有一个</strong>。</p>
<p><strong>尽可能在副本集中使用奇数个数据成员，不适用仲裁者</strong>。因为如果有三个成员，2 个数据成员，1 个仲裁者，在主节点挂了之后，只剩下一个数据成员，被选举为主节点，
为了数据备份，只能再加入一个数据成员，并复制所有数据副本，复制数据会对服务器造成很大的压力。</p>
<h3 id="优先级">
  优先级
  <a class="anchor" href="#%e4%bc%98%e5%85%88%e7%ba%a7">#</a>
</h3>
<p>一个成员成为主节点的优先级，取值范围 <code>0~100</code>。默认是 1。优先级为 0 的成员永远不能成为主节点，这种成员叫做<strong>被动成员</strong>。</p>
<p>优先级越高，就越先被选为主节点。</p>
<h3 id="延迟备份节点">
  延迟备份节点
  <a class="anchor" href="#%e5%bb%b6%e8%bf%9f%e5%a4%87%e4%bb%bd%e8%8a%82%e7%82%b9">#</a>
</h3>
<p>可以使用 <code>slaveDelay</code> 设置一个延迟备份节点，防止有人不小心删除了主数据库，或者程序 bug 导致数据误删除之类的问题。</p>
<p><strong><code>slaveDelay</code> 成员要求优先级为 0</strong>。</p>
<h3 id="创建索引">
  创建索引
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95">#</a>
</h3>
<p>备份节点一般不需要与主节点相同的索引，甚至没有索引。如果只是用来数据备份或者离线任务。可以指定 <code>builgIndexes: false</code> 这个选项阻止备份节点
创建索引。</p>
<p><strong>注意指定了 <code>builgIndexes: false</code> 这个选项的成员无法恢复为可以创建索引的成员。<code>builgIndexes: false</code> 这个选项的成员要求优先级为 0</strong>。</p>
<h3 id="同步">
  同步
  <a class="anchor" href="#%e5%90%8c%e6%ad%a5">#</a>
</h3>
<p>MongoDB 的复制功能是使用操作日志 oplog 实现的，操作日志包含了主节点的每一次写操作。oplog 是主节点的 local 数据库中的一个固定集合。备份
节点通过查询这个集合就知道需要进行的复制操作。</p>
<p>每个备份节点要维护自己 oplog，先复制数据，在写入 oplog，记录每一次从主节点复制数据的操作。这样每个成员都可以作为同步源提供给其他成员使用。

  <img src="../../../images/mongosync.jpg" alt="" /></p>
<p>如果某个人备份节点挂了，重启后，会自动从 oplog 中最后一个操作开始同步。</p>
<p>oplog 的大小是固定的。如果执行大量的批量操作，oplog 会很快填满。</p>
<h4 id="处理陈旧数据">
  处理陈旧数据
  <a class="anchor" href="#%e5%a4%84%e7%90%86%e9%99%88%e6%97%a7%e6%95%b0%e6%8d%ae">#</a>
</h4>
<p>备份节点远落后于同步源当前操作，那么这个备份节点就是<strong>陈旧</strong>的。比如备份节点曾经停机，或者有太多的读请求，都可能导致节点陈旧。</p>
<p>一个节点陈旧之后，会找到 oplog 足够详尽的成员来同步，如果没有 复合的 oplog，就需啊哟进行完全同步。</p>
<p>为了避免陈旧备份节点，主节点的 oplog 要足够大。</p>
<h2 id="分片">
  分片
  <a class="anchor" href="#%e5%88%86%e7%89%87">#</a>
</h2>
<p><strong>分片</strong>（sharding）是指将数据拆分，将其分散存放在不同的机器上的过程。有时也叫做<strong>分区</strong>（partitioning）。数据分散到不同机器上，
这样服务器可以储存更多的数据，处理更大的负载。</p>
<p>几乎所有的数据库软件都支持<strong>手动分片</strong>。MongoDB 支持<strong>自动分片</strong>，简化系统管理，并且对应用程序，就像在使用一台 MongoDB 服务器。</p>
<h3 id="分片集群">
  分片集群
  <a class="anchor" href="#%e5%88%86%e7%89%87%e9%9b%86%e7%be%a4">#</a>
</h3>
<p>Mongo 的分片机制允许创建一个包含多台机器（分片）的集群。将数据子集分散在集群中，每个分片维护一个数据集合的子集。与单机和副本集相比，使用集群架构可以使应用具有
更大的数据处理能力。</p>
<blockquote>
<p><strong>复制</strong>和<strong>分片</strong>的概念是不一样的，复制是让多台服务器拥有<strong>同样的数据副本</strong>，而每一个<strong>分片都有不同的数据子集</strong>。</p>
</blockquote>
<h4 id="何时分片">
  何时分片
  <a class="anchor" href="#%e4%bd%95%e6%97%b6%e5%88%86%e7%89%87">#</a>
</h4>
<p>通常不必太早分片，因为分片会增加部署的复杂度。也不要在系统运行太久后再分片，在一个过载的系统上不停机分片是非常困难的。</p>
<p>分片的作用：</p>
<ul>
<li>增加可用 RAM</li>
<li>增加可用磁盘空间</li>
<li>减轻单台服务器负载</li>
<li>处理更大的吞吐量</li>
</ul>
<p>分片不可太少，因为由于迁移数据，维护元数据，路由等开销，可能还会造成性能下降。</p>
<h4 id="组件">
  组件
  <a class="anchor" href="#%e7%bb%84%e4%bb%b6">#</a>
</h4>
<ul>
<li><strong>mongos</strong>，数据库集群请求的入口，所有的请求都通过 mongos 进行协调，不需要在应用程序添加一个路由选择器，mongos 自己就是一个请求分发中心，
它<strong>负责把对应的数据请求请求转发到对应的 shard 服务器上</strong>。在生产环境通常有多 mongos 作为请求的入口，防止其中一个挂掉所有的 mongodb 请求都没有办法操作。</li>
<li><strong>config server</strong>，配置服务器，存储所有数据库元信息（路由、分片）的配置。</li>
<li><strong>Shard</strong>，分片服务器。</li>
</ul>
<h4 id="配置分片">
  配置分片
  <a class="anchor" href="#%e9%85%8d%e7%bd%ae%e5%88%86%e7%89%87">#</a>
</h4>
<h5 id="配置服务器">
  配置服务器
  <a class="anchor" href="#%e9%85%8d%e7%bd%ae%e6%9c%8d%e5%8a%a1%e5%99%a8">#</a>
</h5>
<p><strong>配置服务器保存集群和分片的元数据，即各个分片包含哪些数据的信息</strong>。</p>
<p><strong>创建集群首先要先建立配置服务器，并启用日志功能。每个配置服务器都应该位于单独的物理机上</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># config-1</span>
mongod --configsvr --dbpath /var/lib/mongodb -f /var/lib/config/mongod.conf
<span style="color:#75715e"># config-2</span>
mongod --configsvr --dbpath /var/lib/mongodb -f /var/lib/config/mongod.conf
<span style="color:#75715e"># config-3</span>
mongod --configsvr --dbpath /var/lib/mongodb -f /var/lib/config/mongod.conf
</code></pre></div><p>启动 3 台配置服务器， mongos 会向所有配置服务器发送请求，确保每台配置服务器拥有相同的数据。配置服务器不需要太多的资源，它只保存数据的分布表。
所以可以将其部署在分片服务器或者 mongos 服务器上。</p>
<p><code>--configsvr</code> 指定 mongod 为配置服务器，其实只是将 mongod 默认的 27017 端口改为了 27019，把默认的数据目录改为 <code>/data/configdb</code>。</p>
<p>为了避免配置服务器全部挂掉，通常也应该对配置服务器的数据进行备份。</p>
<h5 id="mongos">
  mongos
  <a class="anchor" href="#mongos">#</a>
</h5>
<p>3 个配置服务器已运行，启动一个 mongos 进程来做入口。mongos 必须知道配置服务器地址，使用 <code>--configdb</code> 来指定：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">mongos --configdb config-1:27019,config-2:27019,config-3:27019 -f /var/lib/mongos.conf
</code></pre></div><p>mongos 运行在 27017 端口。不需要指定数据目录，因为 mongos 不保存数据。可以启动多个 mongos 进程。</p>
<h5 id="将副本集转化为分片">
  将副本集转化为分片
  <a class="anchor" href="#%e5%b0%86%e5%89%af%e6%9c%ac%e9%9b%86%e8%bd%ac%e5%8c%96%e4%b8%ba%e5%88%86%e7%89%87">#</a>
</h5>
<p>假设已经有一个副本集，如果没有就初始化一个空的副本集。如果有一个使用中的副本集，该副本集会成为第一个分片。</p>
<p>接下来，mongos 需要知道副本集的名称和副本集成员列表。例如 server-1、server-2、server-3、server-4、server-5 上有一个名为 spock 的
副本集，连接 mongos，并运行：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">&gt; sh.addShard<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;spock/server-1:27017,server-2:27017,server-4:27017&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>上面的语句没有指定所有成员，mongos 可以自动检测副本集的所有成员。比如运行 <code>sh.status()</code>，可以发现 mongos 已经找到可所有副本集成员
<code>spock/server-1:27017,server-2:27017,server-3:27017,server-4:27017,server-5:27017</code>。</p>
<p>副本集名称会作为分片的名称。副本集作为分片添加到集群之后，应用程序就可以从连接副本集改为连接到 mongos。mongos 会将副本集的所有
数据库注册为分片数据库，所有查询会送到新的分片上。</p>
<h5 id="数据分片">
  数据分片
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%88%86%e7%89%87">#</a>
</h5>
<p>除非明确指定归罪，否则 MongoDB 不会自动对数据进行拆分。</p>
<p>假设读数据库 music 中的 artists 集合按照 name 字段分片。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 数据库 music 启用分片
</span><span style="color:#75715e"></span><span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">enableSharding</span>(<span style="color:#e6db74">&#34;music&#34;</span>)

<span style="color:#75715e">// 对集合分片
</span><span style="color:#75715e"></span><span style="color:#a6e22e">sh</span>.<span style="color:#a6e22e">shardCollection</span>(<span style="color:#e6db74">&#34;music.artists&#34;</span>, {<span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>})
</code></pre></div><p>**注意，如果对已经存在的集合分片，那么 <code>name</code> 字段必须有索引，否则 <code>shardCollection</code> 会报错。**如果报错，进先创建索引，
再执行 <code>shardCollection</code>。</p>
<h5 id="部署架构">
  部署架构
  <a class="anchor" href="#%e9%83%a8%e7%bd%b2%e6%9e%b6%e6%9e%84">#</a>
</h5>
<p>下面是一个常见的部署架构，可以用作参考，机器数量根据自身情况而定。</p>
<p>使用三台服务器，部署三个分片，每个分片三副本。实际上分片数量可以是任意个，试主机性能而定。各个分片之间是完全相互独立的，一个 database 的数据只会落在一个分片上。</p>
<ul>
<li>服务器：<code>16.187.189.120</code>、<code>16.187.189.121</code>、<code>16.187.189.122</code></li>
</ul>
<p>部署结构如下表所示：</p>
<table>
<thead>
<tr>
<th><code>16.187.189.120</code></th>
<th><code>16.187.189.121</code></th>
<th><code>16.187.189.122</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>mongos: <code>27017</code></td>
<td>mongos: <code>27017</code></td>
<td>mongos: <code>27017</code></td>
</tr>
<tr>
<td>config: <code>27018</code></td>
<td>config: <code>27018</code></td>
<td>config: <code>27018</code></td>
</tr>
<tr>
<td>shard01: <code>27101</code></td>
<td>shard01: <code>27101</code></td>
<td>shard01: <code>27101</code></td>
</tr>
<tr>
<td>shard02: <code>27102</code></td>
<td>shard02: <code>27102</code></td>
<td>shard02: <code>27102</code></td>
</tr>
<tr>
<td>shard03: <code>27103</code></td>
<td>shard03: <code>27103</code></td>
<td>shard03: <code>27103</code></td>
</tr>
</tbody>
</table>
<p>
  <a href="https://yq.aliyun.com/articles/625991">参考文章</a></p>
<h3 id="mongodb-如何追踪集群数据">
  MongoDB 如何追踪集群数据
  <a class="anchor" href="#mongodb-%e5%a6%82%e4%bd%95%e8%bf%bd%e8%b8%aa%e9%9b%86%e7%be%a4%e6%95%b0%e6%8d%ae">#</a>
</h3>
<p>MongoDB 将文档分组为<strong>块</strong>（chunk），每个块由给定片键特定范围内的文档组成。一个块只存在一个分片上，所以只需要一个很小的表就可以维护块和分片的映射。</p>
<p>比如，一个用户集合的片键是 <code>{&quot;age&quot;: 1}</code>，某个块可能是由 age 值为 <code>3~17</code> 的文档组成。如果有一个 <code>{&quot;age&quot;: 5}</code> 的查询，就可以直接路由到 age 值为 <code>3~17</code>
的块所在的分片。</p>
<p>如果 age 值为 <code>3~17</code> （<code>3 ≤ age &lt; 17</code>）的块越来越大，比如我们的应用大部分用户是这个年龄段的学生，那么这个块会被拆分成两个小块，
比如会拆成 <code>3~11</code> （3 ≤ age &lt; 11）和 <code>12~17</code> （<code>12 ≤ age &lt; 17</code>）的块。接着变大，就
接着拆分。</p>
<p><strong>块与块之间的范围不能有交集</strong>。</p>
<p><strong>一个文档只属于一个块。就意味着不能使用数组字段作为片键</strong>。因为 MongoDB 会为数组创建多个索引。</p>
<p><strong><code>--nosplit</code> 可以关闭块的拆分</strong>。</p>
<h3 id="均衡器">
  均衡器
  <a class="anchor" href="#%e5%9d%87%e8%a1%a1%e5%99%a8">#</a>
</h3>
<p>均衡器负责数据的迁移，周期性的检查分片间是否存在 不均衡，存在的话，就会开始块的迁移。mongos 会扮演均衡器的角色。均衡不会影响 mongos 的正常路由
操作。</p>
<h3 id="选择片键">
  选择片键
  <a class="anchor" href="#%e9%80%89%e6%8b%a9%e7%89%87%e9%94%ae">#</a>
</h3>
<p>对集合分片时，要选择一个或两个字段来做**片键，用于数据拆分。一旦拥有多个分片，再修改片键几乎不可能，因此，选择合适的片键
非常重要。</p>
<h4 id="升序片键">
  升序片键
  <a class="anchor" href="#%e5%8d%87%e5%ba%8f%e7%89%87%e9%94%ae">#</a>
</h4>
<p>升序片键类似 “date” 字段或者 ObjectId，是一种随着时间稳定增长的字段。</p>
<p>比如基于 <code>_id</code> 分片，集合会根据 <code>_id</code> 拆分块。如果创建一个新文档，这个文档会分发到 <code>ObjectId(&quot;5112fae0b4a4b396ff9d0ee5&quot;)</code> 到 <code>$maxKey</code> 的块。这个
块叫<strong>最大块</strong>。接下来再插入的文档都在这个最大快中。因为 <code>_id</code> 的值在不断增长，比之前的文档的 <code>_id</code> 值都大。</p>
<p>
  <img src="../../../images/key-chunk-demo.jpg" alt="" /></p>
<p>这样的分块，<strong>有明显的弊端，就是接下来的所有写请求都会路由到一个分片中。这个最大块是唯一一个不断增长和拆分的块，因为只有它能接收到插入请求。然后数据不断增多，
最大块再不断拆分出新的小块。这会导致数据均衡处理困难，因为所有新块都是同一个分片创建。MongoDB 必须不断将一些块迁移至其他的分片</strong>。</p>
<h4 id="随机分发的片键">
  随机分发的片键
  <a class="anchor" href="#%e9%9a%8f%e6%9c%ba%e5%88%86%e5%8f%91%e7%9a%84%e7%89%87%e9%94%ae">#</a>
</h4>
<p>随机分发的片键可以使用户名，邮件地址，UDID，MD5 散列值，或者是数据集中其他一些没有规律的键。</p>
<p>数据的随机性意味着，新数据会比较均衡的分发在不同的块中。</p>
<p>弊端是，MongoDB 在随机访问超出 RAM 大小的数据时效率不高。但是如果 RAM 足够，随机分片的键的性能是很好的。</p>
<h4 id="基于位置的片键">
  基于位置的片键
  <a class="anchor" href="#%e5%9f%ba%e4%ba%8e%e4%bd%8d%e7%bd%ae%e7%9a%84%e7%89%87%e9%94%ae">#</a>
</h4>
<p>基于位置的片键可以使IP，经纬度，或者地址。这里的 “位置” 比较抽象，疏忽会根据 “位置” 分组，所有与该健值比较接近的文档都会被保存在一个块中。</p>
<h4 id="片键策略">
  片键策略
  <a class="anchor" href="#%e7%89%87%e9%94%ae%e7%ad%96%e7%95%a5">#</a>
</h4>
<h5 id="散列片键">
  散列片键
  <a class="anchor" href="#%e6%95%a3%e5%88%97%e7%89%87%e9%94%ae">#</a>
</h5>
<p><strong>散列片键的数据加载速度最快。散列片键可使其他任意键随机分发，如果打算使用升序键，又希望数据随机分发，那么就选择散列片键</strong>。</p>
<p>弊端是无法使用散列片键做指定目标的范围查询。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 创建散列索引</span>
&gt; db.users.ensureIndex<span style="color:#f92672">({</span><span style="color:#e6db74">&#34;username&#34;</span>: <span style="color:#e6db74">&#34;hashed&#34;</span><span style="color:#f92672">})</span>

<span style="color:#75715e"># 集合分片</span>
&gt; sh.shardCollection<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;app.users&#34;</span>, <span style="color:#f92672">{</span><span style="color:#e6db74">&#34;username&#34;</span>: <span style="color:#e6db74">&#34;hashed&#34;</span><span style="color:#f92672">})</span>
</code></pre></div><h4 id="片键限制">
  片键限制
  <a class="anchor" href="#%e7%89%87%e9%94%ae%e9%99%90%e5%88%b6">#</a>
</h4>
<ul>
<li>片键不可以是数组。</li>
<li>文档一旦插入，片键无法修改，要修改，必须先删除文档，因此尽量选择不会被改变的字段。</li>
<li>大多数特殊类型的索引不能做片键。特别是地理空间索引。</li>
</ul>
<h4 id="片键的势">
  片键的势
  <a class="anchor" href="#%e7%89%87%e9%94%ae%e7%9a%84%e5%8a%bf">#</a>
</h4>
<p>选择一个值会发生变化的键很重要，比如以 &ldquo;logLevel&rdquo; 为键，&ldquo;logLevel&rdquo; 只拥有 &ldquo;DEBUG&rdquo;、&ldquo;WARN&rdquo;、&ldquo;ERROR&rdquo;、&ldquo;INFO&rdquo; 四个值。那么最多只有将数据分为四个
块。</p>
<p>如果一个键的值比较少，又希望用作片键，可以与另一只键一起创建组合片键，比如和 &ldquo;timestamp&rdquo;。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/db-learn/commit/391abafbb55e9e09f274b9823c6b411133314e4f" title='Last modified by shipengqi | June 17, 2020' target="_blank" rel="noopener">
      <img src="/db-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 17, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/db-learn/edit/master/content//docs/mongo/03_advance.md" target="_blank" rel="noopener">
      <img src="/db-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#关系">关系</a>
      <ul>
        <li><a href="#引用关系的建模">引用关系的建模</a></li>
      </ul>
    </li>
    <li><a href="#数据库引用">数据库引用</a>
      <ul>
        <li><a href="#使用数据库引用">使用数据库引用</a></li>
      </ul>
    </li>
    <li><a href="#查询分析">查询分析</a>
      <ul>
        <li><a href="#explain">$explain</a></li>
        <li><a href="#hint">$hint</a></li>
      </ul>
    </li>
    <li><a href="#map-reduce">Map Reduce</a>
      <ul>
        <li><a href="#使用">使用</a></li>
        <li><a href="#查看-mapreduce-查询的结果">查看 mapReduce 查询的结果</a></li>
      </ul>
    </li>
    <li><a href="#全文检索">全文检索</a>
      <ul>
        <li><a href="#启用文本搜索">启用文本搜索</a></li>
        <li><a href="#创建文本索引">创建文本索引</a></li>
        <li><a href="#删除文本索引">删除文本索引</a></li>
      </ul>
    </li>
    <li><a href="#正则表达式">正则表达式</a>
      <ul>
        <li><a href="#不区分大小写">不区分大小写</a></li>
        <li><a href="#使用正则表达式来处理数组元素">使用正则表达式来处理数组元素</a></li>
        <li><a href="#优化正则表达式查询">优化正则表达式查询</a></li>
      </ul>
    </li>
    <li><a href="#id自增">ID自增</a></li>
    <li><a href="#副本集">副本集</a>
      <ul>
        <li><a href="#推荐的配置">推荐的配置</a></li>
        <li><a href="#选举机制">选举机制</a></li>
        <li><a href="#仲裁者">仲裁者</a></li>
        <li><a href="#优先级">优先级</a></li>
        <li><a href="#延迟备份节点">延迟备份节点</a></li>
        <li><a href="#创建索引">创建索引</a></li>
        <li><a href="#同步">同步</a></li>
      </ul>
    </li>
    <li><a href="#分片">分片</a>
      <ul>
        <li><a href="#分片集群">分片集群</a></li>
        <li><a href="#mongodb-如何追踪集群数据">MongoDB 如何追踪集群数据</a></li>
        <li><a href="#均衡器">均衡器</a></li>
        <li><a href="#选择片键">选择片键</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












