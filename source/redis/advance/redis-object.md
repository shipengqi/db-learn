# 对象
Redis 用到的所有主要**数据结构**，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合，等等。

Redis 并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个**对象系统**，这个系统包含字符串对象、列表对象、哈希对象、集合对象和
有序集合对象这五种类型的对象。

## 对象的类型与编码
edis 使用对象来表示数据库中的键和值，每次在 Redis 的数据库中新创建一个键值对时，至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。

比如：
```sh
redis> SET msg "hello world"
OK
```

每个对象都由一个 `redisObject` 结构表示:
```c
typedef struct redisObject {

    // 类型
    unsigned type:4;

    // 编码
    unsigned encoding:4;

    // 指向底层实现数据结构的指针
    void *ptr;

    // ...

} robj;
```

### type
对象的 `type` 属性记录了对象的类型，这个属性的值可以是下面列表中的任意一个：
- `REDIS_STRING`，字符串对象
- `REDIS_LIST`，列表对象
- `REDIS_HASH`，哈希对象
- `REDIS_SET`，集合对象
- `REDIS_ZSET`，有序集合对象

对于 Redis 数据库保存的键值对来说，**键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种**，因此：
- 当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”
- 当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”

### 编码和底层实现
**对象的 `ptr` 指针指向对象的底层实现数据结构，而这些数据结构由对象的 `encoding` 属性决定**。

`encoding` 属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现：

| 编码 | 底层实现 |
| --- | --- |
| `REDIS_ENCODING_INT`（`int`） | `long` 类型的整数 |
| `REDIS_ENCODING_EMBSTR`（`embstr`） | `embstr` 编码的简单动态字符串 |
| `REDIS_ENCODING_RAW`（`raw`） | 简单动态字符串 |
| `REDIS_ENCODING_HT`（`hashtable`） | 字典 |
| `REDIS_ENCODING_LINKEDLIST`（`linkedlist`） | 双端链表 |
| `REDIS_ENCODING_ZIPLIST`（`ziplist`） | 压缩列表 |
| `REDIS_ENCODING_INTSET`（`intset`） | 整数集合 |
| `REDIS_ENCODING_SKIPLIST`（`skiplist`） | 跳跃表和字典 |


每种类型的对象都至少使用了两种不同的编码:

| 类型 | 编码 | 对象 |
| --- | --- | --- |
| `REDIS_STRING` | `REDIS_ENCODING_INT` | 使用整数值实现的字符串对象。 |
| `REDIS_STRING` | `REDIS_ENCODING_EMBSTR` | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |
| `REDIS_STRING` | `REDIS_ENCODING_RAW` | 使用简单动态字符串实现的字符串对象。 |
| `REDIS_LIST` | `REDIS_ENCODING_ZIPLIST` | 使用压缩列表实现的列表对象。 |
| `REDIS_LIST` | `REDIS_ENCODING_LINKEDLIST` | 使用双端链表实现的列表对象。 |
| `REDIS_HASH` | `REDIS_ENCODING_ZIPLIST` | 使用压缩列表实现的哈希对象。 |
| `REDIS_HASH` | `REDIS_ENCODING_HT` | 使用字典实现的哈希对象。 |
| `REDIS_SET` | `REDIS_ENCODING_INTSET` | 使用整数集合实现的集合对象。 |
| `REDIS_SET` | `REDIS_ENCODING_HT`	 | 使用字典实现的集合对象。 |
| `REDIS_ZSET` | `REDIS_ENCODING_ZIPLIST` | 使用压缩列表实现的有序集合对象。 |
| `REDIS_ZSET` | `REDIS_ENCODING_SKIPLIST` | 使用跳跃表和字典实现的有序集合对象。 |


## 字符串对象
字符串对象的编码可以是 `int` 、 `raw` 或者 `embstr` 。

### `int` 编码
一个字符串对象保存的是整数值，并且这个整数值可以用 `long` 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 `ptr` 属性里面（将 `void*` 转换成 `long`），
并将字符串对象的编码设置为 `int`。

### `raw` 编码
如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为 `raw`。\

### `embstr` 编码
如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于 39 字节，那么字符串对象将使用 `embstr` 编码的方式来保存这个字符串值。

`embstr` 编码是专门用于保存短字符串的一种优化编码方式，这种编码和 `raw` 编码一样，都使用 `redisObject` 结构和 `sdshdr` 结构来表示字符串对象，
但 **`raw` 编码会调用两次内存分配函数来分别创建 `redisObject` 结构和 `sdshdr` 结构，而 `embstr` 编码则通过调用一次内存分配函数来分配一块连续的空间，
空间中依次包含 `redisObject` 和 `sdshdr` 两个结构**。

`embstr` 编码的字符串对象来保存短字符串值有以下好处：
- `embstr` 编码将创建字符串对象所需的内存分配次数从 `raw` 编码的两次降低为一次。
- 释放 `embstr` 编码的字符串对象只需要调用一次内存释放函数， 而释放 `raw` 编码的字符串对象需要调用两次内存释放函数。
- 因为 `embstr` 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 `raw` 编码的字符串对象能够更好地利用缓存带来的优势。

## 列表对象
列表对象的编码可以是 `ziplist` 或者 `linkedlist` 。

### `ziplist` 编码
`ziplist` 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。

### `linkedlist` 编码
`linkedlist` 编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。

### 编码转换
当列表对象可以同时满足以下两个条件时，列表对象使用 `ziplist` 编码：
- 列表对象保存的所有字符串元素的长度都小于 64 字节；
- 列表对象保存的元素数量小于 512 个；

不能满足这两个条件的列表对象需要使用 `linkedlist` 编码。


## 哈希对象
哈希对象的编码可以是 `ziplist` 或者 `hashtable` 。

### `ziplist` 编码
`ziplist` 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：
- 保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；
- 先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

比如：
```sh
redis> HSET profile name "Tom"
(integer) 1

redis> HSET profile age 25
(integer) 1

redis> HSET profile career "Programmer"
(integer) 1
```

![](../../imgs/hashobject.png)

### `hashtable` 编码
`hashtable` 编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
- 字典的每个键都是一个字符串对象，对象中保存了键值对的键
- 字典的每个值都是一个字符串对象，对象中保存了键值对的值。

### 编码转换
当哈希对象可以同时满足以下两个条件时，哈希对象使用 `ziplist` 编码：
- 哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；
- 哈希对象保存的键值对数量小于 512 个；

不能满足这两个条件的哈希对象需要使用 `hashtable` 编码。

## 集合对象
集合对象的编码可以是 `intset` 或者 `hashtable` 。

### `intset` 编码
`intset` 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。

### `hashtable` 编码
**`hashtable` 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为 `NULL`**。

### 编码的转换
当集合对象可以同时满足以下两个条件时，对象使用 `intset` 编码：
- 集合对象保存的所有元素都是整数值
- 集合对象保存的元素数量不超过 512 个

不能满足这两个条件的集合对象需要使用 `hashtable` 编码。

## 有序集合对象
有序集合的编码可以是 `ziplist` 或者 `skiplist` 。

### `ziplist` 编码
`ziplist` 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member） 而第二个元素则保存元素的分值（score）。

压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。

### `skiplist` 编码
`skiplist` 编码的有序集合对象使用 `zset` 结构作为底层实现， 一个 `zset` 结构同时包含一个字典和一个跳跃表：
```c
typedef struct zset {

    zskiplist *zsl;

    dict *dict;

} zset;
```
#### zsl
结构中的 `zsl` 跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的 `object` 属性保存了元素的成员，
而跳跃表节点的 `score` 属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，如 `ZRANK` 、 `ZRANGE` 等命令就是基于跳跃表 API 来实现的。

#### dict
结构中的 `dict` 字典**为有序集合创建了一个从成员到分值的映射**，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，
而字典的值则保存了元素的分值。通过这个字典，程序可以用 `O(1)` 复杂度查找给定成员的分值，`ZSCORE` 命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。

#### 为什么有序集合需要同时使用跳跃表和字典来实现？
在理论上来说，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。

举个例子，如果我们只使用字典来实现有序集合，那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，
所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(N \log N) 时间复杂度，
以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。

另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，
所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(\log N) 。

因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。

**实际中，字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也不会因此而浪费任何内存**。

### 编码的转换
当有序集合对象可以同时满足以下两个条件时，对象使用 `ziplist` 编码：
- 有序集合保存的元素数量小于 128 个
- 有序集合保存的所有元素成员的长度都小于 64 字节

不能满足以上两个条件的有序集合对象将使用 `skiplist` 编码。

## 类型检查与命令多态
Redis 中用于操作键的命令基本上可以分为两种类型：
1. 其中一种命令可以对任何类型的键执行， 比如说 DEL 命令、 EXPIRE 命令、 RENAME 命令、 TYPE 命令、 OBJECT 命令， 等等。
2. 而另一种命令只能对特定类型的键执行， 比如说：
- SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；
- HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；
- RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；
- SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；
- ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行；

### 类型检查
为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis 会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。

类型特定命令所进行的类型检查是通过 `redisObject` 结构的 `type` 属性来实现的：
- 在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；
- 否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。

比如，对于 `LLEN` 命令来说：
- 在执行 `LLEN` 命令之前，服务器会先检查输入数据库键的值对象是否为列表类型， 检查值对象 `redisObject` 结构 `type` 属性的值是否为 `REDIS_LIST`，如果是的话，服务器就对键执行 `LLEN` 命令；
- 否则的话，服务器就拒绝执行命令并向客户端返回一个类型错误；

### 多态命令
Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。

比如，列表对象有 `ziplist` 和 `linkedlist` 两种编码可用。果我们对一个键执行 `LLEN` 命令，那么服务器除了要确保执行命令的是列表键之外，还需要根据键的值
对象所使用的编码来选择正确的 `LLEN` 命令实现：
- 如果列表对象的编码为 `ziplist` ， 那么说明列表对象的实现为压缩列表， 程序将使用 `ziplistLen` 函数来返回列表的长度；
- 如果列表对象的编码为 `linkedlist` ， 那么说明列表对象的实现为双端链表， 程序将使用 `listLength` 函数来返回双端链表的长度；

借用面向对象方面的术语来说， 我们可以认为 `LLEN` 命令是**多态（polymorphism）的**。

## 内存回收
C 语言并不具备自动的内存回收功能，所以 Redis 在自己的对象系统中构建了一个**引用计数**（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，
在适当的时候自动释放对象并进行内存回收。

每个对象的引用计数信息由 `redisObject` 结构的 `refcount` 属性记录：
```c
typedef struct redisObject {

    // ...

    // 引用计数
    int refcount;

    // ...

} robj;
```

对象的引用计数信息会随着对象的使用状态而不断变化：
- 在创建一个新对象时， 引用计数的值会被初始化为 1 ；
- 当对象被一个新程序使用时， 它的引用计数值会被增一；
- 当对象不再被一个程序使用时， 它的引用计数值会被减一；
- 当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。

## 对象共享
除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。

举个例子， 假设键 A 创建了一个包含整数值 100 的字符串对象作为值对象，如果这时键 B 也要创建一个同样保存了整数值 100 的字符串对象作为值对象，那么服务器有以下两种做法：
- 为键 B 新创建一个包含整数值 100 的字符串对象；
- 让键 A 和键 B 共享同一个字符串对象；

很明显第二种方法更节约内存。

在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：
1. 将数据库键的值指针指向一个现有的值对象；
2. 将被共享的值对象的引用计数增一。

### 为什么 Redis 不共享包含字符串的对象？
当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，
而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的 CPU 时间也会越多：
- 如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；
- 如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；
- 如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是 O(N^2) 。

受到 CPU 时间的限制， **Redis 只对包含整数值的字符串对象进行共享**。

## 对象的空转时长
介绍过的 `type` 、 `encoding` 、 `ptr` 和 `refcount` 四个属性之外，`redisObject` 结构包含的最后一个属性为 `lru` 属性， 该属性记录了对象最后一次被命令程序访问的时间：
```c
typedef struct redisObject {

    // ...

    unsigned lru:22;

    // ...

} robj;
```

**空转时长就是通过将当前时间减去键的值对象的 `lru` 时间计算得出的**，可以使用 OBJECT IDLETIME 命令：
```sh
redis> SET msg "hello world"
OK

# 等待一小段时间
redis> OBJECT IDLETIME msg
(integer) 20

# 等待一阵子
redis> OBJECT IDLETIME msg
(integer) 180

# 访问 msg 键的值
redis> GET msg
"hello world"

# 键处于活跃状态，空转时长为 0
redis> OBJECT IDLETIME msg
(integer) 0
```

> OBJECT IDLETIME 命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的 `lru` 属性。

**如果服务器打开了 `maxmemory` 选项，并且服务器用于回收内存的算法为 `volatile-lru` 或者 `allkeys-lru` ，那么当服务器占用的内存数超过了 `maxmemory` 选项所设置的上限值时，
空转时长较高的那部分键会优先被服务器释放，从而回收内存**。