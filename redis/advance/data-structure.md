# 数据结构与对象
## 简单动态字符串
Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串），而是自己构建了一种名为**简单
动态字符串**（simple dynamic string，SDS）的抽象类型， 并将 **SDS** 用作 Redis 的默认字符串表示。

Redis 中， C 字符串只会作为字符串字面量（string literal），用在一些无须对字符串值进行修改的地方，比如打印日志：
```c
redisLog(REDIS_WARNING,"Redis is now ready to exit, bye bye...");
```

一个可以被修改的字符串值时，Redis 就会使用 SDS 来表示字符串值：比如在 Redis 的数据库里面，包含字符串值的键值对在底层都是由 SDS 实现的。
```sh
redis> SET msg "hello world"
OK
```
其中：
- 键值对的**键是一个字符串对象**，对象的底层实现是一个保存着字符串 "msg" 的 SDS 。
- 键值对的**值也是一个字符串对象**，对象的底层实现是一个保存着字符串 "hello world" 的 SDS 。

又比如：
```sh
redis> RPUSH fruits "apple" "banana" "cherry"
(integer) 3
```
其中：
- 键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串 "fruits" 的 SDS 。
- 键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个 SDS 实现：
第一个 SDS 保存着字符串 "apple" ， 第二个 SDS 保存着字符串 "banana" ， 第三个 SDS 保存着字符串 "cherry" 。

**AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现的**。

### SDS 与 C 字符串的区别
#### 常数复杂度获取字符串长度
C 字符串并不记录自身的长度信息，所以为了获取一个 C 字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，
这个操作的复杂度为 `O(N)`。

SDS 在 `len` 属性中记录了 SDS 本身的长度，所以获取一个 SDS 长度的复杂度仅为 `O(1)`。

比如下面的例子，程序只要访问 SDS 的 len 属性， 就可以立即知道 SDS 的长度为 5 字节：
![](../../img/sds,png)

使用 SDS 确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。

比如说，对一个非常长的字符串键反复执行 `STRLEN` 命令，也不会对系统性能造成任何影响，因为 `STRLEN` 命令的复杂度仅为 `O(1)`。

#### 杜绝缓冲区溢出
C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。

例如，`<string.h>/strcat` 函数可以将 `src` 字符串中的内容拼接到 `dest` 字符串的末尾：
```c
char *strcat(char *dest, const char *src);
```
因为 C 字符串不记录自身的长度，所以 `strcat` 假定用户在执行这个函数时，已经为 `dest` 分配了足够多的内存， 可以容纳 `src` 字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲区溢出。

SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求，如果不满足的话，
API 会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出问题。

比如 SDS 的 API 中的 `sdscat` 函数，它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面，但是在执行拼接操作之前，`sdscat` 会先检查给定 SDS 的空间是否足够，
如果不够的话，`sdscat` 就会先扩展 SDS 的空间， 然后才执行拼接操作。

#### 减少修改字符串时带来的内存重分配次数
C 字符串并不记录自身的长度， 所以对于一个包含了 N 个字符的 C 字符串来说，这个 C 字符串的底层实现总是一个 `N+1` 个字符长的数组（额外的一个字符空间用于保存空字符）。

因为 C 字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个 C 字符串，程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：
- 如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。
- 如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。

**在 SDS 中，`buf` 数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由 SDS 的 `free` 属性记录**。

SDS 实现了空间预分配和惰性空间释放两种优化策略。

##### 空间预分配
空间预分配用于优化 SDS 的字符串增长操作：当 SDS 的 API 对一个 SDS 进行修改，并且需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须要的空间，
还会为 SDS 分配额外的未使用空间。

额外分配的未使用空间数量由以下公式决定：
- 如果对 SDS 进行修改之后， SDS 的长度（也即是 `len` 属性的值）将小于 `1 MB` ，那么程序分配和 `len` 属性同样大小的未使用空间，
这时 SDS `len` 属性的值将和 `free` 属性的值相同。举个例子，如果进行修改之后， SDS 的 `len` 将变成 13 字节，那么程序也会分配 13 字节的未使用空间， SDS 的 `buf` 数组
的实际长度将变成 `13 + 13 + 1 = 27` 字节（额外的一字节用于保存空字符）。
- 如果对 SDS 进行修改之后， SDS 的长度将大于等于 `1 MB` ，那么程序会分配 `1 MB` 的未使用空间。举个例子，如果进行修改之后， SDS 的 `len` 将变成 `30 MB` ，
那么程序会分配 `1 MB` 的未使用空间， SDS 的 `buf` 数组的实际长度将为 30 MB + 1 MB + 1 byte 。

在扩展 SDS 空间之前，SDS API 会先检查未使用空间是否足够，如果足够的话，API 就会直接使用未使用空间，而无须执行内存重分配。

通过这种预分配策略，SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。

##### 惰性空间释放
惰性空间释放用于优化 SDS 的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，
而是使用 `free` 属性将这些字节的数量记录起来，并等待将来使用。

通过惰性空间释放策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。

SDS 也提供了相应的 API ，让我们可以在有需要时，真正地释放 SDS 里面的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。

#### 二进制安全
C 字符串中的字符必须符合某种编码（比如 ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的
空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是**二进制安全**的（binary-safe）：所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 `buf` 数组里的数据，
程序不会对其中的数据做任何限制、过滤、或者假设 —— **数据在写入时是什么样的，它被读取时就是什么样**。

这也是我们将 SDS 的 `buf` 属性称为字节数组的原因 —— **Redis 不是用这个数组来保存字符，而是用它来保存一系列二进制数据**。

#### 兼容部分 C 字符串函数
SDS 的 API 都是二进制安全的，但它们一样遵循 C 字符串以空字符结尾的惯例：这些 API 总会将 SDS 保存的数据的末尾设置为空字符，并且总会在为 `buf` 数组分配空间时多分配一
个字节来容纳这个空字符，这是为了让那些保存文本数据的 SDS 可以重用一部分 `<string.h>` 库定义的函数。

## 链表
链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。

作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为 Redis 使用的 C 语言并没有内置这种数据结构，所以 Redis 构建了自己的链表实现。

### 链表节点的实现
每个链表节点使用一个 `adlist.h/listNode` 结构：
```c
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```
使用 `adlist.h/list` 来持有链表：
```c
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

} list;
```
`list` 结构为链表提供了表头指针 `head` 、表尾指针 `tail` ，以及链表长度计数器 `len` ，而 `dup` 、 `free` 和 `match` 成员则是用于实现多态链表所需的类型特定函数：
- `dup` 函数用于复制链表节点所保存的值；
- `free` 函数用于释放链表节点所保存的值；
- `match` 函数则用于对比链表节点所保存的值和另一个输入值是否相等。

![](../../img/list-nodes.png)

Redis 的链表实现的特性：
- 双端：链表节点带有 `prev` 和 `next` 指针，获取某个节点的前置节点和后置节点的复杂度都是 `O(1)`。
- 无环：表头节点的 `prev` 指针和表尾节点的 `next` 指针都指向 `NULL` ，对链表的访问以 `NULL` 为终点。
- 带表头指针和表尾指针：通过 `list` 结构的 `head` 指针和 `tail` 指针，程序获取链表的表头节点和表尾节点的复杂度为 `O(1)`。
- 带链表长度计数器：程序使用 `list` 结构的 `len` 属性来对 `list` 持有的链表节点进行计数，程序获取链表中节点数量的复杂度为 `O(1)`。
- 多态：链表节点使用 `void*` 指针来保存节点值， 并且可以通过 `list` 结构的 `dup` 、 `free` 、 `match` 三个属性为节点值设置类型特定函数，
所以链表可以用于保存各种不同类型的值。

## 字典
字典（dict），又称符号表（symbol table）、关联数组（associative array）或者映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。

字典中的每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值，或者通过键来更新值，又或者根据键来删除整个键值对，等等。

Redis 构建了自己的字典实现。

**dict 是 Redis 服务器中出现最为频繁的复合型数据结构，除了 `hash` 结构的数据会用到字典外，整个 Redis 数据库的所有 key 和 value 也组成了一个全局字典，
还有带过期时间的 key 集合也是一个字典。`zset` 集合中存储 value 和 score 值的映射关系也是通过 dict 结构实现的。

### 哈希算法
当要将一个新的键值对添加到字典里面时，**程序需要先根据键值对的键计算出哈希值和索引值**（注意这里是根据键计算索引，我所了解的不管是 MySQL 还是 MongoDB 都是根据字段的值计算
索引的，Redis 是 key-value 存储，只需要针对 key 进行增删改查），然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

Redis 计算哈希值和索引值的方法如下：
```c
# 使用字典设置的哈希函数，计算键 key 的哈希值
hash = dict->type->hashFunction(key);

# 使用哈希表的 sizemask 属性和哈希值，计算出索引值
# 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]
index = hash & dict->ht[x].sizemask;
```

比如：将一个键值对 k0 和 v0 添加到字典里面， 那么程序会：
```c
# 计算键 k0 的哈希值
hash = dict->type->hashFunction(k0);

# 假设计算得出的哈希值为 8 ， 那么程序会继续使用语句
index = hash & dict->ht[0].sizemask = 8 & 3 = 0;
```
计算出键 k0 的索引值 0 ，这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上。

![](../../img/hashtable.png)


### 解决键冲突
当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了**冲突**（collision）。

Redis 的哈希表使用**链地址法**（separate chaining）来解决键冲突：**每个哈希表节点都有一个 `next` 指针，
多个哈希表节点可以用 `next` 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题**。

![](../../img/hashtable-link.png)

因为 **`dictEntry` 节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置**（复杂度为 `O(1)`），排在其他已有节点的前面。

### rehash
哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，
程序需要对哈希表的大小进行相应的扩展或者收缩。

扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成，步骤如下：
1. 为字典的 `ht[1]` 哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及 `ht[0]` 当前包含的键值对数量（也即是 `ht[0].used` 属性的值）：
  - 如果执行的是扩展操作， 那么 `ht[1]` 的大小为第一个大于等于 `ht[0].used * 2` 的 `2^n`（2 的 n 次方幂）；
  - 如果执行的是收缩操作， 那么 `ht[1]` 的大小为第一个大于等于 `ht[0].used` 的 `2^n` 。
2. 将保存在 `ht[0]` 中的所有键值对 rehash 到 `ht[1]` 上面： rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 `ht[1]` 哈希表的指定位置上。
3. 当 `ht[0]` 包含的所有键值对都迁移到了 `ht[1]` 之后 （`ht[0]` 变为空表）， 释放 `ht[0]` ，将 `ht[1]` 设置为 `ht[0]`， 并在 `ht[1]` 新创建一个空白哈希表，
为下一次 rehash 做准备。

#### 哈希表的扩展与收缩
当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：
- 服务器目前没有在执行 `BGSAVE` 命令或者 `BGREWRITEAOF` 命令， 并且哈希表的负载因子大于等于 1 ；
- 服务器目前正在执行 `BGSAVE` 命令或者 `BGREWRITEAOF` 命令， 并且哈希表的负载因子大于等于 5 ；
- 当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。

负载因子公式：
```c
# 负载因子 = 哈希表已保存节点数量 / 哈希表大小
load_factor = ht[0].used / ht[0].size

# 例，对于一个大小为 4 ， 包含 4 个键值对的哈希表，负载因子
load_factor = 4 / 4 = 1
```

根据 `BGSAVE` 命令或 `BGREWRITEAOF` 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 `BGSAVE` 命令或 `BGREWRITEAOF` 命令的过程中，
 Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率， 所以在子进程存在期间，
服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。

#### 渐进式 rehash
**rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的**。

原因在于，Redis 是单线程的，如果哈希表里保存的键值对数量非常庞大，一次性 rehash 庞大的计算量会导致服务器一段时间内停止服务。

渐进式 rehash 的详细步骤：
1. 为 `ht[1]` 分配空间，让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。
2. 在字典中维持一个索引计数器变量 `rehashidx` ，并将它的值设置为 0 ， 表示 rehash 工作正式开始。
3. 在 rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ，
当 rehash 工作完成之后，程序将 `rehashidx` 属性的值增一。
4. 随着字典操作的不断执行，最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ，这时程序将 `rehashidx` 属性的值设为 `-1`，表示 rehash 操作已完成。


渐进式 rehash 的过程中，字典会同时使用 `ht[0]` 和 `ht[1]` 两个哈希表，所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。

## 跳跃表
**跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的**。

Redis 只在两个地方用到了跳跃表 一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。

### 跳跃表的实现
Redis 的跳跃表由 `redis.h/zskiplistNode` 和 `redis.h/zskiplist` 两个结构定义，其中 `zskiplistNode` 结构用于表示跳跃表节点，而 `zskiplist` 结构则用于保存跳跃表
节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。

![](../../img/skiplist.png)

`zskiplist` 结构， 该结构包含以下属性：
- `header`：指向跳跃表的表头节点。
- `tail`：指向跳跃表的表尾节点。
- `level`：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。
- `length`：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。

`zskiplistNode` 结构， 该结构包含以下属性：
- 层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：**前进指针和跨度**。
前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。
当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。
- 后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。
- 分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。
- 成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。

#### 跳跃表节点


