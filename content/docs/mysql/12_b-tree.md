---
title: B+ 树索引
---

1. InnoDB 的各个数据页会组成一个**双向链表**。
2. 每个数据页为 `User Records` 中的记录划分**组**，并生成 `Page Directory`。
3. `Page Directory` 中的每个**槽**对应一个**分组的最后一条记录**。
4. 通过主键查找某条记录的时，在 `Page Directory` 中使用**二分法**快速定位到对应的**槽**，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

![innodb-data-page-link](../../../images/innodb-data-page-link.jpg)

## 没有索引的查找

没有索引的时候是怎么查找记录的？比如：

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

### 在一个页中的查找

如果表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

- 以主键为搜索条件

在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

- 以其他列作为搜索条件

对非主键列，数据页中并**没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录**，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

### 在很多页中查找

大部分情况下表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：

1. 定位到记录所在的页。
2. 从所在的页内中查找相应的记录。

由于并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，每一个页中再使用上面一个页中的查找方法。非常低效。

## 索引

```sh
mysql> CREATE TABLE index_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 CHAR(1),
    ->     PRIMARY KEY(c1)
    -> ) ROW_FORMAT = Compact;
Query OK, 0 rows affected (0.03 sec)
```

### 简单的索引方案

根据某个搜索条件查找一些记录时为什么要遍历所有的数据页？

因为各个页中的记录并没有规律，我们并不知道搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。

那么，如何快速定位记录所在的数据页？

我们可以创建 `Page directoty` 来快速定位页中的记录，也可以建一个类似的目录来定位记录所在的页：

### B+ 树

#### 聚簇索引

1. 使用记录主键值的大小进行记录和页的排序
2. B+ 树的叶子节点存储完整的用户记录（记录中存储了所有列的值，包括隐藏列）。

具有这两种特性的 B+ 树称为**聚簇索引**，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这就是所谓的**索引即数据，数据即索引**。

#### 二级索引

**非主键列**建立的 B+ 树需要一次**回表**操作才可以定位到完整的用户记录，所以这种 B+ 树也被称为**二级索引**（secondary index），或者**辅助索引**。

二级索引的叶子节点包含的用户记录由 `索引列 + 主键` 组成。

#### 联合索引

联合索引，本质上也是一个二级索引。

### B+ 树索引的注意事项

**一个 B+ 树索引的根节点自诞生之日起，便不会再移动**。根节点一旦建立，它的页号便会被记录到某个地方，然后 InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

B+ 树的形成过程：

- 当为某个表创建一个 B+ 树索引时，都会为这个索引创建一个**根节点**页。最开始表中没有数据的时候，每个 B+ 树索引对应的根节点中既没有用户记录，也没有目录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。
- 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 `页 a` 中，然后对这个新页进行**页分裂**的操作，得到另一个新页，比如 `页 b`。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 `页 a` 或者 `页 b` 中，而**根节点升级为存储目录项记录的页**。

**B+ 树的同一层内节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

- 索引列的值
- 主键值
- 页号

把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证 B+ 树每一层节点中各条目录项记录除页号这个字段外是**唯一**的。

**一个页面最少存储2条记录**。

## 索引的代价

- 空间上的代价

每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树会消耗很大的一片存储空间。

- 时间上的代价

每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。**B+ 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表**。不论是叶子节点中的记录，还是非叶**节点中的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表**。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要**额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序**。

一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。

## 索引的使用

### B+ 树索引适用的条件

联合索引的各个排序列的排序顺序必须是一致的

### 全值匹配

### 匹配左边的列

### 匹配列前缀

### 匹配范围值

### 用于排序

### 用于分组

### 回表的代价

### 覆盖索引

为了彻底告别回表操作带来的性能损耗：**最好在查询列表里只包含索引列**

### 如何挑选索引

#### 只为用于搜索、排序或分组的列创建索引

#### 考虑列的基数

**列的基数**指的是某一列中不重复数据的个数，比方说某个列包含值 `2, 5, 8, 2, 5, 8, 2, 5, 8`，虽然有 9 条记录，但该列的基数却是 `3`。也就是说，在**记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中**。

假设某个列的基数为 1，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了

而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。

**最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好**。

#### 索引列的类型尽量小

以整数类型为例，有 `TINYINT`、`MEDIUMINT`、`INT`、`BIGINT` 这么几种，它们占用的存储空间依次递增，我们这里所说的**类型大小指的就是该类型表示的数据范围的大小**。

在表示的整数范围允许的情况下，**尽量让索引列使用较小的类型**：

- 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）
- 数据类型越小，**索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率**。

#### 冗余和重复索引
