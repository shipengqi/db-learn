---
title: B+ 树索引
---

1. InnoDB 的各个数据页会组成一个**双向链表**。
2. 每个数据页为 `User Records` 中的记录划分**组**，并生成 `Page Directory`。
3. `Page Directory` 中的每个**槽**对应一个**分组的最后一条记录**。
4. 通过主键查找某条记录的时，在 `Page Directory` 中使用**二分法**快速定位到对应的**槽**，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

![innodb-data-page-link](../../../images/innodb-data-page-link.jpg)

## 没有索引的查找

没有索引的时候是怎么查找记录的？比如：

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

### 在一个页中的查找

如果表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

- 以主键为搜索条件

在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

- 以其他列作为搜索条件

对非主键列，数据页中并**没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录**，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

### 在很多页中查找

大部分情况下表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：

1. 定位到记录所在的页。
2. 从所在的页内中查找相应的记录。

由于并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，每一个页中再使用上面一个页中的查找方法。非常低效。

## 索引

```sh
mysql> CREATE TABLE index_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 CHAR(1),
    ->     PRIMARY KEY(c1)
    -> ) ROW_FORMAT = Compact;
Query OK, 0 rows affected (0.03 sec)
```

### 简单的索引方案

根据某个搜索条件查找一些记录时为什么要遍历所有的数据页？

因为各个页中的记录并没有规律，我们并不知道搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。

那么，如何快速定位记录所在的数据页？

我们可以创建 `Page directoty` 来快速定位页中的记录，也可以建一个类似的目录来定位记录所在的页：

### B+ 树

#### 为什么是 B+ 树

哈希表是一种以键-值（key-value）存储数据的结构，插入和查询都很快，但是适用于只有等值查询的场景，范围查询很慢。

有序数组在等值查询（二分法）和范围查询场景中的性能就都非常优秀。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。

#### 聚簇索引

1. 使用记录主键值的大小进行记录和页的排序
2. B+ 树的叶子节点存储完整的用户记录（记录中存储了所有列的值，包括隐藏列）。

具有这两种特性的 B+ 树称为**聚簇索引**，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这就是所谓的**索引即数据，数据即索引**。

#### 二级索引

**非主键列**建立的 B+ 树需要一次**回表**操作才可以定位到完整的用户记录，所以这种 B+ 树也被称为**二级索引**（secondary index），或者**辅助索引**。

二级索引的叶子节点包含的用户记录由 `索引列 + 主键` 组成。

#### 联合索引

联合索引，本质上也是一个二级索引。

### B+ 树索引的注意事项

**一个 B+ 树索引的根节点自诞生之日起，便不会再移动**。根节点一旦建立，它的页号便会被记录到某个地方，然后 InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

B+ 树的形成过程：

- 当为某个表创建一个 B+ 树索引时，都会为这个索引创建一个**根节点**页。最开始表中没有数据的时候，每个 B+ 树索引对应的根节点中既没有用户记录，也没有目录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。
- 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 `页 a` 中，然后对这个新页进行**页分裂**的操作，得到另一个新页，比如 `页 b`。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 `页 a` 或者 `页 b` 中，而**根节点升级为存储目录项记录的页**。

**B+ 树的同一层内节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

- 索引列的值
- 主键值
- 页号

把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证 B+ 树每一层节点中各条目录项记录除页号这个字段外是**唯一**的。

**一个页面最少存储2条记录**。

## 索引的代价

- 空间上的代价

每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树会消耗很大的一片存储空间。

- 时间上的代价

每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。**B+ 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表**。不论是叶子节点中的记录，还是非叶**节点中的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表**。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要**额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序**。

一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。

## 索引的使用

### B+ 树索引适用的条件

联合索引的各个排序列的排序顺序必须是一致的

```sql
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

二级索引 `idx_name_birthday_phone_number`，它是由 3 个列组成的联合索引。所以在这个索引对应的 B+ 树的叶子节点处存储的用户记录只保留 `name`、`birthday`、`phone_number` 这三个列的值以及主键 `id` 的值

这个 `idx_name_birthday_phone_number` 索引对应的 B+ 树中页面和记录的排序方式就是这样的：

- 先按照 name 列的值进行排序。
- 如果 `name` 列的值相同，则按照 `birthday` 列的值进行排序。
- 如果 `birthday` 列的值也相同，则按照 `phone_number` 的值进行排序。

这个排序方式非常重要，因为**只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找**。

### 全值匹配

`SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';`

`idx_name_birthday_phone_number` 索引包含的 3 个列，查询过程：

1. B+ 树的数据页和记录是先按照 name 列的值进行排序的，可以先按照 name 列来查找。
2. name 列相同的记录又是按照 birthday 进行排序的，可以继续按照 birthday 来查找。
3. 如果 name 和 birthday 都是相同的，会按照 `phone_number` 列的值排序。

name、birthday、phone_number 这几个搜索列的顺序对查询结果没有影响，因为优化器可以优化语句。

### 匹配左边的列

比如：`SELECT * FROM person_info WHERE name = 'Ashburn';` 或者 `SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';` 没有包含全部联合索引的列，只要包含左边的一列或者多列，也可以使用索引。

因为 B+ 树的联合索引按照索引从左到右的顺序排序的，也就是说 name 列的值不同，birthday 的值可能是无序的。而且跳过 name 列直接根据 birthday 的值去查找，是做不到的。

**如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列**。

### 匹配列前缀

字符串排序的本质就是比较哪个字符串大一点儿，哪个字符串小一点，比较字符串大小就用到了该列的字符集和比较规则。

比较两个字符串的大小的过程其实是这样的：

- 先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。
- 如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。
- 如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。

所以一个排好序的字符串列其实有这样的特点：

- 先按照字符串的第一个字符进行排序。
- 如果第一个字符相同再按照第二个字符进行排序。
- 如果第二个字符相同再按照第三个字符进行排序，依此类推。

也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，比方说我们想查询名字以'As'开头的记录，那就可以这么写查询语句：

```sql
SELECT * FROM person_info WHERE name LIKE 'As%';
```

但是如果只给出后缀或者中间某个字符串，如 `%As%`，就没办法利用索引了。

### 匹配范围值

**所有记录都是按照索引列的值从小到大的顺序排好序的**，所以查找某个范围的值的记录是很简单的。

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

记录是先按 name 列排序的，所以我们上边的查询过程其实是这样的：

- 找到 name 值为 Asa 的记录。
- 找到 name 值为 Barlow 的记录。
- 由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来
- 找到这些记录的主键值，再到**聚簇索引中回表**查找完整的记录。

**如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+ 树索引**。

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';
```

查询可以分成两个部分：

1. 通过条件 `name > 'Asa' AND name < 'Barlow'` 来对name进行范围，查找的结果可能有多条 name 值不同的记录，
1. 对这些 name 值不同的记录继续通过 `birthday > '1980-01-01'` 条件继续过滤。

对于联合索引 `idx_name_birthday_phone_number` 来说，**只能用到 name 列的部分，而用不到 birthday 列的部分，因为只有 name 值相同的情况下才能用 birthday 列的值进行排序**。

### 精确匹配某一列并范围匹配另外一列

对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

`name = 'Ashburn'`，对name列进行精确查找，当然可以使用B+树索引了。

`birthday > '1980-01-01' AND birthday < '2000-12-31'`，由于name列是精确查找，所以通过 `name = 'Ashburn'`条件查找后得到的结果的name值都是相同的，它们会再按照birthday的值进行排序。所以此时对birthday列进行范围查找是可以用到 B+ 树索引的。

`phone_number > '15100000000'`，通过 birthday 的范围查找的记录的 birthday 的值可能不同，所以这个条件无法再利用 B+ 树索引了，只能遍历上一步查询得到的记录。

### 用于排序

一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、吧啦吧啦排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在MySQL中，把这种在内存中或者磁盘上进行排序的方式统称为**文件排序**。

如果 `ORDER BY` 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

这个查询的结果集需要先按照name值排序，如果记录的name值相同，则需要按照birthday来排序，如果birthday的值相同，则需要按照 `phone_number` 排序。大家可以回过头去看我们建立的 `idx_name_birthday_phone_number` 索引的示意图，因为这个B+树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。

注意，ORDER BY的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 `ORDER BY phone_number, birthday, name` 的顺序，那也是用不了B+树索引

同理，`ORDER BY name、ORDER BY name, birthday` 这种匹配索引左边的列的形式可以使用部分的B+树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序

```sql
SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;
```

不可以使用索引进行排序:

- ASC、DESC 混用
- 排序列包含非同一个索引的列
- 排序列使用了复杂的表达式 `SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;`

### 用于分组

`SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number`

先把记录按照name值进行分组，所有name值相同的记录划分为一组。

将每个name值相同的分组里的记录再按照birthday的值进行分组，将birthday值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。

再将上一步中产生的小分组按照phone_number的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把大分组分成若干个小分组，然后把若干个小分组再细分成更多的小小分组。

如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的B+树中的索引列的顺序是一致的，而我们的B+树索引又是按照索引列排好序的，这不正好么，所以可以直接使用B+树索引进行分组。

### 回表的代价

`idx_name_birthday_phone_number` 索引为例

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

索引 `idx_name_birthday_phone_number` 对应的 B+ 树用户记录中只包含 `name`、`birthday`、`phone_number`、`id` 这 4 个字段，而查询列表是 `*`，意味着要查询表中所有字段。这时需要把从上一步中获取到的每一条记录的id字段都到聚簇索引对应的 B+ 树中找到完整的用户记录，也就是我们通常所说的**回表**，然后把完整的用户记录返回给查询用户。

#### 顺序 I/O

索引 `idx_name_birthday_phone_number` 对应的 B+ 树中的记录首先会按照 `name` 列的值进行排序，所以值在 `Asa～Barlow` 之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为**顺序 I/O**

#### 随机 I/O

根据第 1 步中获取到的记录的id字段的值可能并不相连，而在聚簇索引中记录是根据 `id`（也就是主键）的顺序排列的，所以根据这些并不连续的 `id` 值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为**随机 I/O**

顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。

**需要回表的记录越多，使用二级索引的性能就越低**。某些查询宁愿使用全表扫描也不使用二级索引。比方说name值在Asa～Barlow之间的用户记录数量占全部记录数量90%以上，那么如果使用 `idx_name_birthday_phone_number` 索引的话，有90%多的id值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。

查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引 + 回表的方式。

回表的记录特别少，优化器就会倾向于使用二级索引 + 回表的方式执行查询。

### 覆盖索引

为了彻底告别回表操作带来的性能损耗：**最好在查询列表里只包含索引列**

```sql
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
```

只查询name, birthday, phone_number这三个索引列的值，所以在通过idx_name_birthday_phone_number索引得到结果后就不必到聚簇索引中再查找记录的剩余列，也就是country列的值了，这样就省去了回表操作带来的性能损耗。

**不鼓励用 `*` 号作为查询列表，最好把我们需要查询的列依次标明**。

### 索引下推

`SELECT * FROM person_info WHERE name LIKE 'As%' and birthday='2000-12-31';`

前缀索引规则，所以这个语句在搜索索引树的时候，只能用 "As"，总比全表扫描要好。

然后呢？

当然是判断其他条件是否满足。

MySQL 5.6 之前，只能一个个回表。到主键索引上找出数据行，再对比字段值。

而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

### 如何挑选索引

#### 只为用于搜索、排序或分组的列创建索引

#### 考虑列的基数

**列的基数**指的是某一列中不重复数据的个数，比方说某个列包含值 `2, 5, 8, 2, 5, 8, 2, 5, 8`，虽然有 9 条记录，但该列的基数却是 `3`。也就是说，在**记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中**。

假设某个列的基数为 1，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了

而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。

**最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好**。

#### 索引列的类型尽量小

以整数类型为例，有 `TINYINT`、`MEDIUMINT`、`INT`、`BIGINT` 这么几种，它们占用的存储空间依次递增，我们这里所说的**类型大小指的就是该类型表示的数据范围的大小**。

在表示的整数范围允许的情况下，**尽量让索引列使用较小的类型**：

- 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）
- 数据类型越小，**索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率**。

#### 只对字符串的前几个字符进行索引

假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。

B+树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。

如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。

只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。

```sql
CREATE TABLE person_info(
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);    
```

但是会影响排序，因为二级索引中不包含完整的name列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只好乖乖的用文件排序喽。

前缀索引就用不上覆盖索引对查询性能的优化 因为系统并不确定前缀索引的定义是否截断了完整信息。

使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。

于是，你就有个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？

实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，

#### 让索引列在比较表达式中单独出现

整数列my_col，我们为这个列建立了索引

`WHERE my_col * 2 < 4` 是以 `my_col * 2` 这样的表达式的形式出现的，存储引擎会依次**遍历所有的记录**，计算这个表达式的值是不是小于4

`WHERE my_col < 4/2` my_col列并是以单独列的形式出现的，这样的情况可以直接使用B+树索引。

**如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的**。

#### 主键插入顺序

据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，可能需要**页面分裂和记录移位**。意味着：**性能损耗**。

最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：**让主键具有 AUTO_INCREMENT，让存储引擎自己为表生成主键**，而不是我们手动插入

#### 冗余和重复索引

## 索引选择异常和处理

一种方法是，采用force index强行选择一个索引。

```sql
set long_query_time=0;
select * from t where a between 10000 and 20000; /*Q1*/
select * from t force index(a) where a between 10000 and 20000;/*Q2*/
```

第二种方法就是，我们可以考虑修改语句，引导MySQL使用我们期望的索引。
第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。
