---
title: B+ 树索引
---

1. InnoDB 的各个数据页会组成一个**双向链表**。
2. 每个数据页为 `User Records` 中的记录划分**组**，并生成 `Page Directory`。
3. `Page Directory` 中的每个**槽**对应一个**分组的最后一条记录**。
4. 通过主键查找某条记录的时，在 `Page Directory` 中使用**二分法**快速定位到对应的**槽**，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

![innodb-data-page-link](../../../images/innodb-data-page-link.jpg)

## 没有索引的查找

没有索引的时候是怎么查找记录的？比如：

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

### 在一个页中的查找

如果表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

- 以主键为搜索条件

在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

- 以其他列作为搜索条件

对非主键列，数据页中并**没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录**，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

### 在很多页中查找

大部分情况下表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：

1. 定位到记录所在的页。
2. 从所在的页内中查找相应的记录。

由于并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，每一个页中再使用上面一个页中的查找方法。非常低效。

## 索引

```sh
mysql> CREATE TABLE index_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 CHAR(1),
    ->     PRIMARY KEY(c1)
    -> ) ROW_FORMAT = Compact;
Query OK, 0 rows affected (0.03 sec)
```

### 简单的索引方案

根据某个搜索条件查找一些记录时为什么要遍历所有的数据页？

因为各个页中的记录并没有规律，我们并不知道搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。

那么，如何快速定位记录所在的数据页？

我们可以创建 `Page directoty` 来快速定位页中的记录，也可以建一个类似的目录来定位记录所在的页：

### B+ 树

#### 为什么是 B+ 树

哈希表是一种以键-值（key-value）存储数据的结构，插入和查询都很快，但是适用于只有等值查询的场景，范围查询很慢。

有序数组在等值查询（二分法）和范围查询场景中的性能就都非常优秀。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。

#### 聚簇索引

1. 使用记录主键值的大小进行记录和页的排序
2. B+ 树的叶子节点存储完整的用户记录（记录中存储了所有列的值，包括隐藏列）。

具有这两种特性的 B+ 树称为**聚簇索引**，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这就是所谓的**索引即数据，数据即索引**。

#### 二级索引

**非主键列**建立的 B+ 树需要一次**回表**操作才可以定位到完整的用户记录，所以这种 B+ 树也被称为**二级索引**（secondary index），或者**辅助索引**。

二级索引的叶子节点包含的用户记录由 `索引列 + 主键` 组成。

#### 联合索引

联合索引，本质上也是一个二级索引。

### B+ 树索引的注意事项

**一个 B+ 树索引的根节点自诞生之日起，便不会再移动**。根节点一旦建立，它的页号便会被记录到某个地方，然后 InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

B+ 树的形成过程：

- 当为某个表创建一个 B+ 树索引时，都会为这个索引创建一个**根节点**页。最开始表中没有数据的时候，每个 B+ 树索引对应的根节点中既没有用户记录，也没有目录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。
- 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 `页 a` 中，然后对这个新页进行**页分裂**的操作，得到另一个新页，比如 `页 b`。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 `页 a` 或者 `页 b` 中，而**根节点升级为存储目录项记录的页**。

**B+ 树的同一层内节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

- 索引列的值
- 主键值
- 页号

把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证 B+ 树每一层节点中各条目录项记录除页号这个字段外是**唯一**的。

**一个页面最少存储2条记录**。

## 索引的代价

- 空间上的代价

每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树会消耗很大的一片存储空间。

- 时间上的代价

每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。**B+ 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表**。不论是叶子节点中的记录，还是非叶**节点中的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表**。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要**额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序**。

一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。

## 索引的使用

### B+ 树索引适用的条件

联合索引的各个排序列的排序顺序必须是一致的

```sql
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

二级索引 `idx_name_birthday_phone_number`，它是由 3 个列组成的联合索引。所以在这个索引对应的 B+ 树的叶子节点处存储的用户记录只保留 `name`、`birthday`、`phone_number` 这三个列的值以及主键 `id` 的值

这个 `idx_name_birthday_phone_number` 索引对应的 B+ 树中页面和记录的排序方式就是这样的：

- 先按照 name 列的值进行排序。
- 如果 `name` 列的值相同，则按照 `birthday` 列的值进行排序。
- 如果 `birthday` 列的值也相同，则按照 `phone_number` 的值进行排序。

这个排序方式非常重要，因为**只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找**。

### 全值匹配

### 匹配左边的列

### 匹配列前缀

### 匹配范围值

### 用于排序

### 用于分组

### 回表的代价

`idx_name_birthday_phone_number` 索引为例

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

索引 `idx_name_birthday_phone_number` 对应的 B+ 树用户记录中只包含 `name`、`birthday`、`phone_number`、`id` 这 4 个字段，而查询列表是 `*`，意味着要查询表中所有字段。这时需要把从上一步中获取到的每一条记录的id字段都到聚簇索引对应的 B+ 树中找到完整的用户记录，也就是我们通常所说的**回表**，然后把完整的用户记录返回给查询用户。

#### 顺序 I/O

索引 `idx_name_birthday_phone_number` 对应的 B+ 树中的记录首先会按照 `name` 列的值进行排序，所以值在 `Asa～Barlow` 之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为**顺序 I/O**

#### 随机 I/O

根据第 1 步中获取到的记录的id字段的值可能并不相连，而在聚簇索引中记录是根据 `id`（也就是主键）的顺序排列的，所以根据这些并不连续的 `id` 值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为**随机 I/O**

顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。

**需要回表的记录越多，使用二级索引的性能就越低**。某些查询宁愿使用全表扫描也不使用二级索引。比方说name值在Asa～Barlow之间的用户记录数量占全部记录数量90%以上，那么如果使用idx_name_birthday_phone_number索引的话，有90%多的id值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。

### 覆盖索引

为了彻底告别回表操作带来的性能损耗：**最好在查询列表里只包含索引列**

### 如何挑选索引

#### 只为用于搜索、排序或分组的列创建索引

#### 考虑列的基数

**列的基数**指的是某一列中不重复数据的个数，比方说某个列包含值 `2, 5, 8, 2, 5, 8, 2, 5, 8`，虽然有 9 条记录，但该列的基数却是 `3`。也就是说，在**记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中**。

假设某个列的基数为 1，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了

而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。

**最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好**。

#### 索引列的类型尽量小

以整数类型为例，有 `TINYINT`、`MEDIUMINT`、`INT`、`BIGINT` 这么几种，它们占用的存储空间依次递增，我们这里所说的**类型大小指的就是该类型表示的数据范围的大小**。

在表示的整数范围允许的情况下，**尽量让索引列使用较小的类型**：

- 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）
- 数据类型越小，**索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率**。

#### 冗余和重复索引

## 索引选择异常和处理

一种方法是，采用force index强行选择一个索引。

```sql
set long_query_time=0;
select * from t where a between 10000 and 20000; /*Q1*/
select * from t force index(a) where a between 10000 and 20000;/*Q2*/
```

第二种方法就是，我们可以考虑修改语句，引导MySQL使用我们期望的索引。
第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。
