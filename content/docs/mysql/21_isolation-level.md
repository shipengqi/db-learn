---
title: 事务的隔离级别
---

```sql
CREATE TABLE hero (
    number INT,
    name VARCHAR(100),
    country varchar(100),
    PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8;
```

## 事务并发执行遇到的问题

当数据库上多个事务并发执行的时候，就可能出现**脏写**（Dirty Write）、**脏读**（Dirty Read）、**不可重复读**（Non-Repeatable Read）、
**幻读**（Phantom Read）的问题。

问题按照严重性来排序：

```
脏写 > 脏读 > 不可重复读 > 幻读
```

### 脏写

"脏写"是指，**一个事务修改了另一个未提交事务修改过的数据**。

### 脏读

"脏读"是指，**一个事务读到了另一个未提交事务修改过的数据**。

### 不可重复读

"不可重复读"是指，**一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值**。

![](../../../images/un-repearable-read-sample.jpg)

如上图在 Session B 中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了 number 列为 1 的记录的列 name 的值，每次事务提交之后，Session A 中的事务都可以查看到最新的值，这就是不可重复读。

### 幻读

"幻读"是指。**一个事务先根据某些条件查询出了一些记录，然后另一个事务又向表中插入了一些符合这些条件的记录，第一个事务再次使用相同条件查询时，把另一个事务插入的记录也读出来了**。

![](../../../images/phantom-read-sample.jpg)

如上图，Session A 中的事务先根据条件 `number > 0` 这个条件查询表 hero，得到了 name 列值为'刘备'的记录；之后 Session B 中提交了一个隐式事务，该事务向表 hero 中插入了一条新记录；之后 Session A 中的事务再根据相同的条件 `number > 0` 查询表 hero，得到的结果集中包含了 Session B 中的事务新插入的那条记录，这就是幻读。

> 那对于先前已经读到的记录，之后记录被别的事物删除了，导致又读取不到了，这种情况，算不算幻读？这不属于幻读，幻读只是重点强调了读取到了之前读取没有获取到的记录。

## 四种隔离级别

为了解决事务并发执行遇到的问题，就有了**隔离级别**的概念。SQL 标准中设立了 4 个隔离级别：

- `READ UNCOMMITTED`：**读未提交**是指，一个事务还没提交时，它做的变更就能被别的事务看到。可能发生脏读、不可重复读和幻读问题。
- `READ COMMITTED`：**读已提交**是指，一个事务提交之后，它做的变更才会被其他事务看到。可能发生不可重复读和幻读问题，但是不可以发生脏读问题。
- `REPEATABLE READ`：**可重复读**是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可能发生幻读问题，但是不可以发生脏读和不可重复读的问题。
- `SERIALIZABLE`：**可串行化**是指，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

MySQL 的默认隔离级别为 `REPEATABLE READ`。**MySQL在 `REPEATABLE READ` 隔离级别下，是可以禁止幻读问题的发生的**。

**隔离级别越低，越严重的问题就越可能发生**。

### 设置事务的隔离级别

```sql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
```

level可选值有4个：REPEATABLE READ，READ COMMITTED，READ UNCOMMITTED，SERIALIZABLE

启动参数 `transaction-isolation` 可以设置事务的默认隔离级别。

## MVCC 原理

InnoDB 存储引擎它的聚簇索引记录中都包含两个必要的隐藏列：

- `trx_id`：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。
- `roll_pointer`：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表。对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为**版本链**。

**版本链的头节点就是当前记录最新的值**。

### ReadView

对于使用READ UNCOMMITTED隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；对于使用SERIALIZABLE隔离级别的事务来说，设计InnoDB的大叔规定使用加锁的方式来访问记录。

对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：**需要判断一下版本链中的哪个版本是当前事务可见的**。

ReadView中主要包含4个比较重要的内容：

- `m_ids`：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。
- `min_trx_id`：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是 `m_ids` 中的最小值。
- `max_trx_id`：表示生成ReadView时系统中应该分配给下一个事务的id值。
- `creator_trx_id`：表示生成该ReadView的事务的事务id。

> 只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。

- 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
- 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
- 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

**如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本**。
如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。

**READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了**。
