---
title: Join 原理
weight: 8
---

**`JOIN` 的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户**。

![join-cartesian-product](https://raw.gitcode.com/shipengqi/illustrations/files/main/db/join-cartesian-product.png)

这个过程看起来就是把 `t1` 表的记录和 `t2` 的记录连起来组成新的更大的记录，所以这个查询过程称之为**连接查询**。

连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为**笛卡尔积**。

表 `t1` 中有 3 条记录，表 `t2` 中也有 3 条记录，所以这两个表连接之后的笛卡尔积就有 `3×3=9` 行记录。

连接查询的语法也很随意，只要在 `FROM` 语句后边跟多个表名就好了，例如 `SELECT * FROM t1, t2;`。

## 内连接和外连接

对于**内连接**的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，上边提到的连接都是**内连接**。

对于**外连接**的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。

外连接仍然可以为 2 种：

- 左外连接，选取左侧的表为驱动表。
- 右外连接，选取右侧的表为驱动表。

## 内连接

## 外连接

**内连接中的 `WHERE` 子句和 `ON` 子句是等价的**。

一般情况下，**只涉及单表的过滤条件放到 `WHERE` 子句中，把涉及两表的过滤条件都到 `ON` 子句中**，一般把放到 `ON` 子句中的过滤条件称之为**连接条件**。

## 连接的原理

**对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍**，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。

内连接查询的大致过程：

1. 选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。
2. 对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。
3. 如果有 3 个表进行连接的话，那么步骤 2 中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上边过程

```
for each row in t1 {   #此处表示遍历满足对t1单表查询结果集中的每一条记录

    for each row in t2 {   #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录

        for each row in t3 {   #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询
            if row satisfies join conditions, send to client
        }
    }
}
```

这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为**嵌套循环连接**（Nested-Loop Join），这是最简单，也是最笨拙的一种连接查询算法。

### 使用索引加快连接速度

```sql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

查询驱动表t1后的结果集中有两条记录，嵌套循环连接算法需要对被驱动表查询2次：

当 `t1.m1 = 2` 时，去查询一遍 t2 表，对 t2 表的查询语句相当于：

```sql
SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 < 'd';
```

当 `t1.m1 = 3` 时，再去查询一遍 t2 表，此时对 t2 表的查询语句相当于：

```sql
SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 < 'd';
```

`t1.m1 = t2.m2` 这个涉及两个表的过滤条件在针对 t2 表做查询时关于 t1 表的条件就已经确定了，所以我们只需要单单优化对 t2 表的查询了

- 在 m2 列上建立索引，因为对 m2 列的条件是等值查找，比如 `t2.m2 = 2、t2.m2 = 3` 等，所以可能使用到 ref 的访问方法。假设使用ref的访问方法去执行对t2表的查询的话，需要回表之后再判断t2.n2 < d这个条件是否成立。

- 在n2列上建立索引，涉及到的条件是t2.n2 < 'd'，可能用到range的访问方法，假设使用range的访问方法对t2表的查询的话，需要回表之后再判断在m2列上的条件是否成立。

假设m2和n2列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对t2表的查询。当然，建立了索引不一定使用索引，只有在**二级索引 + 回表**的代价比全表扫描的代价更低时才会使用索引。

有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用 `eq_ref`、`ref`、`ref_or_null` 或者 `range` 这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是 `index` 的访问方法来查询被驱动表。所以工作中**最好不要使用 `*` 作为查询列表**，最好把真实用到的列作为查询列表。

### 基于块的嵌套循环连接（Block Nested-Loop Join）

扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。现实生活中几百万、几千万甚至几亿条记录的表到处都是。内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。采用嵌套循环连接算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个 I/O 代价就非常大了，所以要想办法：**尽量减少被驱动表的访问次数**。

当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，**驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次**。所以可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。

`join buffer` 就是执行连接查询前申请的一块固定大小的内存，先把**若干条驱动表结果集中的记录装在这个 `join buffer` 中**，然后开始扫描被驱动表，**每一条被驱动表的记录一次性和 join buffer 中的多条驱动表记录做匹配**，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 I/O 代价。

最好的情况是 join buffer 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。这种加入了 join buffer 的嵌套循环连接算法称之为**基于块的嵌套连接**（Block Nested-Loop Join）算法。

这个join buffer的大小是可以通过启动参数或者系统变量join_buffer_size进行配置，默认大小为262144字节（也就是256KB），最小可以设置为128字节。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大join_buffer_size的值来对连接查询进行优化。

{{< callout type="info" >}}
注意，驱动表的记录并不是所有列都会被放到 `join buffer` 中，只有查询列表中的列和过滤条件中的列才会被放到 `join buffer` 中。所以**最好不要把 `*` 作为查询列表**，只需要把我们关心的列放到查询列表就好了，这样还可以在 `join buffer` 中放置更多的记录。
{{< /callout >}}